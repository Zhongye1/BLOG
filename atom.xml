<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柊野的博客</title>
  
  
  <link href="https://zhongye1.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/"/>
  <updated>2024-09-03T15:58:02.105Z</updated>
  <id>https://zhongye1.github.io/</id>
  
  <author>
    <name>柊野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>制作自己的校园网路由器</title>
    <link href="https://zhongye1.github.io/posts/1e8f513f.html"/>
    <id>https://zhongye1.github.io/posts/1e8f513f.html</id>
    <published>2024-09-03T15:43:18.000Z</published>
    <updated>2024-09-03T15:58:02.105Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="怎么制作自己的校园网路由器（广州大学版）"><a href="#怎么制作自己的校园网路由器（广州大学版）" class="headerlink" title="怎么制作自己的校园网路由器（广州大学版）"></a>怎么制作自己的校园网路由器（广州大学版）</h1><p><img src="https://www.talaxy.site/static/fb1ffc836d6d829688c0ba281ed33cca/3999e/img.png" alt="动手编译适合自己路由器的 ipk"></p><p><strong>2024年更</strong></p><p>庆已使用web端进行校园网认证，路由器已经不再需要使用插件登录模拟登录</p><p>但是同时一个账户只能有一台设备通过web登录，包括无感登录的设备，即最多只有两台设备可以直接接入校园网</p><p>而使用锐捷认证的不记在内，也就是说可以同时有3台设备直接接入校园网，如果带多台设备上课的话体验有比较大的提升</p><p>对于多人使用的情况，使用插件登录也不会占用某人的校园网账号，导致某人无法使用校园网wifi，有利于宿舍和谐</p><p>我现在是使用方式是在宿舍的电脑用web登录，在教学区通过手机热点让其他设备接入，勉强能用（校园网本来就烂，经过手机转发雪上加霜，导致远程桌面延时明显提升）</p><p>最后，这项技术对于普通的同学意义已经不是很大了，但也算是10年代技术大佬为后人留下的丰碑吧</p><hr><p>庆用的是锐捷的系统，你能买到的锐捷校园网路由器都大同小异，直接购买即可</p><p>此文主要是写给愿意折腾的同学，将我本人组all in one服务器踩到的一些坑分享给大家，如果你想用树莓派软路由、x86虚拟机软路由抑或是自行刷机，甚至是想做路由器赚钱，都可以参考此文</p><p>不多bb，我们所要做的就是在路由器上安装一个插件，用这个插件客户端进行认证，以此来接入校园网</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185331-b6mr6li-20240523140847-q34j0zx.png" alt="image"></p><p>主流的插件有华中科技大学大佬开发的mentohust</p><p><a href="https://github.com/hyrathb/mentohust">hyrathb/mentohust: mentohust加入v4支持 (github.com)</a></p><p>和其算法开发的minieap</p><p><a href="https://github.com/updateing/minieap">updateing/minieap: 可扩展的 802.1x 客户端，带有锐捷 v3 (v4) 算法插件支持 (github.com)</a></p><p>minieap庆内亲测可用，以下以minieap为例</p><h2 id="一、装系统"><a href="#一、装系统" class="headerlink" title="一、装系统"></a>一、装系统</h2><p>主流的开源路由器系统为openwrt，各种插件也是基于此开发的，先给你的机子安装上openwrt，方法各异自行百度，也可以直接买刷好op的</p><h2 id="二、搞到插件"><a href="#二、搞到插件" class="headerlink" title="二、搞到插件"></a>二、搞到插件</h2><p>openwrt是基于linux的，不同的处理器都可以安装openwrt，但编译好的固件只能用于一种架构的处理器，如果网上找不到，只能自行编译插件（编译环境的处理器架构和最终成品的处理器架构没关系）</p><p>我们需要编译minieap-gzhu、luci-proto-minieap，前者为认证插件本体，后者为其界面，openwrt的软件包是ipk文件</p><p>个人编译的x86架构插件，x86软路由或者x86虚拟机可直接用</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1l1w2RH00jnfrvuKwjdzL_g">百度网盘-链接不存在</a> <strong>(已联系作者，等待补档中)</strong></p><p>提取码：k10j</p><p>本文参考 <a href="https://www.talaxy.site/mentohust-minieap/">动手编译适合自己路由器的 ipk | 雪山深处 (talaxy.site)</a> 另一位学长的教程</p></blockquote><h3 id="0-准备好魔法环境"><a href="#0-准备好魔法环境" class="headerlink" title="0. 准备好魔法环境"></a>0. 准备好魔法环境</h3><p>dddd</p><h3 id="1-安装linux环境"><a href="#1-安装linux环境" class="headerlink" title="1. 安装linux环境"></a>1. 安装linux环境</h3><p>推荐使用wsl或者其他虚拟机（虚拟机网络请使用nat模式）方法自行百度</p><h3 id="1-5-推荐使用ssh控制linux用scp拷文件（直接在虚拟机钟使用图形化界面也不是不行）"><a href="#1-5-推荐使用ssh控制linux用scp拷文件（直接在虚拟机钟使用图形化界面也不是不行）" class="headerlink" title="1.5 推荐使用ssh控制linux用scp拷文件（直接在虚拟机钟使用图形化界面也不是不行）"></a>1.5 推荐使用ssh控制linux用scp拷文件（直接在虚拟机钟使用图形化界面也不是不行）</h3><p>安装ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>宿主机推荐使用winscp客户端连接虚拟机ssh</p><h3 id="2-安装编译环境依赖"><a href="#2-安装编译环境依赖" class="headerlink" title="2. 安装编译环境依赖"></a>2. 安装编译环境依赖</h3><p>终端钟敲入以下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git-core build-essential libssl-dev libncurses5-dev unzipgawk subversion mercurial</span><br><span class="line">sudo apt-get install ccache</span><br></pre></td></tr></table></figure><h3 id="3-下载openwrt-sdk（openwrt编译工具）并解压"><a href="#3-下载openwrt-sdk（openwrt编译工具）并解压" class="headerlink" title="3. 下载openwrt sdk（openwrt编译工具）并解压"></a>3. 下载openwrt sdk（openwrt编译工具）并解压</h3><p>推荐解压目录到~目录，否则有报错的可能，注意，不可使用root账户编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://downloads.openwrt.org/releases/21.02.0/targets/x86/64/openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64.tar.xz</span><br><span class="line">xz -dk openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64.tar.xz</span><br><span class="line">tar xvf openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64.tar</span><br></pre></td></tr></table></figure><p>该命令目的在于把文件sdk文件解压到~/目录，如果上述命令执行失败，可以手动将压缩包解压后上传linux</p><h3 id="4-开始编译"><a href="#4-开始编译" class="headerlink" title="4. 开始编译"></a>4. 开始编译</h3><h4 id="a-编译minieap-gzhu"><a href="#a-编译minieap-gzhu" class="headerlink" title="a. 编译minieap-gzhu"></a>a. 编译minieap-gzhu</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>进入sdk目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ysc3839/openwrt-minieap.git -b gzhu package/minieap</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>将插件源码克隆到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>进入编译菜单，依次选择 “Network” “minieap” “save” “OK” 然后退出到命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make package/minieap/compile V=s</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>开始编译</p><p>ipk 文件就在 bin/packages/(处理器架构)/base/</p><h4 id="b-编译luci-proto-minieap"><a href="#b-编译luci-proto-minieap" class="headerlink" title="b. 编译luci-proto-minieap"></a>b. 编译luci-proto-minieap</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64</span><br></pre></td></tr></table></figure><p>进入sdk目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/feeds update luci</span><br><span class="line">./scripts/feeds install-a</span><br></pre></td></tr></table></figure><p>安装 luci feed</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ysc3839/luci-proto-minieap.git package/luci-proto-minieap</span><br></pre></td></tr></table></figure><p>将插件源码克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>进入编译菜单，依次选择依次选择 “LuCI” “Protocols” “luci-proto-minieap” “save” “OK” 然后退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make package/luci-proto-minieap/compile V=s</span><br></pre></td></tr></table></figure><p>开始编译</p><p>ipk 文件就在 bin/packages/(处理器架构)/base/</p><h2 id="三、-安装插件"><a href="#三、-安装插件" class="headerlink" title="三、 安装插件"></a>三、 安装插件</h2><p>将刚刚得到的ipk包传入openwrt系统中，如果你的openwrt安装了文件传输插件，那可以直接用，如果没有，也可以用ssh传上去，以下演示假设传到了根目录上</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185404-j1pryjq-20240523140847-fdmqe0f.png" alt="image"></p><p>菜单栏选择“系统”&gt;&gt; “软件包”（外观不同，但是选项应该是一样的）</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185411-71u1wdu-20240523140847-scegqzs.png" alt="image"></p><p>直接点击安装即可，如果没有文件管理插件或者是你的文件管理插件没有这个功能</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185431-iipews6-20240523140848-lvse9vy.png" alt="image"></p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185426-lereul2-20240523140848-t2bv084.png" alt="image"></p><p>点击确认即可安装</p><h2 id="四、-使用插件"><a href="#四、-使用插件" class="headerlink" title="四、 使用插件"></a>四、 使用插件</h2><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185441-2vywcuq-20240523140848-iqrhv3j.png" alt="image"></p><p>点击“网络”&gt;&gt; “接口”</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185444-w4mjro7-20240523140848-9jjf83q.png" alt="image"></p><p>选择“新接口”</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185448-8nedism-20240523140849-h93yhbr.png" alt="image"></p><p>协议选择“MiniEAP client”，名字随便，接口选择你的wan口，每个接口对应一个物理接口或者虚拟接口，需要根据自己的实际情况选择，该接口要连接到宿舍校园网网口</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185452-ntvaqpm-20240523140849-q0hetku.png" alt="image"></p><p>账户密码就是你校园网的，Packet plugins选我这个</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185458-rm0nx1f-20240523140849-111kgo7.png" alt="image"></p><p>然后将DHCP type改成我这个</p><p>不出意外的话就可以愉快使用了</p><p>转自：<a href="https://blog.carry.fit/archives/how-to-make-your-own-campus-network-guangzhou-university-edition-avb6x">怎么制作自己的校园网路由器（广州大学版） - carry blog</a></p>]]></content>
    
    
    <summary type="html">如何制作自己的校园网路由器（广州大学版）</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="校园网" scheme="https://zhongye1.github.io/tags/%E6%A0%A1%E5%9B%AD%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>关于Jupyter汉化问题</title>
    <link href="https://zhongye1.github.io/posts/3de5091.html"/>
    <id>https://zhongye1.github.io/posts/3de5091.html</id>
    <published>2024-09-02T15:49:05.000Z</published>
    <updated>2024-09-02T15:58:47.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决新版Jupyter-notebook-v7-0-0及以上-汉化、默认保存路径等问题"><a href="#解决新版Jupyter-notebook-v7-0-0及以上-汉化、默认保存路径等问题" class="headerlink" title="解决新版Jupyter notebook(v7.0.0及以上)汉化、默认保存路径等问题"></a>解决新版Jupyter notebook(v7.0.0及以上)汉化、默认保存路径等问题</h2><h3 id="一-Jupyter-notebook-v7-0-0及以上汉化"><a href="#一-Jupyter-notebook-v7-0-0及以上汉化" class="headerlink" title="一. Jupyter notebook v7.0.0及以上汉化"></a>一. Jupyter notebook v7.0.0及以上汉化</h3><p><strong>注意！在环境变量中添加如下用户变量仅适用于Jupyter v6及以下版本，不再适用于Jupyter v7</strong><br><img src="https://free-img.400040.xyz/4/2024/09/02/66d5df36ec7d2.png" alt="在这里插入图片描述"><br><strong>Jupyter v7汉化方法如下</strong></p><p>1.打开<a href="https://so.csdn.net/so/search?q=命令行&amp;spm=1001.2101.3001.7020">命令行</a>或者Anaconda Prompt，运行如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyterlab-language-pack-zh-CN</span><br></pre></td></tr></table></figure><p>2.运行Jupyter notebook，选择settings中的Language，替换中文<br><img src="https://free-img.400040.xyz/4/2024/09/02/66d5df33aa570.png" alt="在这里插入图片描述"></p><h3 id="二-修改Jupyter-notebook默认保存路径"><a href="#二-修改Jupyter-notebook默认保存路径" class="headerlink" title="二. 修改Jupyter notebook默认保存路径"></a>二. 修改Jupyter notebook默认保存路径</h3><p><strong>这里先介绍一种万能（不嫌麻烦）的方法</strong><br>1.打开命令行或者Anaconda Prompt，运行如下代码，其中D:\JupyterWorkspace可以修改成你想要Jupyter保存的任意路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook D:\JupyterWorkspace</span><br></pre></td></tr></table></figure><p><strong>这种方法的优点是很灵活<br>缺点是每次启动都需要用命令行或者Anaconda Prompt</strong></p><p><strong>下面介绍一种一本万利（fu za）的方法</strong><br>1.打开命令行或者Anaconda Prompt，运行如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>2.运行后会提示创建完jupyter_notebook_config.py文件，以及它所在的路径，我们直接复制路径找到这个.py文件<br>3.用记事本打开它，CTRL+F查找<strong>notebook_dir</strong>，会搜索到这一行（适用旧版）<br>3.用记事本打开它，CTRL+F查找<strong>root_dir</strong>，会搜索到这一行（适用新版）</p><blockquote><p>#c.NotebookApp.notebook_dir = ‘path’ # 旧版查找这一行<br>#c.ServerApp.root_dir = ‘path’ # 更正，最新版应该查找这一行</p></blockquote><p>有些电脑搜到的可能是#c.ServerApp.notebook_dir = ‘path’，不过没什么影响<br>4.将path替换成自己想要保存的路径，直接复制文件夹路径的话一定要将 \ 改成 // ，并将这一行前面的#去掉**，保存文件<br>5.右键Jupyter notebook选择属性，按下图设置即可<br><img src="https://free-img.400040.xyz/4/2024/09/02/66d5df33b83ca.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">解决新版Jupyter(v7.0.0及以上)汉化、默认保存路径等问题</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>自定义VSCode背景图片</title>
    <link href="https://zhongye1.github.io/posts/533329c2.html"/>
    <id>https://zhongye1.github.io/posts/533329c2.html</id>
    <published>2024-09-02T15:39:00.000Z</published>
    <updated>2024-09-02T15:56:33.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于如何自定义VSCode背景图片"><a href="#关于如何自定义VSCode背景图片" class="headerlink" title="关于如何自定义VSCode背景图片"></a>关于如何自定义VSCode背景图片</h2><h4 id="1-以管理员身份运行VS-Code，安装background插件"><a href="#1-以管理员身份运行VS-Code，安装background插件" class="headerlink" title="1.以管理员身份运行VS Code，安装background插件"></a>1.以管理员身份运行VS Code，安装background插件</h4><p><img src="https://pica.zhimg.com/80/v2-b5a35f698b7589c7090b1bfa2a2963b8_720w.webp" alt="img"></p><h4 id="2-打开setting，在搜索框中输入background，选择扩展中的plugin-background，选择在setting-json中编辑"><a href="#2-打开setting，在搜索框中输入background，选择扩展中的plugin-background，选择在setting-json中编辑" class="headerlink" title="2.打开setting，在搜索框中输入background，选择扩展中的plugin background，选择在setting.json中编辑"></a>2.打开setting，在搜索框中输入background，选择扩展中的plugin background，选择在setting.json中编辑</h4><p><img src="https://pic3.zhimg.com/80/v2-3e406502b1294ad2bcc6a9425c208eb2_720w.webp" alt="img"></p><h4 id="3-在用户设置中输入以下代码，修改完后保存，会提示重启VS-Code，点击确定后即可完成修改"><a href="#3-在用户设置中输入以下代码，修改完后保存，会提示重启VS-Code，点击确定后即可完成修改" class="headerlink" title="3.在用户设置中输入以下代码，修改完后保存，会提示重启VS Code，点击确定后即可完成修改"></a>3.在用户设置中输入以下代码，修改完后保存，会提示重启VS Code，点击确定后即可完成修改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//background 的相关配置</span></span><br><span class="line">    <span class="string">&quot;update.enableWindowsBackgroundUpdates&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;background.customImages&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;file:///F:/Picture/Yukino/vs_background.png&quot;</span><span class="comment">//图片地址（支持http</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;background.style&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;content&quot;</span>:<span class="string">&quot;&#x27;&#x27;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pointer-events&quot;</span>:<span class="string">&quot;none&quot;</span>,</span><br><span class="line">        <span class="string">&quot;position&quot;</span>:<span class="string">&quot;absolute&quot;</span>,<span class="comment">//图片位置</span></span><br><span class="line">        <span class="string">&quot;width&quot;</span>:<span class="string">&quot;100%&quot;</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>:<span class="string">&quot;100%&quot;</span>,</span><br><span class="line">        <span class="string">&quot;z-index&quot;</span>:<span class="string">&quot;99999&quot;</span>,</span><br><span class="line">        <span class="string">&quot;background.repeat&quot;</span>:<span class="string">&quot;no-repeat&quot;</span>,</span><br><span class="line">        <span class="string">&quot;background-size&quot;</span>:<span class="string">&quot;25%,25%&quot;</span>,<span class="comment">//图片大小</span></span><br><span class="line">        <span class="string">&quot;opacity&quot;</span>:<span class="number">0.2</span> <span class="comment">//透明度</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;background.useFront&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;background.useDefault&quot;</span>: <span class="literal">false</span>,<span class="comment">//是否使用默认图片</span></span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-504cbda92dbe5de68c9372b9b8197a31_720w.webp" alt="img"></p><p>效果如下：</p><p><img src="https://pica.zhimg.com/80/v2-3ba8478d3556441d49b22ac1598855ee_720w.webp" alt="img"></p>]]></content>
    
    
    <summary type="html">关于如何自定义VSCode背景图片</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>九月</title>
    <link href="https://zhongye1.github.io/posts/fd12c93d.html"/>
    <id>https://zhongye1.github.io/posts/fd12c93d.html</id>
    <published>2024-09-01T08:30:15.000Z</published>
    <updated>2024-09-03T15:40:21.718Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="tip "><p>9月1日</p></div><p><img src="https://pic4.zhimg.com/80/v2-5415b3941d1e8c38796689255c41f7c7_720w.webp" alt="img" style="zoom:50%;" /></p><p><img src="https://pic2.zhimg.com/80/v2-b741d4b5996a9d758d16ce1887a15979_720w.webp" alt="img" style="zoom:50%;" /></p><p><img src="https://pic1.zhimg.com/80/v2-038b40ade38253649ea6c49bd73f4578_720w.webp" alt="img" style="zoom:50%;" /></p><p>满校区跑，开学焦虑了</p><p>顺便混了下图书馆,借了几本关于网站建设的书。</p><p>翻了下RSS订阅时，读到一段话</p><blockquote><p>今天好像有一股力量在努力把这些超越性的东西从我们的社会生活里清理出去。</p><p>人很渺小，但是人不应该因为自己渺小就要消灭所有伟大。</p><blockquote><p><a href="https://lenciel.com/2024/08/bu-er-qi-xi/">不二与偏要二 - @Lenciel</a></p></blockquote></blockquote><hr><div class="tip "><p>9月2日</p></div><p>概率论挂科率高？我卷死你</p><p>重装了下python</p><p>大一完全是瞎搞，把一堆东西瞎装，现在重新清理一下</p><p><img src="https://pic1.zhimg.com/80/v2-60f4739c4831e87cdabcc073c6bb9b56_720w.webp" alt="img"></p><p>毕竟要开课了</p><p>虽然觉得VScode更好用</p><p>日后再说</p><hr><div class="tip "><p>9月3日</p></div><p>老师推荐的logseq做笔记没博客好用</p><p>都是写markdown，博客还支持HTML CSS JS 各种页面和嵌入</p><p>不过这个归档页面不错</p><p><img src="https://free-img.400040.xyz/4/2024/09/03/66d72d9cc24ea.png" alt="img"></p>]]></content>
    
    
    <summary type="html">关于九月份的琐事</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://zhongye1.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>八月</title>
    <link href="https://zhongye1.github.io/posts/87dfe862.html"/>
    <id>https://zhongye1.github.io/posts/87dfe862.html</id>
    <published>2024-08-29T16:31:02.000Z</published>
    <updated>2024-08-31T14:44:13.438Z</updated>
    
    <content type="html"><![CDATA[<div class="tip "><p>8月1日</p></div><div class="fj-gallery"><p><img src="https://pic3.zhimg.com/80/v2-193d7b78c90201ecbf616cc0a07ce5aa_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-1e5f7949d227f9c8e619d1590968768b_720w.webp" alt="img"></p>          </div><p>到货了，好好好</p><ul><li></li></ul><p>今天NAS建站的尝试是暂时失败了，校园墙的复活有点难</p><p>其实部署网站就之前续费雨云30块一个月服务器的事，简单的很，</p><p>绕这么多弯路存粹不想多花钱（</p><p>不过校园墙这块还是让别人来做算了</p><p>我这种人搞不好的，毕竟运营力大于技术能力，之前搭好了也没人访问</p><p>毕竟让一个进入大学以来几乎没有社交的人来运营的话就是不太合适</p><ul><li></li></ul><p>有时间不如刷番刷漫画啥的</p><p><img src="https://pic1.zhimg.com/v2-b2ee8e1083fda5de4e42aa144af19b60_b.jpg" alt="img"></p><hr><div class="tip "><p>8月3日</p></div><p>尝试搞个QQ机器人<br>接一个GPT<br>不过搭好后好像很鸡肋<br>遂搁置</p><hr><div class="tip "><p>8月4日</p></div><p>给博客加了个访客IP地图</p><p>虽然真要实现预想的效果要做个后端来着（</p><p>也没有搞，有个效果就行</p><p><img src="https://pic3.zhimg.com/80/v2-deb7fa83da6accc4def5a21d5bca886a_720w.webp" alt="img"></p><p><em>（百度的API好烂）</em><br>成品如下：</p><div class="site-card-group"><a class="site-card" href="https://zhongye1.github.io/posts/a8a0d075.html"><div class="img"><img src="https://pic3.zhimg.com/80/v2-deb7fa83da6accc4def5a21d5bca886a_720w.webp"/></div><div class="info"><img src="https://pic1.zhimg.com/80/v2-88d2ec402c1018cec57110c295e85a30_720w.webp"/><span class="title">Blogmap</span><span class="desc">博客访客IP</span></div></a></div><hr><div class="tip "><p>8月5日</p></div><p>所以说暑假就是一段迷茫的时间，除了搁置许久的项目和令人昏昏欲睡的又湿又热的天气没什么其他的什么。</p><p>还要考驾照，不知道要折腾到什么时候，反正回老家得等到寒假了</p><p>…</p><p>放个歌</p>    <div id="aplayer-KOxVeErG" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2020981543" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><em>~~~ 你知道掉下的不是眼泪</em></p><p><img src="https://picx.zhimg.com/80/v2-1492e41f463a164d71062de4e615d7ad_720w.webp?source=d16d100b" alt="img"></p><hr><div class="tip "><p>8月7日</p></div><p>那个驾校的是个究极压力怪</p><p>一想以后还会遇到越来越多这样的人（虽然以前也有一堆）</p><p>这样的话在大学毕业后要和许多这样的人打交道的话</p><p>以后还会出现啥其他情况也说不定</p><p>这就显得让人头疼了</p><p>=============================================</p><p>给博客加了个新页面，扒了一些代码</p><p>反正没人会看的，（好中二）</p><p>就这样吧，附上SITEPOST和<a href="https://zhongye1.github.io/AKN/">链接</a></p><img src="https://pic4.zhimg.com/80/v2-2cab37aed4fd6e18c2c86aef17568beb_720w.webp" alt="img" style="zoom:50%;" /><center>https://zhongye1.github.io/AKN/</center><p>曾希望能在某段经历的时间段中能多留一点，结果是这个想法连着这段不舍的经历一同忘去，</p><p>最后自己去迎接将来那些破事。</p><hr><div class="tip "><p>8月14日</p></div><p><img src="https://pica.zhimg.com/80/v2-29276bc35ff75d9738058a97a5e8872f_720w.webp?source=d16d100b" alt="img"></p><p>啊，是的没多久我的暑假也要结束了</p><p>莫名伤感</p><p>好嘛，下半年比谁都要忙的来着</p><p>也无所谓了</p><img src="https://pic4.zhimg.com/80/v2-187b2461e74eb982b34e7b177b654243_720w.webp" alt="img" style="zoom:67%;" /><p>看到有人拿我的模型做mod还是挺高兴的，没想到还会有被称为佬的一天（</p><img src="https://pic2.zhimg.com/80/v2-1a0251a342876b19b20aa5ed2cb2bc49_720w.webp" alt="img" style="zoom:67%;" /><p>附一张blender摸鱼的记录</p><p>暑假结束的话又要回广州，下半年的话希望新舍友会好点（虽然平时大概率宅图书馆</p><p>希望生活对我也好点。</p><p>.</p><p>其实过的怎么样还是怎么样，不过有点愿景的话也好点</p><p>面对这些的话还是要靠自己</p><p>.</p><p>.</p><p>想当初同感的一个人看上去孤独的人是一个超级现充</p><p>（艹</p><p>这是好事</p><ul><li></li></ul><p>我一想这一年：</p><p>读大学以来几乎没社交</p><p>认识的人都不认识自己</p><p>从没有和人一起出去过</p><p>爱好也完美的岔开了</p><p>不满消费主义和购物街旅游景区</p><p>经常听摇滚又不摇滚</p><p>天天发病然后留黑历史</p><p>经常晚上偷偷写博客</p><p>然后第二天爬起来把写的一堆东西删掉</p><p>经常普通话不标准</p><p>自己还听不出来</p><p>qq资料卡别人都几千赞上万赞</p><p>自己8年老号就百来个赞</p><p>宅</p><p>不喜欢流行文化</p><p>而喜欢上个世纪的东西</p><p>经常几个番反复看又不想看新番</p><p>游戏打不动</p><p>经常囊中羞涩</p><p>经常喜欢捣鼓些有的无的</p><p>喜欢冷门的东西又不想火起来</p><p>（比方说喜欢的乐队火起来就不纯粹了</p><p>（成了网红热门乐队的话还会摇滚吗</p><p>经常写些没人看的东西</p><p>同时很多想法还没记下来就第二天了</p><p>…</p><p>扯远了</p><p>反正我预感大学四年我也交不到几个朋友</p><p>只会忙些有的无的</p><p>然后毕业了去社会了还会一个人吗(倒)</p><p>然后就理所当然的是职场和加班吗</p><p>以前还幻想过搞科研来着</p><ul><li></li></ul><p>这个社会对不善交际的人的恶意还是太大了</p><p>本以为自己做了许多其实啥都没做</p><p>写博客也是</p><hr><p>这个夏天没能回去</p><p>那下次回去的话就是冬天了吧</p><p>到时候还会有这种原野吗</p><p><img src="https://picx.zhimg.com/80/v2-9d1eb0ef93647afb21f0c22f16142be3_720w.webp?source=d16d100b" alt="img"></p><p><em>黎</em></p><p><em>正月初</em></p><p><em>风吹花遍野</em></p><p><em>低头看野草春生</em></p><p>我多次走到此路上，却永远走不到开县的另一端</p><hr><p>这边的话</p><p>都不容易，</p><p>毕竟我只是个写博客牢骚的屑</p><p>在这个角落写下自己的故事</p><p>然后默默删掉</p><p>…</p><p>生活啊</p><p>我的过往只有过去了</p><p>当一切都变了后</p><p>那时我将走向何方？</p><p>若十几年后一切都翻天覆地</p><p>在时间过去后我还会记得吗</p><p>我生活过的这些日子里</p><p>苍白里的彩色</p><p>这些故事还会继续吗</p><p>还会在吗</p><p>其实会很难的吧…</p><hr><div class="tip "><p>8月18日凌晨</p></div><p><img src="https://pic2.zhimg.com/80/v2-f1f9cc470d441d125d9f0a021009ca79_720w.webp" alt="img"></p><p>也许再过几年生活会因些意外而截然不同</p><p>过去的往往因鲜为人知而被掩饰</p><p>未来的旷野在四面八方</p><p><img src="https://pic3.zhimg.com/80/v2-01619bae5eb61073b060beb53ba2ff1e_720w.webp" alt="img"></p><center>凌晨，夜失眠日益加重，遂出门摄</center><center>风吹草遍野</center><hr><div class="tip "><p>8月19日</p></div><p>总是想起黑历史睡不着</p><p>以后这些事也会一直折磨自己</p><p>…</p>    <div id="aplayer-WCuMaJAa" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1911908203" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>挥之而去</p><p>但愿吧</p><hr><div class="tip "><p>8月27日</p></div><p>这段时间中间空了多少天呢…</p><p>暑假也要结束了吧</p><p>要开学了</p><p>想去江之岛（</p><div class="tip "><p>8月28日</p></div><p>明明家里离海边就几公里依然选择了去几十公里外的海滩玩<br>单纯为了看沙滩</p><p>结果看了场雷雨</p><p>天气差也好，至少沙滩边不会下饺子</p><img src="https://pic4.zhimg.com/80/v2-2606e517c7ca990ae5eae3dba6105abd_720w.webp" alt="img" style="zoom:50%;" /><img src="https://pic1.zhimg.com/80/v2-1d7a3355fc0008bede984deadd8e72dc_720w.webp" alt="img" style="zoom:50%;" /><img src="https://pica.zhimg.com/80/v2-19ceb20ff4583261847dba67c70a88ce_720w.webp" alt="img" style="zoom:50%;" /><p>去的大梅沙（</p><p>（反正算是满足了看番里去江之岛类似地方的执念（（（</p><p>夏天结束了</p><p><s>不想开学</s></p><hr><div class="tip "><p>8月30日</p></div><p>放在学校的东西霉了一堆</p><p>洗到10点钟</p><p><img src="https://pica.zhimg.com/80/v2-94cb52077c39d6731c51a39bf5158aa4_720w.webp" alt="img"></p><p><img src="https://picx.zhimg.com/80/v2-a16fc917483ca6d9164062f47b7329c9_720w.webp" alt="img"></p><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊</p><hr><div class="tip "><p>8月31日</p></div><p><img src="https://pic2.zhimg.com/80/v2-e7966d21c22792195b1ce963ccde2375_720w.webp" alt="img"></p><p>8月底，偶遇老家饭馆</p><p>画个尾声</p><p><strong>晓花我们一起摇滚吧！</strong></p><p><em>end</em></p>    <div id="aplayer-hvZBAPVr" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2012172936" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>]]></content>
    
    
    <summary type="html">“晓花，我们一起摇滚吧”</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>动漫圣地巡礼地图</title>
    <link href="https://zhongye1.github.io/posts/e11696b0.html"/>
    <id>https://zhongye1.github.io/posts/e11696b0.html</id>
    <published>2024-08-29T03:10:01.000Z</published>
    <updated>2024-09-01T08:47:18.811Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;!DOCTYPE html&gt;</p><html lang="zh"><head>    <meta charset="UTF-8">    <meta name="keywords" content="动漫,圣地巡礼,柊野">    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- 响应式视口设置 -->    <title>圣地巡礼地图</title>    <!-- 引入百度地图API -->    <script type="text/javascript" src="https://api.map.baidu.com/api?v=3.0&ak=1XjLLEhZhQNUzd93EjU5nOGQ&s=1"></script>    <style>        html, body {            margin: 0;            padding: 0;            height: 100%;        }        #mapContainer {            width: 100%;            height: calc(100% - 70px); /* 考虑到底部表单的高度 */        }        #searchForm {            display: flex;            flex-direction: column;            align-items: center;            position: fixed;            bottom: 0;            left: 0;            right: 0;            padding: 10px;            background-color: white;            z-index: 1000;        }        #searchForm label, #searchForm input, #searchForm button {            margin-bottom: 5px;        }        @media screen and (max-width: 768px) {            #searchForm label, #searchForm input, #searchForm button {                font-size: 14px;            }        }    </style>    <script>        // 确保BMap对象定义完成后再执行后续代码        window.onload = function() {            let map = null;            // 初始化百度地图            function initBaiduMap() {                map = new BMap.Map("mapContainer");                // 设置地图选项                map.enableScrollWheelZoom(true); // 启用滚轮缩放                map.addControl(new BMap.NavigationControl()); // 添加导航控件                map.addControl(new BMap.ScaleControl()); // 添加比例尺控件                // 设置地图的初始中心点和缩放级别                map.centerAndZoom(new BMap.Point(116.404, 39.915), 12);                return map;            }            // 清除地图上的所有标记            function clearMarkers(map) {                var allOverlays = map.getOverlays();                for (var i = 0; i < allOverlays.length; i++) {                    if (allOverlays[i].setMap) {                        allOverlays[i].setMap(null);                    }                }            }            // 从API获取数据            function fetchLandmarks(subjectID) {                Promise.all([                    fetch(`https://api.anitabi.cn/bangumi/${subjectID}/lite`),                    fetch(`https://api.anitabi.cn/bangumi/${subjectID}/points/detail?haveImage=true`)                ])                .then(responses => Promise.all(responses.map(r => r.json())))                .then(([bangumiData, landmarksData]) => {                    if (!bangumiData || !Array.isArray(landmarksData)) {                        alert('没有找到与提供的Bangumi作品ID匹配的数据QAQ');                        return;                    }                    clearMarkers(map); // 在添加新的地标之前清除旧的标记                    landmarksData.forEach(point => {                        addMarkerToMap(point, map, bangumiData);                    });                    if (bangumiData && bangumiData.geo && bangumiData.zoom) {                        map.centerAndZoom(new BMap.Point(bangumiData.geo[1], bangumiData.geo[0]), bangumiData.zoom);                    }                })                .catch(error => {                    console.error('Error fetching landmarks:', error);                    alert('Error,请输入有效的Bangumi ID😂');                });            }            // 在百度地图上添加标记            function addMarkerToMap(point, map, bangumiData) {                if (!point.geo || !point.geo[0] || !point.geo[1]) {                    console.error('Invalid geo coordinates:', point);                    return;                }                var p = new BMap.Point(point.geo[1], point.geo[0]); // 注意坐标顺序                var marker = new BMap.Marker(p);  // 创建标注                map.addOverlay(marker);              // 将标注添加到地图中                       // 创建信息窗口                var infoWindowContent = `                    <b>${bangumiData ? bangumiData.cn : '未知番剧'}: ${point.cn || '未知地标'}</b><br>                    ${point.name || '未知名称'}<br>                    <img src="${point.image ? point.image.replace('?plan=h160', '?plan=h360') : '无图片'}" width="100" height="auto"><br>                    Origin: ${point.origin || '未知来源'}<br>                    <a href="${point.originURL || '#'}" target="_blank">${point.originURL || '无链接'}</a>                `;  // 创建信息窗口内容                var infoWindow = new BMap.InfoWindow(infoWindowContent);  // 创建信息窗口                marker.addEventListener("click", function(){ // 添加点击事件                    this.openInfoWindow(infoWindow, map, p); // 打开信息窗口                });            }            // 绑定表单提交事件处理程序            document.getElementById('searchForm').addEventListener('submit', function(event) {                event.preventDefault(); // 阻止表单默认提交行为                const subjectID = document.getElementById('subjectID').value;                if (subjectID.trim() === '') {                    alert('请输入有效的Bangumi作品ID。');                    return;                }                fetchLandmarks(subjectID);            });            // 初始化地图            initBaiduMap();        }    </script></head><body>    <div id="mapContainer"></div>    <!-- 底部搜索表单 -->    <form id="searchForm">        <label for="subjectID">请输入Bangumi番剧ID:</label>        <input type="text" id="subjectID" name="subjectID" placeholder="例如: 328609（孤独摇滚）">        <button type="submit">检索</button>        <a href="/posts/ac0edfe5.html">【教程】如何查找Bangumi番剧ID</a>    </form></body></html>]]></content>
    
    
    <summary type="html">圣地巡礼用</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>《孤独摇滚》总作监C102原画集</title>
    <link href="https://zhongye1.github.io/posts/46b5378b.html"/>
    <id>https://zhongye1.github.io/posts/46b5378b.html</id>
    <published>2024-08-21T18:10:43.000Z</published>
    <updated>2024-08-21T18:22:37.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C102-孤独摇滚Bocchi-The-Rock-原画集"><a href="#C102-孤独摇滚Bocchi-The-Rock-原画集" class="headerlink" title="(C102) 孤独摇滚Bocchi The Rock 原画集"></a>(C102) 孤独摇滚Bocchi The Rock 原画集</h2><p>收集的一些电子版</p><div class="fj-gallery"><p><img src="https://imgs.aixifan.com/newUpload/69965585_7b2f01a1d79c47ddb9affe1b9b313399.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e79181eaa4364114b18a6db12efb1116.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f8a030ce0016400096fe2b378d2119a5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9e6ef916f6564dcbbb56870cf53be714.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_009b3798a9774678bff4f5f715210de4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6b6257e200df4f4eba90d66a2734d79d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9d7bcdc4c8544181a4c6dff011dea1b9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c85730552aa14ad9b34d6aeb07fb3d1e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_135d69f8ad294bdbafe4a56f7ab902a9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_474eeb0118f74223b79de7485c4b7899.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fe245b79ea14476583942d512545c1b8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d423619c0daf4b2586040dffc1cfad6c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dd19f9e37dcc4eefa991b6fe3ca9ea3d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_085115097bce4ec890872c7aaba06039.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_05ebaa43a0384855815ca327f8f234e5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_aed0b2e1037a48b988c920f84edf7152.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b393f98223d24887bfee0209c257a51e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_76ab5f8479b043daa2ef187e39028d2e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fb56bc81c22141b0b40fc27cb934cc28.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_58e877016d6d4aeea2f57fbc6927ba84.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_58c9f3263aa044b99f62d8250c9424ad.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c1a1c8b7e7034e2c81ae78225691bd3c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9164527573814d4f8421de8c30fc9d2b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_09eb3469bdc14dbdbf40aa13c7df34ca.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3e5264dc5903455bbcbc8a9bff12b1f5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6b1fe584158f4ae89452acc3be9180c6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9f090b9682494e049cc15ace7a294deb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_65fce27d3cae43c5b366c02dfd7b7e4e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_308093594895421f9c86deed22609c12.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_98c97770513642a698a45e5fc28063b6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3dc41fcf716743dd92928811ae252064.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b08755e2bea646ad9295e73e96da02c1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8f5a56fef0124414aa6594ad35292ef8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_df0c193365bb4186acd533a234513786.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c25b372e3dbc416a98306660f2d7cd67.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2a95e43b460a4c30819e452739248c7b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_339a802422cb413fbec9e489fa9abb32.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c31e578b7be94fadb56898be41de798f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_bb4cd23470f54c249bb581325081d740.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9a35da37616a4100baaf97273d3d93cb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9b6a016a1af14b23b382c9d8c46c3551.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0b5a5925fd0d41caa2315ff847dad182.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0bde84edd0134e4ca4a52819e9f4b986.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d0c38c8aa0104999b21b40ea758db909.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_470bb6028c7649c0ad15ccccfacc44d4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_85ff7da2de054fed962986e8169c0c04.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_861f45a12b3a423bba643d9fbf2bb2d8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_02f1ac0536b142808d348c5b1da12193.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fdce6f354ca247a2ab45fc12dec9659a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_948045aff7754930b4dddb7b6bf948ea.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d9f6003d664d4a3fac8f7e154f309aae.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cbd5f788b5c44259b47962e82c716c62.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3d42ff5cc2304be88b17c1f5b23a2128.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0fe15716c0c74e6c8446d37c30d46b93.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_129af876e8c549699ebade39b7aa7038.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8079412053b74e5f833dbe657e03dca9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c4cfb8c83f9b4076a8692f57f232cddb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_816964addf574e248c8c86690cf4b5a7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0c4c1e57098f445d994727b1953a518b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dc60d2efef8f49039e48561b016644a1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3de414a392134a4e977e250a9f77d216.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b1d752e2e94b4ec8812570ea40223796.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_16a885f23369400196170bee21464fdf.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_17847a101e454adc84579c5a0ee73428.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c32cf4785d9e489dbacff1447baa2fc8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f52a884a49e444cca4eb20be20d3344e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_aca734101b3f40b88aa068636ba1b106.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_978dd39f4cd04f199606bae8c0092c11.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_27390658aa1f4fdd969f7a22a80b2bc5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8bdc09db8fa547608bcff24f01a1a57a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3a996e89fdbd4726a72d8a8e840428d4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_be4a7f0553634e6aa6bf1336f57d016c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_95597f5702584f90b21653c3a512393b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b3e421be309349d1b39b7a950ebd528e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_aa8abf6fa18e47658db494c01c8265ba.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_01aa66537b704bf88ace7c3659b8fb74.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8ecea563e0144143be54aaf927304490.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2f1b444b5515440986438a7b5992b748.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e8dfde0d0aee465387737b5c074f2051.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3315e3c6d75345e59ac21f7e117669b4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_961a83bf5eb34785a693050973388997.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5908a1275a5e43bba46404edf10308fb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_59a5a83ce79747e1a7fd49d3c5df924c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e1927d8533584026945626c68d87d221.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cb664207350b4919a7f86e0b6e733a8f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_eb901413ade946a5b7a9e4d32faff912.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c1c370f31ce647e2baccbfdd0576100e.jpg" alt="img"></p><p><img src="https://imgs.aixifan.com/newUpload/69965585_28d17d77cd58470fb485f5d6d3ae4553.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_68f2e27ecc764ca2ba74d58a47285e6b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d4ae83619ca24ffc9640f46048ac4f25.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_557622a8d41242bd9924dfb7cb4bf948.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7ad23864b8074857a8258b2f981bedb8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d8bcbf487e3e4f6092abc95b432d23b5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_59c42361be3e4dc596bb72a73c8bdbed.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_536ce3bfefe344ee89c411bbbf7f2a6f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_334c58a18a0e40b9871e4be193410d44.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7bb5338f8c6e460c842e3627bc648bc9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ed5afd80586e47b7ad11988fc2ba4178.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_106aa1ab35044e62ac2b916a407a9f13.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_74b2c0ed89f641a2ab9fdd155da75a1a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8b725eb2452b409b82e8c76190d0c5e9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_306ae5bc399d4d339c60f87caaeec2a1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a1b3ec2bc71d41658a6a54fe00fdf23f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_66fffbb767f044c5a9d83c05d991fc23.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8c037f8add9441ca9afd9a444fb3753d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1be0024f5a6548c1a7b8f16103da4460.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a7384c9ba6fe478988b47dc1ee9fbda7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a2ab8fa289a84033acab9c29602dd74d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_30dffafb161f43a49a811859a8bfb8e3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_03cf1a08b49d4b17bd917b9ed455902b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2b2d0df699e44f7391c83fdf8e38b858.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a6d6962d8b354589ab5df30488b8a5f6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_876222daac0a42359476cfc9edc74b3b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d75bc588b76a495f8166e4ba7af40dfd.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_09aa58ebcbb44846b431ea0b8c7034bc.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_67265bc7c58646168b5d13acd0a72c63.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9d162a0de0884469982795b653fce613.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ce80e67d7ac9487aa5f1fce4c7daa349.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1e874e819fab4a7095ee5e5d28d5e4c2.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7bee5510f5b04e90a2a15b19c07ca5be.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a36e1bc091004e1ab23d802e893449f3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_df5292f817754bf88e6eab30ac64ac48.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_30090f56666143f4a5f667f412fa4df3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6e67a0cc4fa945d8913f47a21eaaed5d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5b486acb20d74756a260c26530eb25ee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fd9887b921e84970a4bdbae0c7ccf7f8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_20c9fcb5e07c42abb93f29f570c12b27.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3bcdc61c4ff740fbbc29fba5d34a740a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_491a2e86c90a4b8d9314f996d9f1344f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a3bed59e256342908e3210384ceaf839.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3261785df6604c169bcd7aaa66f3b5fd.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_69db319c189342d0a1e9e9194d96f5be.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2357971202784819bfda29c142608716.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_69b99dd5984b4f2f93d761fb7482df6c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_55df611fc3e9464b9395efa7f9df75e9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_69f671b87e964b17885fd0235f2d37d6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2b5bd2bc8a6e4ac4a0818a55e44d1904.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e65b5370f34447fab43c898119b6baf4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3f362f0e3503470ab0312df8b3ad7229.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9fd9a9cbac66402db529675477d5cdc8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4c5760adc4c343e194e80a1548561a89.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_394a75b701114f45a80ae3511c86bcba.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fef210da87de438f95a411c6e5e6a558.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_caefa9f3d2b0464fa0e7ce58d927199b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_31bd802ca3434827bf6e719dff6850ee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6ae3e49146eb4918bbf722a2c0be37bf.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5745cf3da9ee42c6aebbbf2444dbf124.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5cf10143f7e145be9a80b90d7c7f4312.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e7f1b5d8414c4954a704c76b9594dfc9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ecd1853cc3f548fc800573c7b3c3f751.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2ea29e150f6f4286bb79b38c35f84eeb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a8015ca1db0f4e15b292da85f24a78d9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9e4a384384b24798985a16e3bf197c88.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9193307811774412bb43c8832d0bbf3b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0e553e7857d3486eb064d284bd403ce5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b7590b9d4cbb46e69d13f1e10df2f6f6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6498f3d823f1408aab8d346080694e0f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9890e61354cc407a80879467cc319dc6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_93964dfd8bc04d1db5e0373938e6ece3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f22b972c76614a029097f98637cc27dd.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9aa192f122d248c2abb6d20d4a4872f0.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b29a5c9b66a946708f6ccf0f5873ce75.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b633276b454545e1a2514afeb435b2fb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a1ea82460c0e45a5be5e856a5dfe628c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_93e41213acee44f5a1b083a629942a0c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0a59a0b58ce3425cab58c72427ad15ad.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f8846a4ccd5345d4829d50cca42a9dee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_437165bddf11448d92cf4f1e4ae2fee3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4d8e725292824e0d8fa7b936eaacfd44.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4f128d383d3e437a909e9f93f15af3ae.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_72ea8164f75a4001a13d703a78b9004e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_28b45fd1e4854cbe80aabd79447cf6cf.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f6d42b0060a342d7869c93db3b91b33f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fb4c0d7102b44fda8a75fb0702d2cd3a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_649f9a68ea2c44508d2e0c053690bbbb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_38fe51cd88734fbb98f116029c47f86d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dc831113338f418691224df1cafa0eee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a56b901c99da4e17b064d5e910b63a6d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1813c4ab4cd84294a165d605e701fc89.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9a20a7de5cd54c80bc7b14a611f9979d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_62620727d52240fab8e476627792c825.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fbe309bd2432413f9f6c1bf8e1b756dc.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9c059019efc24b5dae0aec416afb417c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1e2347e2605b467085886730fbdb7a72.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a1956210697342d9be793e69fdf514c1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6d75aa1994494612a735682239d15b2f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b1783c27705f444b95c6e96d1d193d05.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_50ebf5bffad34233b68d75555aa3b395.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_adb03d8d85bc43178fce0041eebfc560.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_288feba39b5a47f7a8d7596d537f656c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_715332a9940847618720d74b5e4d7ed4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_58f267407f234bf6b9d880d5dc898063.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_89fd653b9ed642b2b496491b5e8bb52c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1c3a67d2991644388dd402b64ad6f4fa.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_79ad365776d24283bf1955b8b2ca4ba5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_78bdde41e4b54df79e0756ffc8b184b5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d980733c974d4a92ab2cf85d05600ada.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_18d0e025b5c5490da1eda4c79a3c24e6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_81931cf7fb5347e2a2e75f63cbd3a17c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f5e21169a6554f96acff5e8911aa220c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d5e96074d61342d4b13d13901bbf6a2e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7e0c29fe4a214eaab48f55615f486f81.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_62cc1375305444b0971d0e1ea223e55d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3716db73b93b47abbedeafec8b4b4173.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_10fc2498dbb943babc0a49d11cdab16b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_16e2e327cc52414e84559ece061a3c04.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ab67643641a64e94b13ac5940fe8fe27.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5753950520e448acb574960fc47e6181.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_baa7f509a6e340f4bf4df69912ccfd30.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_40eb057f1cb34b7e9e3a8411e49d0c82.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ac0c382f4adb40da8b997536d92e098a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_40e7980422374b568566da9aaf54fe5e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7669a13e269249898e97293673d41417.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cf5c10b2e77147148bb3427261c92030.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_35d492fc050d4b1bae0e29cfba2de8fd.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2d025b11e66942c188178696b94ddc6d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ab95b6ec06a1411eb2a2ea0391148c94.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_37b66766209f414b839569f4943af4a4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4d569fb32f4d4320806f967e26ccfe99.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_bce74fce6262410aa0b523a29484069d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_55377a6ae67c4663948be76a52e5eac8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_517553bdee6f4d6384ecb0a95ead4b6c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fddf9e012f484ba496405d442e1a26fb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_67d2fa130ad347cd91fa751cc9d6ebb0.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_843e79471bd14aee9d92ee1728ede37f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7bc72d233f0d47efa37bd08ffe945b44.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3d9050f4c4df401eab701e70ae84aa0b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_74f766269c31436d9508ffe8cab2f87e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_00bd7530ca5648fb932124b69606809f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e5e459c10b974a05b1df0f75922d7287.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c4cfcbe125164169a940d039cabf4d98.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6e951a58e2854125811824ee3d129fab.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_721149fa40bb4e3fbb89c902c46e603c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_054608f27b784b8abe9fe1447f600987.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_464b90dab5104b3b92e1e87cf28adc82.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e4ef8244adcd4b7dbce3784090e62974.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_79b0483a9690447d856d7f44063b0727.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ae63cdfec6014c46a76f1571a3ed60ee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cbcde965e4ac4c89970df2358a8175ef.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_023e2d39811d4aad803d63d357f49a24.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ec896497316648cbbb9f6ef30f48cfbb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_73d8d5641a0440f3800631c77352152f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_bfb32e30819c4fc1ad5ba61bbec671f7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_83a18a0ecfbb4c06a28fdf8eb7827b93.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_733b7a0585ee4386811b803f7c3422eb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5ad89a8115eb4ef683706847f2da715b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_59d31775fcee43ddbf35aaa797e3c222.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1fc3a43eb7a24302a31cf37bde0e62de.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5de39eb8a4a541a88c6af7d7f6cf4407.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_94f7cdb27d104306afbf482e922e89b6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_742d4a3e094a41e69cb03df115a17fea.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_bce8567fba77443e9eaffc20ea62d576.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2fb668fbc9714f78adf472c45c165b79.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cdc4103a9ce244d4aa1f431253b5f68d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dcd190b6edb64be1a6203591f971f196.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5087ca0e101a4f38abe0caeb44445a86.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_60c83482c95c4e4484cafc537da43da6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_aaf9aa46de404bffbaebc863a52a0a6e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_eab59771cdae40709f947463759568b7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8d905aa78dd14ba3ac79a09c0c3179cb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6a32bb7a266e4b3a80f785efefa638ef.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4360f3c6c63a432383f9a90a5a79af29.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c0df0b633e9041098c4697a482246f43.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dc21d58a181a40e696705802af33b1e1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_64cf69a5e1924b98bd53713ab29f4083.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_46cb6ae1e3164fa1a388178f708e7a64.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dd9296872b0d4a019e77f9aa8e7b44f7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4bea26853b35493a95260d5754282225.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c5a64f922bf64c52a860ca4c1c4873f0.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3ae7c5ff195b47cea2cd31a6e88d67a1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_addd09a588154610b5c25859bcc028cf.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_212625402f6e446eb14966a3f1586609.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_125c854dcf90484eac22c9d4a700d39b.jpg" alt="img"></p>          </div>]]></content>
    
    
    <summary type="html">《孤独摇滚》总作监けろりらC102原画集</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【教程】如何让你的好友不停看到你在玩某游戏</title>
    <link href="https://zhongye1.github.io/posts/ba9ce6f6.html"/>
    <id>https://zhongye1.github.io/posts/ba9ce6f6.html</id>
    <published>2024-08-20T15:40:20.000Z</published>
    <updated>2024-08-20T16:06:31.359Z</updated>
    
    <content type="html"><![CDATA[<div class="tip warning faa-horizontal animated"><p>FBI warning</p></div><img src="https://imgsa.baidu.com/forum/w%3D580/sign=8d30ba9c09087bf47dec57e1c2d1575e/e49c3f2ac65c1038c3e64b15b9119313b27e899d.jpg" alt="img" style="zoom:50%;" align=right /><p>该方法会让你的好友每隔10秒弹出你的好友正在玩▆▆▆▆▆▆</p><p>不过可能会导致被屏蔽甚至删除好友的严重后果。</p><p>所以你需要的是一些steam好友（不怕死的那种</p><p>===================</p><p>接下来当然是基本操作，如何添加▆▆▆▆▆▆，网上都有教程<br>为了水还是发下，</p><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=d8cf65e03efae6cd0cb4ab693fb10f9e/41c464061d950a7b4decca1301d162d9f0d3c95c.jpg" alt="img"><br><img src="https://imgsa.baidu.com/forum/w%3D580/sign=af97493bda00baa1ba2c47b37712b9b1/8feac5fc1e178a8289abfb77fd03738dab77e89a.jpg" alt="img"></p><hr><p>这时候关键步骤来了，添加的你女朋友最好是个自己关掉的东西</p><p>（这样在调用时就不用关掉了）</p><p>这里我们自己写了一个……程序很简单，线程挂着就行了，java，c++，Delphi都行，</p><p>这里我们用c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">5000</span>);  <span class="comment">//五秒后自动关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=2b13490aa064034f0fcdc20e9fc17980/05365b3d269759ee5d85e71cb9fb43166f22df58.jpg" alt="img"></p><p>现在我们已经添加了一个非steam游戏，现在改个名，</p><p>但是注意直接启动，steam状态是不认的，</p><p>我们就要通过steam启动来完成，那么……<br><img src="https://imgsa.baidu.com/forum/w%3D580/sign=6e18634507f431adbcd243317b34ac0f/b1f2bb3533fa828b7ab11b34f61f4134950a5aa7.jpg" alt="img"></p><p>我们右键它，创建一个桌面快捷方式，桌面就会有个图标，右键，复制像这样的链接。</p><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=9e0a12f9a3d3fd1f3609a232004f25ce/7e3c88025aafa40f577a4f0aa064034f7af019f0.jpg" alt="img"></p><p>在桌面新建，文本文档，改名为a.bat（批处理文件）,写入</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`[@<span class="built_in">echo</span>](https://tieba.baidu.com/home/main?un=<span class="built_in">echo</span>&amp;fr=pb&amp;ie=utf-<span class="number">8</span>) off`</span><br><span class="line">`:<span class="built_in">start</span>`</span><br><span class="line">`<span class="built_in">start</span> steam://rungameid/<span class="number">11873789792539901952</span>` #👈把链接换成刚刚你获得的链接#</span><br><span class="line">`<span class="built_in">ping</span> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> -n <span class="number">10</span>&gt;<span class="built_in">nul</span>`</span><br><span class="line">`<span class="keyword">goto</span> <span class="built_in">start</span>`</span><br></pre></td></tr></table></figure><p>把链接换成刚刚你获得的链接，ping那行的10表示每10秒骚扰好友一次。修改，不要低于5，不然steam这个东西就不会下线了。就无法不停上线弹窗了。</p><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=e0c9d9c5444a20a4311e3ccfa0509847/46faa6af2edda3ccdf0639f70ae93901233f9257.jpg" alt="img"></p><p>双击运行就可以看到效果了，过一会估计你的好友估计就会线下真实你了（立竿见影</p><p>关掉cmd就可以了<br><img src="https://imgsa.baidu.com/forum/w%3D580/sign=62c3e1cb1adfa9ecfd2e561f52d1f754/bfdd9913b07eca80f528ba309a2397dda0448300.jpg" alt="img"></p><p>（每日一个昇镬小訬招）</p>]]></content>
    
    
    <summary type="html">论如何让你的好友不停看到你在玩奇怪游戏</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MikuTap</title>
    <link href="https://zhongye1.github.io/posts/mikumiku.html"/>
    <id>https://zhongye1.github.io/posts/mikumiku.html</id>
    <published>2024-08-04T07:21:26.000Z</published>
    <updated>2024-08-04T07:51:37.097Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en" version="4"><head>    <meta charset="UTF-8">    <title>MikuMikuTap~</title>    <style>        body, html {            margin: 0;            padding: 0;            height: 100%;        }        #Frame {            border: none; /* 移除边框 */            display: block; /* 块级元素 */            width: 100%; /* 宽度100% */            height: calc(100vh - 40px); /* 减去按钮的高度 */            position: absolute; /* 绝对定位 */            top: 40px; /* 使iframe位于按钮下方 */            left: 0;        }        .return-button {            display: block;            position: fixed; /* 固定定位 */            top: 0; /* 顶部位置 */            left: 50%; /* 水平居中 */            transform: translateX(-50%); /* 水平居中 */            background-color: #333;            color: white;            text-align: center;            padding: 10px 20px;            text-decoration: none;            z-index: 1000; /* 确保按钮在其他元素之上 */        }    </style></head><body inject_video_svd="true"><!-- 添加按钮 --><p><a href="https://zhongye1.github.io/" class="return-button">返回博客主页~</a></p><iframe id="Frame" src="https://air.moe/funs/MikuTap/" allowfullscreen=""></iframe></body></html>]]></content>
    
    
    <summary type="html">Miku声乐小游戏</summary>
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>申论生成器</title>
    <link href="https://zhongye1.github.io/posts/b61fa24.html"/>
    <id>https://zhongye1.github.io/posts/b61fa24.html</id>
    <published>2024-08-04T06:38:10.000Z</published>
    <updated>2024-08-20T16:06:26.094Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en" version="4"><head>    <meta charset="UTF-8">    <title>申论生成器</title>    <style>        body, html {            margin: 0;            padding: 0;            height: 100%;        }        #Frame {            border: none; /* 移除边框 */            display: block; /* 块级元素 */            width: 100%; /* 宽度100% */            height: calc(100vh - 40px); /* 减去按钮的高度 */            position: absolute; /* 绝对定位 */            top: 40px; /* 使iframe位于按钮下方 */            left: 0;        }        .return-button {            display: block;            position: fixed; /* 固定定位 */            top: 0; /* 顶部位置 */            left: 50%; /* 水平居中 */            transform: translateX(-50%); /* 水平居中 */            background-color: #333;            color: white;            text-align: center;            padding: 10px 20px;            text-decoration: none;            z-index: 1000; /* 确保按钮在其他元素之上 */        }    </style></head><body inject_video_svd="true"><!-- 添加按钮 --><p><a href="https://zhongye1.github.io/" class="return-button">返回博客主页~</a></p><iframe id="Frame" src="https://air.moe/funs/Slscq/" allowfullscreen=""></iframe></body></html>]]></content>
    
    
    <summary type="html">50-5000字申论自动生成器</summary>
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>访客地图</title>
    <link href="https://zhongye1.github.io/posts/a8a0d075.html"/>
    <id>https://zhongye1.github.io/posts/a8a0d075.html</id>
    <published>2024-08-03T16:12:49.000Z</published>
    <updated>2024-08-07T16:49:57.774Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;!DOCTYPE html&gt;</p><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="initial-scale=1.0, user-scalable=no" /><title>柊野的博客-访客分布</title><style type="text/css">    body, html {        width: 100%;        height: 100%;        margin: 0;        font-family: "微软雅黑";    }    #allmap {        width: 100%;        height: 100%;        position: relative;        z-index: 1;    }    p {        margin-left: 5px;        font-size: 14px;    }    .openInfo {        margin: 4px 0;    }    .my_label {        width: 300px;        overflow: hidden;        text-overflow: ellipsis;        white-space: nowrap;        display: inline-block;    }    .openInfo_div {        width: 100%;        height: 80%;        overflow-y: auto;    }    .BMap_bubble_content {        height: 100%!important;    }    .openInfo>* {        vertical-align: middle;    }    /* 返回博客按钮=========================================================== */    .button {        border: none;        color: white;        text-align: center;        text-decoration: none;        display: inline-block;        font-size: 20px;        margin: 4px 2px;        cursor: pointer;        background-image: url('https://pic4.zhimg.com/v2-68ff3d189ef7ec060222261a98892e67_b.webp'); /* 图片路径 */        background-size: cover; /* 使图片填充整个按钮区域 */        background-repeat: no-repeat;        background-position: center center;        width: 170px; /* 设置按钮的宽度为图片的宽度 */        height: 90px; /* 设置按钮的高度为图片的高度 */    }    .button2 {        background-color: #008CBA; /* 蓝色备用背景颜色 */    }</style><!-- 将所有的 script 标签放在这里 --><script type="text/javascript" src="https://api.map.baidu.com/api?v=2.0&ak=1XjLLEhZhQNUzd93EjU5nOGQ&s=1"></script><script type="text/javascript" src="https://api.map.baidu.com/library/Heatmap/2.0/src/Heatmap_min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.9.0/jquery.min.js"></script><!-- 将不安全的http升级为https --><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"></head><body><div style="position:absolute;top:0;z-index:99999;background-color:rgba(0,0,0,0.2);width:100%;color:#FFFFFF;">    <center>        <h2>柊野的博客-访客分布-Апрель （访客IP地图）</h2>    </center></div><div style="position:absolute;bottom:20px;left:0;z-index:99999;background-color:rgba(0,0,0,0.2);">    <h3 style="color:#FFFFFF;">好好好</h3>    <p></p>    <a href="https://zhongye1.github.io/" class="button button2" target="_blank">返回博客主页</a></div><div style="position:absolute;bottom:0;right:0;z-index:99999;background-color:rgba(0,0,0,0.2);">    <h4 style="color:#FFFFFF;">        <br/>        进博客就会点亮你的位置，想不到吧hhh        <br/>        访问博客都会被记录在此（        <br/>        顺带位置依据是IP，IP不能精确定位但可以确定城市        <br/>        所以站长不太可能找上门（除非你也在广州大学        <br/>        <br/>来看看你和站长有多远        <br/><font color="#80bfff">站长QQ 2760913192</font>        <br/>                        ————柊野        <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1261190516'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1261190516%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>    </h4></div><div id="allmap"></div><script type="text/javascript">    // 百度地图API功能    var map = new BMap.Map("allmap");    map.centerAndZoom("中国", 6);    map.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放    map.setMapStyle({ style: 'midnight' }); // 修正语法错误    var point = new BMap.Point(116.418261, 39.921984);    map.centerAndZoom(point, 6);    var data_info = [        [114.4942, 37.0631, "China-Hebei-Xingtai", "https://bf3.axibug.com/hunter_map/icon/c1.png"],        [104.93457341, 33.39447997, "256", "https://bf3.axibug.com/hunter_map/icon/c2.png"],        [108.3146, 22.8137, "China-Guangxi-","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [113.380249, 23.04721, "300","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [113.380249, 23.09721, "77","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [120.59246739, 30.00236458, "293","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [106.7167, 26.5833, "China-Guizhou-","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [114.248084,30.601824, "HB","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [114.248084,30.701824, "HB","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [114.248084,30.621824, "298","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [113.507593,30.366792, "298","https://bf3.axibug.com/hunter_map/icon/c4.png"],        [120.14887182, 33.37986188, "223","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [113.1117, 28.1783, "China-Hunan-Changsha","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [114.35164212, 34.80185418, "210","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [114.4, 23.0833, "China-Guangdong-Huizhou","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [106.5531, 29.5569, "China-Chongqing-","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [115.89352755, 28.689578, "163","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.25, 23.1167, "China-Guangdong-","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [108.92427443, 23.55225469, "17","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [117.67620468, 24.51706478, "255","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [114.1861241, 22.29358599, "2912","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [112.247378,32.457298, "58","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [119.3061, 26.0614, "China-Fujian-Fuzhou","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [115.37292429, 22.7787305, "339","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [120.36132599, 23.77722277, "9000","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [106.5531, 29.5569, "China-Chongqing-Chongqing","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [120.3694, 36.066, "China-Shandong-Qingdao","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [106.53063501, 29.54460611, "132","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.854145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.634145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.587907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.6827907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.277627,23.132179, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.237627,23.133179, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.277627,23.1331179, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045547, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045547, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382433,23.045547, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382323,23.045547, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045247, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045447, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045557, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],            ];      var opts = {        width: 390, // 信息窗口宽度        height: 200, // 信息窗口高度        title: "", // 信息窗口标题    };    for (var i = 0; i < data_info.length; i++) {        var marker = new BMap.Marker(new BMap.Point(data_info[i][0], data_info[i][1])); // 创建标注        var myIcon = new BMap.Icon(data_info[i][3], new BMap.Size(25, 25), {});         marker.setIcon(myIcon);        map.addOverlay(marker); // 将标注添加到地图中        addClickHandler(marker, data_info[i][2]);    }    function addClickHandler(marker, id) {        marker.addEventListener("click", function (e) {            openInfo(e, id);        });    }    var nowpoint;    function openInfo(e, id) {        var p = e.target;        var point = new BMap.Point(p.getPosition().lng, p.getPosition().lat);        nowpoint = point;        ajax(id, point);    }    function ajax(id, point) {        // 这里应该添加 AJAX 请求的代码        // 示例代码：        // $.ajax({        //     url: "your-url-here",        //     data: { id: id, point: point },        //     success: function (data) {        //         // 处理成功后的逻辑        //     },        //     error: function () {        //         // 处理错误后的逻辑        //     }        // });    }</script></body></html>]]></content>
    
    
    <summary type="html">博客-访客分布图</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何检索Bangumi作品ID</title>
    <link href="https://zhongye1.github.io/posts/ac0edfe5.html"/>
    <id>https://zhongye1.github.io/posts/ac0edfe5.html</id>
    <published>2024-07-31T17:40:49.000Z</published>
    <updated>2024-08-29T18:13:20.758Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="Bangumi站点" href="https://bgm.tv/"><div class="left"><img src="https://picx.zhimg.com/80/v2-bc308dd4467bdc76edbb6c65fabd38d1_720w.webp"/></div><div class="right"><p class="text">Bangumi站点</p><p class="url">https://bgm.tv/</p></div></a></div><p><strong>进入相关动画页面的链接最后数字就是作品ID</strong><br>如</p><p><a href="https://bgm.tv/subject/328609">https://bgm.tv/subject/328609</a><br>作品ID就是328609</p><p>如图</p><p><img src="https://pic2.zhimg.com/80/v2-a68ca080c5c84942894892e634329df1_720w.webp" alt="img"></p><div class="tag link"><a class="link-card" title="返回圣地巡礼地图" href="https://zhongye1.github.io/posts/e11696b0.html"><div class="left"><img src="https://pic1.zhimg.com/80/v2-bc721faaba1ef3f9e951f621148f700e_720w.webp"/></div><div class="right"><p class="text">返回圣地巡礼地图</p><p class="url">https://zhongye1.github.io/posts/e11696b0.html</p></div></a></div>]]></content>
    
    
    <summary type="html">如何检索Bangumi作品ID</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>typora图床设置</title>
    <link href="https://zhongye1.github.io/posts/32d01401.html"/>
    <id>https://zhongye1.github.io/posts/32d01401.html</id>
    <published>2024-07-31T04:56:23.000Z</published>
    <updated>2024-07-31T05:02:12.915Z</updated>
    
    <content type="html"><![CDATA[<p>兰空图床安装可以去看另一篇文章 <a href="https://blog.imtop1.moe/archives/299/">搭建一个属于自己的图床</a></p><h2 id="一、安装和配置picgo">一、安装和配置picgo</h2><ol><li><p>首先到picgo的官方仓库下载安装包 <a href="https://github.com/Molunerfinn/PicGo">Molunerfinn/PicGo: A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder (github.com)</a> 安装过程一路next就ok，安装完成后的界面：</p><p><a href="https://image.imtop1.moe/oPOFUp.webp"><img src="https://image.imtop1.moe/oPOFUp.webp" alt="picgo0"></a></p></li><li><p>安装兰空图床插件</p><p>这里可以直接到picgo的插件设置里面搜索兰空安装插件，或者是直接到官方github下载并且手动安装，链接：<a href="https://github.com/hellodk34/picgo-plugin-lankong">hellodk34/picgo-plugin-lankong: A PicGo uploader for 兰空图床 lsky-pro，支持 V1 和 V2。 (github.com)</a>教程在链接里面有。</p><p><a href="https://image.imtop1.moe/euJ6uz.webp"><img src="https://image.imtop1.moe/euJ6uz.webp" alt="pic1"></a></p></li><li><p>获取兰空图床token</p><p>这里使用postman请求一个token，信息按照图片里的填就ok，记得把域名换成你自己图床的域名。</p><p><a href="https://image.imtop1.moe/mV6yuf.webp"><img src="https://image.imtop1.moe/mV6yuf.webp" alt="pic2"></a></p><ol><li>设置picgo</li></ol><p>打开图床设置，选择lankong，照着写即可。</p><p><a href="https://image.imtop1.moe/pZXL24.webp"><img src="https://image.imtop1.moe/pZXL24.webp" alt="pic3"></a></p></li><li><p>检测效果</p><p>图床选lankong，随便上传一张图片，看看能不能成功。</p><p><a href="https://image.imtop1.moe/X08dZe.webp"><img src="https://image.imtop1.moe/X08dZe.webp" alt="pic4"></a></p><p><a href="https://image.imtop1.moe/HDM3Ef.webp"><img src="https://image.imtop1.moe/HDM3Ef.webp" alt="pic5"></a></p></li></ol><h2 id="二、对接typora">二、对接typora</h2><p>打开typora，前往偏好设置，进行如下设置：</p><p><a href="https://image.imtop1.moe/ZZOkbW.webp"><img src="https://image.imtop1.moe/ZZOkbW.webp" alt="pic6"></a></p><p>并点击验证图片上传选项：</p><p><a href="https://image.imtop1.moe/L8Z6yw.webp"><img src="https://image.imtop1.moe/L8Z6yw.webp" alt="pic7"></a></p><p>能出现如图界面说明成功了。</p><p>现在你往typora拖拽图片能自动上传到兰空图床</p>]]></content>
    
    
    <summary type="html">typora+picgo+兰空图床打造markdown写作环境</summary>
    
    
    
    <category term="博客美化" scheme="https://zhongye1.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>2024年7月31日</title>
    <link href="https://zhongye1.github.io/posts/e6902323.html"/>
    <id>https://zhongye1.github.io/posts/e6902323.html</id>
    <published>2024-07-30T17:21:52.000Z</published>
    <updated>2024-07-30T17:44:10.011Z</updated>
    
    <content type="html"><![CDATA[<ul><li></li></ul><p>中午困死，一直睡到下午七点</p><p>梦到了些很诡异的东西</p><ul><li></li></ul><p>研究NAS建站</p><p>研究图床</p><p>研究API</p><p>然后都没搞定（倒</p><img src="https://pic4.zhimg.com/80/v2-24ff52b4977d121d3bc9ab1dc9678bab_720w.webp" alt="img" style="zoom:50%;" /><p>就是无厘头的405了</p><p>图床还得用知乎</p><p>搞不好哪天开了防盗链这个博客站又得寄掉</p><p>要弄的还是太多了</p><p>其实现在要网上保存个什么的死难</p><p>随便哪边供应的跑路了就寄了</p><p>不过暑假还有时间修</p><p>之后难说了，大二忙成狗</p><p>难搞</p><p><img src="https://pic1.zhimg.com/80/v2-666eaa2a5c3b4e18b03bef3e0fcb077c_720w.webp" alt="img"></p><ul><li></li></ul><p>另外网易云一个歌单全部收费了</p><p>收费的话比起灰掉还是好点</p><p>不过没啥差别</p><p>每次重新翻收藏时总是有一堆都变成这样</p><img src="https://pic2.zhimg.com/80/v2-eee0a77edb1272f1fb9e58ab732a3f65_720w.webp" alt="img" style="zoom:33%;" />]]></content>
    
    
    <summary type="html">405 Not Allowed</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>周边其二</title>
    <link href="https://zhongye1.github.io/posts/fcf81dde.html"/>
    <id>https://zhongye1.github.io/posts/fcf81dde.html</id>
    <published>2024-07-29T18:03:23.000Z</published>
    <updated>2024-07-30T12:31:48.156Z</updated>
    
    <content type="html"><![CDATA[<ul><li></li></ul><p><img src="https://pic4.zhimg.com/80/v2-d133dfa8b586d5ddc43d8715a24a172b_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-097dafe2afb1cdbf10d944f78e517d5b_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5e6a6a4c3a2297277a6b685b29f91a57_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-53d4b8af1de60e9e907ec7c7190ca52a_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-f5dd3dd51ee10f7a6916e95956990e0b_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-23ddc9d4fa9f7c20c8ab67279924735f_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-84e794e35970290f0ee5234fea9e6301_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-e0cc837ae526a648e14d913910782694_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-22a5064ff5e04f3ce92de9c2886baadd_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-e7e2db37d51b148062918eb560f93322_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-ead7692442601112efcc88a83502a3aa_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-c8e909921c103eea2f78e17c85f46300_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-9aa8c440226d90aba306e139d17a267f_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-31a2e4274eba328a24754dad871aded9_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-298d8f7019e59d8467912bdcea869b3c_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5643fdf1e32bb3aa1792fe9b2d14b553_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-a6949a79d9e87e6fa83394462e526479_720w.webp" alt="img"></p><ul><li></li></ul><p>其实刚到这里时还是挺高兴的</p><p>百来块不到的预算草草来香港除了拍街景另外是想来看一下周边</p><p>不过周边的产品附加值拉满了</p><p>个人不是很能接受拿金钱实力来展示自己的厨力</p><p>穷游香港的话预算60多</p><p>在香港也没有买任何东西</p><p>除此之外另外也没啥其他的了</p><p>给7月画个尾声罢</p><p>其实还想说什么的话</p><p>也没头绪</p><p>就是想的太多</p><p>睡了</p><ul><li></li></ul>]]></content>
    
    
    <summary type="html">百来块不到的预算草草来香港除了拍街景也主要是想来看一下周边</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>年前</title>
    <link href="https://zhongye1.github.io/posts/aeed56ee.html"/>
    <id>https://zhongye1.github.io/posts/aeed56ee.html</id>
    <published>2024-07-29T15:59:07.000Z</published>
    <updated>2024-08-05T15:47:29.019Z</updated>
    
    <content type="html"><![CDATA[<p>-放首歌</p>    <div id="aplayer-KrlKULFO" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1960403945" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><img src="https://pic3.zhimg.com/80/v2-aee1088402a3dba60d86b71c4c5ce4f2_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-f8f67bac6b457af94c4bad5f6b928f94_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-80392f2b012bd26a267d48530c2d523a_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-b840b58b9de1f17ffb0eb71cc9ed5dc3_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-66de82b1b0d5482d439272051e9b0ffb_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-92b32c509920899c39173f1593ab8100_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-bf4481accae1dc117377e6e97d33fa22_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-c18d007dfe7fd637e9d21b61e7bf8642_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-40b9431c44e0f088356e1893f6da9685_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-ae586f3b62e6c45e28f92bac1f294cf8_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-9c8cbf1a07beb44c9415556a387ee31e_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-6c7c62b2e4057ea9014b85a514c39a1a_720w.webp" alt="img"><img src="https://pic4.zhimg.com/80/v2-bb3408d229550808179e9ec48c72b36f_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-9c896e2539244f481b7f06195bfc5c5a_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-4f504440b8b8130ea093454c1ba25568_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-5b1ee59e3138ccc7b6c4cf7731f8147d_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-f7ff7171d0e2e8ca388b84ce79714382_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-1f36bcd074963f0e9c5df29e9ed4fa07_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-c7ad9246231d288efecb967beb16e319_720w.webp" alt="img"></p><p>当时二月初，刚下完冻雨后又下了几天雪</p><p>很少会下这么大的雪，把一切都冻住了几天</p><p>当时说将来可能看不到这种景致了，要多看看</p><p>现在又是夏天了</p>]]></content>
    
    
    <summary type="html">一些年前的照片</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数学分析笔记其二</title>
    <link href="https://zhongye1.github.io/posts/dc9c528b.html"/>
    <id>https://zhongye1.github.io/posts/dc9c528b.html</id>
    <published>2024-07-26T15:54:02.000Z</published>
    <updated>2024-07-26T17:50:32.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数分思维导图（分块对比版）">数分思维导图（分块对比版）</h2><p><img src="https://pic3.zhimg.com/80/v2-51d2dd8a8fce49d68e4155102d2f4b6a_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-328947f5004d7fc73dd60d07c1ae70f3_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-a1b8946301d2c666e14287048462eede_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-3ddf0622ca0c7c8991b3d4e4350fc502_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-ab6d616deccd4c73ce4a929aeb1b6794_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5003f333cf7daedefa7187d8e8d86fcb_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-a6502548cbf3a6baff900ba800287483_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-310a39b7ca256d6d45ca887597de4955_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-d163bd005712d70995ab263d28b541bc_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-f3a12ba58309f0ef249e59f95cc20548_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-55ab37de967ee6f658adc8eff9956e55_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-691b17d8319e18e5b958b565961c3b56_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-d202eb555293a6d8aecfd8af0f4f5731_720w.webp" alt="img"></p><hr><h2 id="一些公式和解题方法">一些公式和解题方法</h2><p><img src="https://pic2.zhimg.com/80/v2-262629548cf754b41abb7056f0f63201_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5115e32777d8549f235ab0ac7f5c805b_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-d1f11105011824e4eac3e37208dcd204_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-9a9e2c71a423e95ca6e861d6a7aa7efc_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-ccbf8f1c47c4b16aa0e01614e1f2ed0e_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-4c35492e316f1fc489493f39186cc6be_720w.webp" alt="img"></p><p>编辑于 2024-07-27</p>]]></content>
    
    
    <summary type="html">数分思维导图及公式合集</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>高代知识点全汇总</title>
    <link href="https://zhongye1.github.io/posts/47d446d0.html"/>
    <id>https://zhongye1.github.io/posts/47d446d0.html</id>
    <published>2024-07-25T19:27:55.000Z</published>
    <updated>2024-07-31T04:32:21.995Z</updated>
    
    <content type="html"><![CDATA[<details class="folding-tag" cyan open><summary> CSDN上的一些知识点合集（点击折叠） </summary>              <div class='content'>              <h4 id="第一章——矩阵及初等变换">第一章——矩阵及初等变换</h4><p><strong>§1.1. 矩阵及其运算</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99618446">线性代数学习笔记——第一讲——线性代数课程绪论</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99618603">线性代数学习笔记——第二讲——矩阵的定义及示例</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99618805">线性代数学习笔记——第三讲——矩阵加法及数乘</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99618841">线性代数学习笔记——第四讲——矩阵乘法的定义</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99657438">线性代数学习笔记——第五讲——矩阵乘法的性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99660769">线性代数学习笔记——第六讲——矩阵的转置</a><br><strong>§1.2. 高斯消元法与矩阵的初等变换</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99721392">线性代数学习笔记——第八讲——矩阵的初等变换</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99722636">线性代数学习笔记——第九讲——初等矩阵</a></p><p><strong>§1.3. 逆矩阵</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99726807">线性代数学习笔记——第十讲——逆矩阵的定义</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99729891">线性代数学习笔记——第十一讲——逆矩阵的计算（利用初等变换求逆矩阵）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99730636">线性代数学习笔记——第十二讲——求解矩阵方程</a><br><strong>§1.4. 分块矩阵</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99663452">线性代数学习笔记——第七讲——分块矩阵</a></p><h4 id="第二章——行列式">第二章——行列式</h4><p><strong>§2.1. n阶行列式的定义</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99747212">线性代数学习笔记——第十三讲——行列式的定义</a></p><p><strong>§2.2. n阶行列式的性质</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99762801">线性代数学习笔记——第十四讲——行列式的性质</a><br><strong>§2.3. Laplace定理</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99766891">线性代数学习笔记——第十五讲——行列式按行（列）展开</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99770920">线性代数学习笔记——第十六讲——行列式的计算</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99773351">线性代数学习笔记——第十七讲——伴随矩阵与逆矩阵</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99887040">线性代数学习笔记——第十八讲——抽象矩阵的可逆性</a><br><strong>§2.4. Cramer法则</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99889327">线性代数学习笔记——第十九讲——克拉默法则</a><br><strong>§2.5. 矩阵的秩</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99890960">线性代数学习笔记——第二十讲——矩阵秩的定义</a>、</p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99893849">线性代数学习笔记——第二十一讲——矩阵秩的等式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99895726">线性代数学习笔记——第二十二讲——矩阵秩的不等式</a></p><h4 id="第三章——几何空间">第三章——几何空间</h4><p><strong>§3.1. 空间直角坐标系与向量</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99999238">线性代数学习笔记——第二十三讲——空间直角坐标系</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100005855">线性代数学习笔记——第二十四讲——向量及其线性运算</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100006195">线性代数学习笔记——第二十五讲——向量在轴上的投影</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100026005"> 线性代数学习笔记——第二十六讲——向量线性运算的几何意义</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100026531">线性代数学习笔记——第二十七讲——向量的方向余弦</a><br><strong>§3.2. 向量的乘法</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100027126">线性代数学习笔记——第二十八讲——向量内积的概念与性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100085857">线性代数学习笔记——第二十九讲——向量内积的坐标形式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100086031">线性代数学习笔记——第三十讲——向量外积的概念与性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100086376">线性代数学习笔记——第三十一讲——向量外积的坐标形式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100087151">线性代数学习笔记——第三十二讲——向量混合积的概念与性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100087236">线性代数学习笔记——第三十三讲——向量混合积的几何意义</a></p><h4 id="第四章——n维向量空间">第四章——n维向量空间</h4><p><strong>§4.1. n维向量空间的概念</strong></p><p><a href="https://mp.csdn.net/postedit/100167321">线性代数学习笔记——第四十讲——n维向量空间的概念</a></p><p><a href="https://mp.csdn.net/postedit/100167541">线性代数学习笔记——第四十一讲——n维向量空间的子空间</a><br><strong>§4.2. 向量组的线性相关性</strong></p><p><a href="https://mp.csdn.net/postedit/100167651">线性代数学习笔记——第四十二讲——向量组的线性组合</a></p><p><a href="https://mp.csdn.net/postedit/100167901">线性代数学习笔记——第四十三讲——向量组之间的线性表出</a></p><p><a href="https://mp.csdn.net/postedit/100525200">线性代数学习笔记——第四十四讲——线性相关性的概念</a></p><p><a href="https://mp.csdn.net/postedit/100528562">线性代数学习笔记——第四十五讲——线性相关性的判定</a></p><p><a href="https://mp.csdn.net/postedit/100529249">线性代数学习笔记——第四十六讲——线性相关基本定理</a><br><strong>§4.3. 向量组的秩与最大无关组</strong></p><p><a href="https://mp.csdn.net/postedit/100545185">线性代数学习笔记——第四十七讲——向量组的秩与最大无关组的概念</a></p><p><a href="https://mp.csdn.net/postedit/100545450">线性代数学习笔记——第四十八讲——矩阵的列秩和行秩</a></p><p><a href="https://mp.csdn.net/postedit/100545669">线性代数学习笔记——第四十九讲——向量组之间的线性表出和秩</a></p><p><a href="https://mp.csdn.net/postedit/100545879">线性代数学习笔记——第五十讲——最大无关组的性质和等价叙述</a><br><strong>§4.4. 线性方程组解的结构</strong></p><p><a href="https://mp.csdn.net/postedit/100563945">线性代数学习笔记——第五十一讲——n维向量空间的基、维数与坐标</a></p><p><a href="https://mp.csdn.net/postedit/100564018">线性代数学习笔记——第五十二讲——齐次方程组解的性质和基础解系</a></p><p><a href="https://mp.csdn.net/postedit/100564726">线性代数学习笔记——第五十三讲——齐次方程组求解实例</a></p><p><a href="https://mp.csdn.net/postedit/100568940">线性代数学习笔记——第五十四讲——非齐次方程组解的性质</a></p><p><a href="https://mp.csdn.net/postedit/100569281">线性代数学习笔记——第五十五讲——非齐次方程组求解实例</a></p><h4 id="第五章——特征值与特征向量">第五章——特征值与特征向量</h4><p><strong>5.1 特征值与特征向量的概念与计算</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100584392">线性代数学习笔记——第五十六讲——特征值及特征向量的定义</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100584678">线性代数学习笔记——第五十七讲——特征子空间</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100584921">线性代数学习笔记——第五十八讲——特征值与特征向量的判定</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100585358">线性代数学习笔记——第五十九讲——特征值与特征向量的计算</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100585433"> 线性代数学习笔记——第六十讲——特征多项式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100654266">线性代数学习笔记——第六十一讲——矩阵函数、逆矩阵、伴随矩阵的特征值与特征向量</a><br><strong>§5.2 矩阵的相似对角化</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100654621">线性代数学习笔记——第六十二讲——矩阵的相似对角化引例</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100654919">线性代数学习笔记——第六十三讲——相似的定义与性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100661294">线性代数学习笔记——第六十四讲——相似对角化的判定（1）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100662028">线性代数学习笔记——第六十五讲——相似对角化的判定（2）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100665386">线性代数学习笔记——第六十六讲——矩阵方幂的计算</a></p><p><strong>§5.3 n维向量空间的正交性</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100669700">线性代数学习笔记——第六十七讲——向量的内积</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100670303">线性代数学习笔记——第六十八讲——柯西—施瓦兹（Cauchy-Schwarz）不等式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100676734">线性代数学习笔记——第六十九讲——正交向量组与标准正交基</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100677372">线性代数学习笔记——第七十讲——格拉姆—施密特（Gram-Schmidt）正交化方法</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100677838">线性代数学习笔记——第七十一讲——正交矩阵</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100708919">线性代数学习笔记——第七十二讲——共轭矩阵</a></p><p><strong>§5.4实对称矩阵的相似对角化</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100715687">线性代数学习笔记——第七十三讲——实对称矩阵的特征值与特征向量</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100715880">线性代数学习笔记——第七十四讲——实对称矩阵的相似对角化</a></p><h4 id="第六章——二次型与二次曲面">第六章——二次型与二次曲面</h4><p><strong>§6.1.实二次型</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100750410">线性代数学习笔记——第七十五讲——二次型及其矩阵表示</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100751105">线性代数学习笔记——第七十六讲——矩阵的合同</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100751420">线性代数学习笔记——第七十七讲——用配方法化二次型为标准型</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100751854">线性代数学习笔记——第七十八讲——用正交变换化二次型为标准型</a><br><strong>§6.2. 正定二次型</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100752201">线性代数学习笔记——第七十九讲——正定二次型的概念</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100752518">线性代数学习笔记——第八十讲——正定二次型的性质（1）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100780293">线性代数学习笔记——第八十一讲——正定二次型的性质（2）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100780570">线性代数学习笔记——第八十二讲——二次型的其它类型</a></p>              </div>            </details><p>一些总结，可能较零碎。</p><hr><p>本节是线代某些知识点总结，可能较零碎。</p><p>对于简单的知识点，例如“两行对应成比例，<a href="https://so.csdn.net/so/search?q=%E8%A1%8C%E5%88%97%E5%BC%8F&amp;spm=1001.2101.3001.7020">行列式</a>为0&quot;就不讲了。暂时不举例题，有时间会继续补充！</p><h4 id="一-初等行-列变换">一.初等行/列变换</h4><h5 id="1-计算行列式时，行列变换都可">1.计算行列式时，行列变换都可</h5><p>因为<img src="https://latex.csdn.net/eq?D%3DD%5E%7BT%7D" alt="D=D^{T}">，所以不论动行/列都是等价的。</p><blockquote><p>变换规则：</p><p>1.“倍乘”：行列式的某行(列)乘某个元素k。相应的，若行列式中某行(列)元素有公因子k(k≠0)，则k可提到行列式外面，即:</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be10e4590.png" alt="img"></p><p>2.“互换”：行列式中两行(列)互换，行列式变号。</p><p>3.“倍加”：某行(列)的k倍加到另一行(列)，行列式不变。</p></blockquote><h5 id="2-求矩阵的秩时，行列变换都可">2.求<a href="https://so.csdn.net/so/search?q=%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9&amp;spm=1001.2101.3001.7020">矩阵的秩</a>时，行列变换都可</h5><p>因为初等变换不改变某个矩阵非零子式的最高阶数，秩指的就是非零子式的最高阶数。</p><blockquote><p>初等变换的规则：</p><p>1.“倍乘”：一个非零常数乘矩阵矩阵的某一行(列)。</p><p>2.“互换”：互换矩阵中某两行(列)的位置。</p><p>3.“倍加”：将矩阵的某一行(列)的k倍加到令一行(列)。</p><p><strong>注意：</strong></p><p>某矩阵乘元素k，是矩阵中的每个元素都成k，要与行列式区分。</p><p>也就是<img src="https://latex.csdn.net/eq?%7CkA%7C%3Dk%5En%7CA%7C" alt="|kA|=k^n|A|">。</p></blockquote><h5 id="3-解线性方程组时，仅能使用初等行变换">3.解<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84&amp;spm=1001.2101.3001.7020">线性方程组</a>时，仅能使用初等行变换</h5><p>因为矩阵的每一种初等行变换都对应着线性方程组的同解变换，而作列变换会改变原来的方程。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1291006.png" alt="img"></p><h5 id="4-判定解的情况，单纯求r-A-r-A-b-的过程行列变换都可">**4.**判定解的情况，单纯求r(A),r(A,b)的过程行列变换都可</h5><p><strong>注</strong>：将r(A,b)化行阶梯求秩时，往往我们需要<strong>同时得到r(A)</strong>，如果想用列变换的话，<strong>只能对A单独列变换</strong>，千万不要将b列和A的列混合运算，这样r(A)就不准了。(但r(A,b)是准的)。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be11a1aaf.png" alt="img"><br>但是，如果涉及到求通解或唯一解，那么就只能做行变换化行阶梯了，所以建议一开始就只做行变换。</p><blockquote><p><strong>总结</strong>：求解的过程，就只进行<strong>初等行变换化行阶梯</strong>求秩，并且顺势化为行最简型求解**。**</p></blockquote><h5 id="5-求向量组极大无关组、线性表出关系，则仅行变换"><strong>5.求向量组极大无关组、线性表出关系，则仅行变换</strong></h5><p>因为初等行变换不改变列向量组的线性表出关系。例如下图，<img src="https://latex.csdn.net/eq?%5Cbeta" alt="\beta">矩阵中，![\beta_{3}=\beta_{2} +\beta_{1}](<a href="https://latex.csdn.net/eq?%5Cbeta_%7B3%7D%3D%5Cbeta_%7B2%7D">https://latex.csdn.net/eq?\beta_{3}%3D\beta_{2}</a> +\beta_{1})，<img src="https://latex.csdn.net/eq?%5Calpha" alt="\alpha">矩阵同样有这样的关系。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be11d0e76.png" alt="img"></p><h5 id="6-求向量组的秩时，行列变换都可">6.求向量组的秩时，行列变换都可</h5><p>求向量组的秩，其实最后会转化为求矩阵的秩，原理就是**“矩阵的秩=行向量组的秩=列向量组的秩”，**所以求向量组的秩也是行列变换都可。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be12a3bfe.png" alt="img"></p><p>但是一般求向量组的秩后面会继续求解极大无关组/线性表出关系，这时只能做行变换，所以还是建议从开头就只使用行变换。</p><h5 id="7-求特征值时，行列变换都可">7.求特征值时，行列变换都可</h5><p>因为特征多项式本质上是行列式，求行列式时，行列都可以换。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be12cb40c.png" alt="img"></p><h5 id="8-求特征向量时，仅做行变换">8.求特征向量时，仅做行变换</h5><p>因为求特征向量时，本质是在解线性方程组，只能进行初等行变换。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be12abf5d.png" alt="img"></p><h5 id="9-求逆矩阵时，对-A-E-仅做初等行变换">9.求逆矩阵时，对(A,E)仅做初等行变换</h5><p>因为以A−1𝐴−1左乘A得到E，以A−1𝐴−1左乘E得到A−1𝐴−1，以A−1𝐴−1左乘的过程就是做初等行变换的过程。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be136ee86.png" alt="img"></p><p>所以怎么体现A和E做了完全一样的A−1𝐴−1所带来的初等行变换，就是将A，E横着拼在一起，此时做的初等行变换就是同步的了。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be13a4143.png" alt="img"></p><h5 id=""></h5><h5 id="总结："><strong>总结：</strong></h5><blockquote><p>除了① 求行列式的值（求特征值本质上就是求行列式的值）和 ② 单纯求秩，行列变换都可，其余情况通通只做行变换。</p></blockquote><h4 id="二-要牢记">二.要牢记</h4><p>先写那么多，后面有再补充：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be14cf11b.png" alt="img"></p><p>一些推导：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be155866b.png" alt="img"></p><p>对于AB ≠ BA的补充：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be15c5aa1.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be14e0fc5.jpeg" alt="img"></p><p><strong>1.矩阵的逆</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1690f49.png" alt="img"></p><p>推导如下：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be168227d.png" alt="img"></p><p><strong>初等矩阵的逆：</strong><br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be16ad19b.png" alt="img"></p><p><strong>2.矩阵的伴随</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be16d31f9.png" alt="img"></p><h4 id="三-某某子式">三.某某子式</h4><h5 id="1-余子式">1.余子式</h5><p>在n阶行列式中，去掉元素a所在的第i行、第j列元素，由剩下的元素按原来的位置与顺序组成的n-1阶行列式称为元素a的余子式，记作Mij𝑀𝑖𝑗。</p><h5 id="2-代数余子式">2.代数余子式</h5><p>余子式Mij𝑀𝑖𝑗乘(−1)i+j(−1)𝑖+𝑗后称为a的代数余子式，记作AAij𝐴𝑖𝑗</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be177aa2f.png" alt="img"></p><h5 id="3-k阶子式">3.k阶子式</h5><p>给定一个矩阵，任取k行，任取k 列，共k2𝑘2个数构成的行列式，出现在矩阵的秩中，定义如下：</p><p>设A是mxn矩阵，则若存在k阶子式不为零，而任意k+1阶子式(如果有的话)全为零，则r(A)=k，且若A为nxn矩阵，则：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be17bac82.png" alt="img"></p><h5 id="-2"></h5><h5 id="4-k阶主子式">4.k阶主子式</h5><p>指在行列式中选k行k列，但要求行和列的下标相同。如：行为r1、r2、r3，列必须为c1、c2、c3；行为r2、r3、r5，列必须为c2、c3、c5。因此，k阶主子式不唯一。</p><p>这在矩阵相似会用到，下面会讲。</p><h5 id="5-顺序主子式">5.顺序主子式</h5><p>顺序主子式是在主子式上再加限定，顺序主子式是由 1~k 行和 1~k 列所确定的子式。</p><blockquote><p><strong>例如：</strong></p><p>1阶时：取第1行，第1列</p><p>2阶时：取第1、2行，第1、2列</p><p>3阶时：取第1、2、3行，第1、2、3列</p><p>4阶时：取第1、2、3、4行，第1、2、3、4列</p><p>实际上，主子式的主对角线元素是原 n 阶行列式的主对角线元素的一部分，<strong>且顺序相同。</strong></p><p>所以k 阶主子式是不唯一的，而 <strong>k 阶顺序主子式是唯一的</strong>。</p></blockquote><p>用在判断<strong>二次型正定</strong>上，下面会讲。</p><h4 id="四-矩阵的秩">四.矩阵的秩</h4><p>① 0 &lt;= r(A) &lt;= min{m,n}</p><p>② r(kA)=r(A)(k ≠ 0)</p><p>③ r(AB) &lt;= min{r(A),r(B)}</p><p>④ r(A+B) &lt;=r(A)+r(B)</p><p>⑤</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be17ac8a1.png" alt="img"></p><p>r(A)=n-1,r(A*)=1的证明：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1808208.jpeg" alt="img"></p><p>进而可得出一个重要结论：</p><blockquote><p><em><em><em>*</em>*****************A************m****∗****n********************B************n****∗****s**************=****0************𝐴𝑚∗𝑛𝐵𝑛∗𝑠=0*****</em>*</em>，则r(A)+r(B)&lt;=n****</p></blockquote><p>所以，看到A*B就要想到两个结论：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be18c42df.png" alt="img"></p><p>⑥ 设A是m*n矩阵，P,Q分别是m阶，n阶可逆矩阵，则</p><blockquote><p>r(A)=r(PA)=r(AQ)=r(PAQ)</p></blockquote><p>⑦ r(A)=r(AT)𝑟(𝐴𝑇)=r(AAT𝐴𝐴𝑇)=r(ATA𝐴𝑇𝐴)</p><p>关于⑤的例题：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1968a2a.png" alt="img"></p><p>为什么Ax=b有n-r+1个线性无关的解：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1a401a8.png" alt="img"></p><h5 id="-3"></h5><h4 id="五-常用特征值与特征向量">五.常用特征值与特征向量</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1977f3e.png" alt="img"></p><p><strong>注意这样一道例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1989394.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1a81805.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1a5656c.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1a9ec52.png" alt="img"></p><p>关于特征值的一些提示：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1bd81d8.png" alt="img"></p><h4 id="六-矩阵，向量组，方程组">六.矩阵，向量组，方程组</h4><p><strong>矩阵，向量组</strong></p><blockquote><p>① <strong>向量组</strong>是由有限个相同维数的行向量或者列向量组成，其中向量是由n个实数组成的有序数组,是一个n<em>1的矩阵(n维列向量)或是一个1</em>n的矩阵(n维行向量)。</p><p>② <strong>矩阵</strong>是由m*n个数排列成m行n列的数表。</p><p><strong>一个向量组可以看作是一个矩阵的列（或行）向量集合</strong>。如果一个矩阵有n列，那么这n列就可以看作是一个由n个向量组成的向量组。反过来，一个矩阵也可以看作是由其列（或行）向量组成的向量组。</p></blockquote><h5 id="1-怎么判断两个矩阵等价">1.怎么判断两个矩阵等价</h5><blockquote><p>矩阵等价的前提：A与B是****同型****矩阵，即A,B行数，列数相同</p><p>矩阵等价的<strong>充要条件</strong>：</p><p>① r(A)=r(B)</p><p>② PAQ=B，P,Q可逆</p></blockquote><h5 id="2-怎么判断两个向量组是等价向量组">2.怎么判断两个向量组是等价向量组</h5><blockquote><p>向量组等价的前提：A，B矩阵****同维****</p><p>若r( Ⅰ )=r(α1,α2,α3,α4𝛼1,𝛼2,𝛼3,𝛼4…) r(Ⅱ)=r(β1,β2,β3,β4𝛽1,𝛽2,𝛽3,𝛽4…)</p><p>向量组等价的<strong>充要条件</strong>：<br>① r(Ⅰ)=r(Ⅱ)，且(Ⅰ)可由(Ⅱ)线性表出（单向表出即可）</p><p>② r(Ⅱ)=r(Ⅰ)，且(Ⅱ)可由(Ⅰ)线性表出（单向表出即可）</p><p>③ r(α1,α2,α3,α4𝛼1,𝛼2,𝛼3,𝛼4…) =r(β1,β2,β3,β4𝛽1,𝛽2,𝛽3,𝛽4…) =r(α1,α2,α3,α4𝛼1,𝛼2,𝛼3,𝛼4…,β1,β2,β3,β4𝛽1,𝛽2,𝛽3,𝛽4…)，即</p><p>r(Ⅰ)=r(Ⅱ)=r(Ⅰ，Ⅱ)</p><p>④ Ⅰ和Ⅱ能够相互线性表示。</p></blockquote><blockquote><p><strong>总结：</strong><br>① 两个矩阵A与B等价指的是A可以通过有限次初等变换变成B。两个不同型矩阵是不可能等价<br>乡<br>② 两个向量组等价只指的是它们能够互相线性表示，它们各自所含向量的个数可能是不一样的。</p></blockquote><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1c02c42.png" alt="img"></p><blockquote><p>D.即使Ⅰ 和 Ⅱ 同为n维向量组，但是s与t的关系未知，也就是行数相等，列数未知，所以A，B两个矩阵可能不同型，不能等价。</p><p>B.(Ⅰ)可由（Ⅱ）表示，缺少其他条件，如果① 加上(Ⅱ)可由(Ⅰ)线性表出 或者② r(Ⅰ)=r(Ⅱ)就对了</p><p>C正确</p><p>D r(A)=r(B)，只能推出两个向量组秩相同，缺少其他条件，如果加上① 加上(Ⅱ)可由(Ⅰ)线性表出 或者②加上(Ⅰ )可由(Ⅱ)线性表出或者③ r(Ⅰ)=r(Ⅱ)=r(Ⅰ，Ⅱ)，就对了。</p></blockquote><h5 id="3-矩阵和向量等价的比较">3.矩阵和向量等价的比较</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1bf17fc.png" alt="img"></p><p><strong>例题：</strong></p><h5 id="img"><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1c75912.png" alt="img"></h5><blockquote><p>A.(α1,α2,α3,0𝛼1,𝛼2,𝛼3,0)能与(α1,α2,α3𝛼1,𝛼2,𝛼3)相互线性表示，但是(α1,α2,α3,0𝛼1,𝛼2,𝛼3,0)不是Ax=0的基础解系</p><p>B.基础解系一定是线性无关的，但是B选项3个向量是线性相关的（3个向量相加=0）</p><p>C.像上面举的例子一样，α1α2𝛼1𝛼2，β1β2𝛽1𝛽2等秩，但是α1α2𝛼1𝛼2与β1β2𝛽1𝛽2不能相互线性表示。</p><p>D.<img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1c58bf6.png" alt="img"></p><p>在(α1,α2,α3𝛼1,𝛼2,𝛼3)的右边乘可逆矩阵，不改变原来矩阵的秩，且(β1,β2,β3𝛽1,𝛽2,𝛽3)与(α1,α2,α3𝛼1,𝛼2,𝛼3)能相互线性表示</p><p><strong>所以，求Ax=0的另一个基础解析，需要满足与(*<em>******************α********1**********,**********α********2**********,**********α********3******************𝛼1,𝛼2,𝛼3*****</em>)等价且等秩。</strong></p></blockquote><h5 id="-4"></h5><h5 id="4-同解方程组">4.同解方程组</h5><p>若两个方程组Am∗nx=0𝐴𝑚∗𝑛𝑥=0与Bs∗nx=0𝐵𝑠∗𝑛𝑥=0有完全相同的解，则称它们为同解方程组</p><blockquote><p><strong>充要条件：</strong></p><p>① Ax=0的解满足Bx=0，且Bx=0的解满足Ax=0(互相把解代入求出结果即可)</p><p>② r(A)=r(B)，且Ax=0的解满足Bx=0(或Bx=0的解满足Ax=0)</p><p>③ r(A)=r(B)=r([AB][𝐴𝐵])(三秩相同)</p></blockquote><p><strong>例1：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1c67ad1.png" alt="img"></p><p><strong>例2：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1da3ebf.png" alt="img"></p><p><strong>例3：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1da5b0a.png" alt="img"></p><h5 id="-5"></h5><h4 id="七-齐次线性方程组和非齐次线性方程组">七.齐次线性方程组和非齐次线性方程组</h4><blockquote><p><strong>齐次线性方程组有解的条件：</strong></p><p>① r(A)=n时，方程组有<strong>唯一零解</strong>。</p><p>② r(A)=r&lt;n时，方程组有非零解（无穷多解），且有n-r个线性无关解</p><p><strong>齐次方程组其实就是解和系数的正交</strong>，例如，给你一个条件：</p><p>α1=2α2+α3𝛼1=2𝛼2+𝛼3----&gt;α1−2α2−α3+0α4=0𝛼1−2𝛼2−𝛼3+0𝛼4=0</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1dbfe23.png" alt="img"></p><p>则(1 -2 -1 0)就是齐次方程组的基础解系</p></blockquote><blockquote><p><strong>非齐次线性无关组有解的条件：</strong></p><p>① 若r(4)≠r([A,b])，则方程组无解；<br>② 若r(A)=r([A,b])=n，则方程组有唯一解；<br>③ r(A)=r([A,b])=r&lt;n，则方程组有无穷多解。</p></blockquote><blockquote><p>非齐次方程组的通解的求法：</p><p>①求Ax=0的解</p><p>② 求Ax=b的一个特解</p><p>③ 非齐次方程组的通解=齐次方程组的解+一个非齐次的特解</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1ed632d.png" alt="img"></p><blockquote><p>如果A行满秩，则r(A)=r(A|b)，那么方程组一定有解。</p><p>如果A列满秩，则r(A)与r(A|b)的关系不确定：</p><p>① <strong>r(A)&lt;r(A|b)，则无解</strong></p><p>② <strong>r(A)=r(A|b)&lt;n，有无穷多解</strong></p><p>③ <strong>r(A)=r(A|b)=n，有唯一解</strong></p></blockquote><p><strong>非齐次方程组解的性质：</strong></p><blockquote><p>若η1η2η3𝜂1𝜂2𝜂3是非齐次线性方程组Ax=b的解，ξ𝜉是对应齐次方程组Ax=0的解，则：<br>(1) η1−η2𝜂1−𝜂2是Ax=0的解；（2）kξ+η𝑘𝜉+𝜂是Ax=b的解</p></blockquote><p>扩展：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1ec96b0.png" alt="img"></p><blockquote><p>解释：</p><p>1.p个解的任意组合，都是齐次线性方程组的解</p><p>2.非齐次的解线性组合也能得到齐次线性方程组的解，但是需要满足k1+k2+…+kp=0，例如，α1−α2𝛼1−𝛼2=0(1-1=0),α1−α2𝛼1−𝛼2就是齐次线性方程组的解。</p><p>3.非齐次的解线性组合也能得到非齐次线性方程组的解，但是需要满足k1+k2+…+kp=1，例如，(α1+α2)/2(𝛼1+𝛼2)/2，就是非齐次线性方程组的一个解。</p><p>4.齐次线性方程组的解与非齐次线性方程组的解相加，得到的是非齐次线性方程组的解。</p><p>5.r(A)=r，A就有n-r个线性无关的解，而x1,x2,…xn−r𝑥𝑛−𝑟刚好是Ax=0的n-r个线性无关解，所以</p><p>k1x1+k2x2+…+kn−rxn−r𝑘𝑛−𝑟𝑥𝑛−𝑟是Ax=0的解。</p></blockquote><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1eca0c3.png" alt="img"></p><blockquote><p>A.α1−α2𝛼1−𝛼2是组合系数是1-1=0，α1−α2𝛼1−𝛼2是Ax=0的解</p><p>B.3α1−2α23𝛼1−2𝛼2是Ax=b的解，C,D同理。</p></blockquote><h5 id="-6"></h5><h4 id="八-对比记忆"><strong>八.对比记忆</strong></h4><p><strong>1.</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1f5ee5b.png" alt="img"></p><p><strong>矩阵A的tr(A)：tra(A)=矩阵A的迹=对角线元素之和</strong></p><p>**2.**对于秩为1的n阶矩阵A或A=αβT𝛼𝛽𝑇(或βTα𝛽𝑇𝛼)（a,β都是n维非零列向量），其特征值为λ1λ2λ3…λn−1𝜆1𝜆2𝜆3…𝜆𝑛−1=0，λn=∑ni=1aii=βTα𝜆𝑛=∑𝑖=1𝑛𝑎𝑖𝑖=𝛽𝑇𝛼（或αTβ𝛼𝑇𝛽）</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1f593c8.png" alt="img"></p><p><strong>3.</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be204a814.png" alt="img"></p><p><strong>例题1：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2066a1e.png" alt="img"></p><p><strong>例题2：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be20bc1f4.png" alt="img"></p><h4 id="九-相似与正交"><strong>九.相似与正交</strong></h4><p>存在n阶可逆矩阵P，使得P−1AP=B𝑃−1𝐴𝑃=𝐵,则称A相似于B，记为A~B</p><blockquote><p>若A~B</p><p>① |A|=|B|</p><p>② r(A)=r(B)</p><p>③ tr(A)=tr(B)</p><p>④ λA=λB𝜆𝐴=𝜆𝐵（|λE−A|=|λE−B||𝜆𝐸−𝐴|=|𝜆𝐸−𝐵|）</p><p>⑤ r(λE−A)=r(λE−B)𝑟(𝜆𝐸−𝐴)=𝑟(𝜆𝐸−𝐵)</p><p><em><strong>*⑥ A，B各阶主子式之和分别相同*</strong></em></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be222816e.png" alt="img"></p><p>也就是说，A与B即使特征值相同，但也不一定相似。但是如果A，B都是实对称矩阵，那么相似，则一定特征值相同（实对称矩阵一定能相似对角化，特征值相同一定能相似于同一个对角矩阵，根据传递性A~B）。</p><p><strong>那么怎么判定矩阵相似呢？</strong></p><blockquote><p>① 定义法</p><p>存在n阶可逆矩阵P，使得P−1AP=B𝑃−1𝐴𝑃=𝐵</p><p>② 传递法</p><p>A~ΛΛ，ΛΛ~B，则A~B，其中ΛΛ为对角阵</p><p>这就要说到矩阵的相似对角化</p></blockquote><p><strong>矩阵可相似对角化的条件：</strong></p><blockquote><p><strong>充要条件：</strong></p><p>① n阶矩阵A可相似对角化↔有n个线性无关的特征向量。</p><p>② n阶矩阵A可相似对角化↔A对应于每个k重特征值都有k个线性无关的特征向量</p><p><strong>必要条件：</strong></p><p>③ n阶矩阵A有n个不同特征值→A可相似对角化</p><p>④ n阶矩阵为<strong>实对称矩阵</strong>→A可相似对角化</p></blockquote><p>对于矩阵相似对角化的步骤：</p><blockquote><p>① 求特征值</p><p>② 求特征向量</p><p>③ 正交化（如果需要的话），单位化η1η2η3…ηn𝜂1𝜂2𝜂3…𝜂𝑛</p><p>④ 令Q=[η1η2η3…ηn𝜂1𝜂2𝜂3…𝜂𝑛],则Q为正交矩阵，且Q−1AQ=QTAQ=Λ𝑄−1𝐴𝑄=𝑄𝑇𝐴𝑄=Λ</p></blockquote><p>上面提到了实对称矩阵，实对称矩阵就是组成A的元素都是实数。对于实对称矩阵（AT=A𝐴𝑇=𝐴）要记住：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2250f42.png" alt="img"></p><blockquote><p><strong>对于正交，你需要记住：</strong><br>① αTβ=0𝛼𝑇𝛽=0，则<img src="https://latex.csdn.net/eq?%5Calpha" alt="\alpha">，<img src="https://latex.csdn.net/eq?%5Cbeta" alt="\beta">是正交向量</p><p>② 若满足ATA=E𝐴𝑇𝐴=𝐸，则A是正交矩阵</p><p>ATA=E𝐴𝑇𝐴=𝐸↔A−1=AT𝐴−1=𝐴𝑇</p></blockquote><p>例题：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be20c78f6.png" alt="img"></p><p><strong>不可对角化的矩阵怎么判断相似：</strong></p><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2286469.png" alt="img"></p><blockquote><p>如果A与B相似，那么：</p><p>对于任意实数k和整数n，有(A+kE)n(𝐴+𝑘𝐸)𝑛与(B+kE)n(𝐵+𝑘𝐸)𝑛相似</p><p>对于上面这道题，取k=-1，n=1，判断哪两个矩阵相似。</p></blockquote><p><strong>矩阵相似还可得出：</strong></p><blockquote><p>① A~B，Ak=Bk𝐴𝑘=𝐵𝑘，f(A)=f(B)</p><p>② 若A~B，且A可逆，则A−1𝐴−1~B−1𝐵−1，f(A−1𝐴−1)=f(B−1𝐵−1)</p><p>③ 若A~B，A∗𝐴∗~B∗𝐵∗</p><p>④ 若A~B，AT𝐴𝑇~BT𝐵𝑇</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be22f103e.png" alt="img"></p></blockquote><p><strong>注：</strong></p><h4 id="img-2"><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be23741bd.png" alt="img"></h4><h5 id="-7"></h5><h4 id="十-合同">十.合同</h4><p>设A，B为n阶矩阵，若存在可逆矩阵C，使得CTAC=B𝐶𝑇𝐴𝐶=𝐵，则称A与B合同，即A≅B𝐴≅𝐵。A与B合同，就是指同一个<strong>二次型</strong>在<strong>可逆线性变换</strong>下的两个不同状态的联系。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be23716ca.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be23c6528.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be240b87e.png" alt="img"></p><p>**注：**由于我们已经规定，对称矩阵才是二次型矩阵，所以二次型矩阵都是对称矩阵，相应的和对称矩阵合同的矩阵也是对称矩阵。</p><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be23c6692.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be245dd6f.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be24aba92.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be24a8cd1.png" alt="img"></p><h5 id="-8"></h5><h4 id="十一-二次型">十一.二次型</h4><p>关于二次型化标准型或规范型的方法：配方法，正交变化有总结如下：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be260b287.png" alt="img"></p><p><strong>所以我们可以进一步得到</strong></p><h5 id="等价，合同和相似的关系："><strong>等价，合同和相似的关系：</strong></h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be26b3cd5.png" alt="img"></p><p>**注：**相似一定合同的前提条件是A，B都是实对称矩阵</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2634cf1.png" alt="img"></p><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be265a9df.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be27a8028.png" alt="img"></p><p>关于配方法和正交变换分别给一个例题：<br><strong>配方法：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be28c1744.png" alt="img"></p><p><strong>正交变换：</strong><br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be27ea985.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be27d854c.png" alt="img"></p><blockquote><p>① 若λ1=λ2𝜆1=𝜆2，那么两个同一特征值对应的特征向量需要正交化，如果本来就正交可以不做这一步，所以在计算特征值的时候，可以将两个特征向量写为正交的，这样就免去了施密特正交化，直接进入单位化即可。</p><p>② λ1≠λ2≠λ3𝜆1≠𝜆2≠𝜆3，那么不用进行施密特正交，直接单位化即可。</p></blockquote><p><strong>常见题型：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be27a8802.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be28ccb91.png" alt="img"></p><p>这里记录一个例题：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be29b50e6.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be29d5c66.png" alt="img"></p><p>若二次型中只有混合项，没有平方项，要怎么做？</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2a51d99.png" alt="img"></p><h4 id="十二-二次型正定">十二.二次型正定</h4><blockquote><p><strong>二次型正定的充要条件：</strong><br>n元二次型f=xTAx𝑓=𝑥𝑇𝐴𝑥正定↔对任意x≠0，有xTAx𝑥𝑇𝐴𝑥&gt;0（定义）</p><p>① ↔f的正惯性指数p=n</p><p>② ↔存在可逆矩阵D，使得A=DTD𝐴=𝐷𝑇𝐷</p><p>③ ↔A≅E𝐴≅𝐸，A与E合同</p><p>② ③推导：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be29ead4d.png" alt="img"></p><p>④↔A的特征值λ𝜆&gt;0</p><p>⑤↔A的全部顺序主子式&gt;0</p><p><strong>二次型正定的必要条件：</strong></p><p>① aii𝑎𝑖𝑖&gt;0，对角线元素全部大于0</p><p>② |A|&gt;0</p></blockquote><p>最好是使用充要条件① ④ ⑤判断二次型是否正定，如果非要用定义法，来看个例题：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2b97057.png" alt="img"></p><p>注意上题，不能直接将f判定为正定：</p><p>因为将二次型化为标准型的过程一定要做<strong>可逆线性变换</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2b73fd4.png" alt="img"></p><p><strong>例题1：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2bde67d.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2bbdd65.jpeg" alt="img"></p><p><strong>例题2：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2c370ad.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2bd06ac.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2de5d54.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2f0a59c.png" alt="img"></p>]]></content>
    
    
    <summary type="html">收集到的一些高代复习资料</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构复习其二</title>
    <link href="https://zhongye1.github.io/posts/7eb63ac7.html"/>
    <id>https://zhongye1.github.io/posts/7eb63ac7.html</id>
    <published>2024-07-25T18:48:08.000Z</published>
    <updated>2024-07-31T03:58:47.890Z</updated>
    
    <content type="html"><![CDATA[<ul><li></li></ul><h3 id="——算法、线性表——">——算法、线性表——</h3><h3 id="概念明晰：随机存取、顺序存取、随机存储和顺序存储">概念明晰：随机存取、顺序存取、随机存储和顺序存储</h3><blockquote><p>随机存取、顺序存取、随机存储和顺序存储这四个概念是完全不一样的，切不可将之混淆</p><p>很多人包括我可能认为随机存取就是随机存储，顺序存取就是顺序存取，其实不是这样。</p></blockquote><p>下面完整的介绍一下这4个概念</p><h5 id="1、存取结构">1、存取结构</h5><h5 id="分为随机存取和非随机存取（又称顺序存取）">分为<code>随机存取</code>和<code>非随机存取</code>（又称顺序存取）</h5><blockquote><p>1、<code>随机存取</code>就是<code>直接存取</code>，可以通过<strong>下标直接访问</strong>的那种<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;spm=1001.2101.3001.7020">数据结构</a>，与<strong>存储位置无关</strong>。例如数组。</p><p><code>非随机存取</code>就是<code>顺序存取</code>，不能通过下标访问了，只能<strong>按照存储顺序存取</strong>，与<strong>存储位置有关</strong>，例如链表。</p><p>2、<code>顺序存取</code>就是存取第N个数据时，<strong>必须先访问</strong>前（N-1）个数据 （list）;</p><p><code>随机存取</code>就是存取第N个数据时，<strong>不需要</strong>访问前（N-1）个数据，<strong>直接</strong>就可以对第N个<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C&amp;spm=1001.2101.3001.7020">数据操作</a> （array）。</p></blockquote><h5 id="2、存储结构">2、存储结构</h5><h5 id="分为顺序存储和随机存储">分为<code>顺序存储</code>和<code>随机存储</code></h5><h5 id="3、顺序存储结构">3、顺序存储结构</h5><blockquote><ul><li><p>在计算机中用一组<strong>地址连续的存储单元</strong>依次存储线性表的各个数据元素，称作线性表的顺序存储结构。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>顺序存储结构是存储结构类型中的一种，该结构是把<span class="strong">**逻辑上相邻的节点**</span>存储在<span class="strong">**物理位置上相邻的存储单元**</span>中，结点之间的逻辑关系由存储单元的邻接关系来体现。 </span><br><span class="line"><span class="bullet">- </span>由此得到的储结构为顺序存储结构，通常顺序存储结构是借助于计算机程序设计语言（例如c/c++）的数组来描述的。</span><br><span class="line">12</span><br></pre></td></tr></table></figure></li></ul><p>– <strong>主要优点</strong>：节省存储空间。</p><p>因为分配给数据的存储单元全用存放结点的数据（不考虑c/c++语言中数组需指定大小的情况），结点之间的逻辑关系没有占用额外的存储空间。采用这种方法时，<strong>可实现对结点的随机存取</strong>，即每一个结点对应一个序号，由该序号可以<strong>直接计算出来结点的存储地址</strong>。</p><p>– <strong>主要缺点</strong>：不便于修改，对结点的插入、删除运算时可能要移动一系列的结点。</p></blockquote><h5 id="4、随机存储结构">4、随机存储结构</h5><blockquote><p>在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。它不要求逻辑上相邻的元素在物理位置上也相邻。因此它没有顺序存储结构所具有的弱点，但也同时失去了顺序表可随机存取的优点。</p></blockquote><p>–随机存储<strong>最典型的代表</strong>为链式存储：</p><p>链式存储结构特点</p><p>1、比顺序存储结构的存储密度小 （每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多）。</p><p>2、逻辑上相邻的节点物理上不必相邻。</p><p>3、插入、删除灵活 （不必移动节点，只要改变节点中的指针）。</p><p>4、查找结点时链式存储要比顺序存储慢。</p><p>5、每个结点是由数据域和指针域组成</p><h4 id="一、数据结构的概念">一、数据结构的概念</h4><h5 id="1、基本概念">1、基本概念:</h5><blockquote><ul><li>数据：描述客观事实的符号，是计算机中可以操作的对象，能被计算机识别，并输给计算机处理的符号集合。</li><li>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被成为记录。</li><li>数据对象：是性质相同数据元素的集合，是数据的一个子集。</li><li>数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位。</li><li>数据结构：相互之间存在一种或者多种特定关系的数据元素的集合。可分为逻辑结构和物理结构。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3aa801.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-H2EEsw2b-1641217649127)(myReviewPicture/数据结构的类别-16411800000834.jpg)]"></p><h5 id="2、算法">2、算法</h5><h6 id="1-概念">(1)概念</h6><blockquote><p>解决特定问题的求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p></blockquote><h6 id="2-重要特性：">(2)重要特性：</h6><blockquote><p><strong>①输入</strong>：有零个输入或者多个输</p><p><strong>②输出</strong>：只有一个或者多个输出</p><p><strong>③有穷性</strong>：算法在执行有限个步骤时，会自动结束而不会陷入无限循环里面</p><p><strong>④确定性</strong>：算法的每一步都有确定的含义而不会出现二义性</p><p><strong>⑤可行性</strong>：算法的每一步都可以通过有限次数完成。</p></blockquote><h5 id="3、算法的评价标准-“好”的算法应该考虑达到以下目标">3、算法的评价标准(“好”的算法应该考虑达到以下目标)</h5><blockquote><p><strong>①正确性</strong>。算法能够正确地求解问题。</p><p><strong>②可读性</strong>。算法能具有良好的可读性，以帮助人们理解。</p><p><strong>③健壮性</strong>。输入非法数据时，算法能适当地做出反应或进行处理。而不会产生莫名其妙的输出结果。</p><p><strong>④效率与低存储量需求</strong>。效率指算法执行的时间，存储量需求是指算法执行过程中所需的最大存储空间。</p></blockquote><h5 id="4、算法的时空效率">4、算法的时空效率</h5><h6 id="1-时间复杂度">(1)时间复杂度</h6><h6 id="根据算法写成的程序在执行时耗费时间的长度，记为T-n-O-n">根据算法写成的程序在执行时耗费时间的长度，记为T(n) = O(n)</h6><h6 id="2-空间复杂度">(2)空间复杂度</h6><h6 id="根据算法写成的程序在执行时占用存储单元的长度记为S-n">根据算法写成的程序在执行时占用存储单元的长度记为S(n)</h6><h6 id="3-语句频度">(3)语句频度</h6><h6 id="一个算法中的语句执行次数称为语句频度或时间频度，记为T-n">一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)</h6><blockquote><p>时间复杂度：时间复杂度实际上是一个函数，代表基本操作重复执行的次数，进而分析函数虽变量的变化来确定数量级，数量级用O表示，所以算法的时间复杂度为： T（n）=O（f（n））</p></blockquote><blockquote><p>在一个算法存在最好、平均、最坏<strong>三种情况</strong>，我们一般关注的是<strong>最坏情况</strong>，原因是，最坏情况是任何输入实例在运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，从大体上来看，平均情况和最坏情况一样差。</p></blockquote><h6 id="4-一般O（n）的计算方法：">(4)一般O（n）的计算方法：</h6><blockquote><p>①用 1代替所有运行时间中出现的<strong>加法常数</strong>；</p><p>②在修改后的运行函数中**保留最高阶的项；</p><p>③如果<strong>最高阶</strong>的<strong>项系数不是1</strong>，则<strong>去除</strong>这个项系数。</p><p>④ <strong>递归算法</strong>的时间复杂度为：递归总次数每次递归中基本操作执行的次数。</p></blockquote><h6 id="5-常见的时间复杂度有以下七种：">(5)常见的时间复杂度有以下七种：</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3338b6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fChDxRHo-1641217649129)(myReviewPicture/时间复杂度的比较-16411800195595.png)]"></p><p><strong>① O（1）常数型；② O（log2N）对数型；③ O（N）线性型；④ O（Nlog2N）二维型；⑤ O（N^2)平方型；⑥ O（N^3)立方型；⑦ O（2^N）指数型。</strong></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;①</span><br><span class="line"><span class="keyword">while</span> (i&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">i=i*<span class="number">2</span>; ②</span><br><span class="line">&#125;</span><br><span class="line">解：语句<span class="number">1</span>的频度是<span class="number">1</span>, </span><br><span class="line">设语句<span class="number">2</span>的频度是f(n),则：<span class="number">2</span>^f(n)&lt;=n;f(n)&lt;=log2n  </span><br><span class="line">取最大值f(n)= log2n, T(n)=O(log2n )</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h3 id="二、线性表">二、线性表</h3><h4 id="1、顺序存储">1、顺序存储</h4><h5 id="1-结构体的定义">(1)结构体的定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> * PtrToLNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElmenetType Data[ MAXSIZE ];</span><br><span class="line">    Position Last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h5 id="2-顺序表的初始化">(2)顺序表的初始化</h5><blockquote><p>1、构造一个空表</p><p>2、动态分配表结构所需的存储空间，然后将表中Last指针置为-1 表示表中没有数据。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    L = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    L-&gt;Last = <span class="number">-1</span>;<span class="comment">//Last 置为-1 表示表中没有数据元素</span></span><br><span class="line">    Return L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><ul><li>通过L我们可以访问相应线性表的内容。比如：下标为i 的元素：L-&gt;Data[i]</li><li>查询线性表的长度：L-&gt;Last+1;</li></ul><h5 id="3-顺序表的查找-时间复杂度为O-n">(3)顺序表的查找(时间复杂度为O(n))</h5><blockquote><p>在线性表中<strong>查找与给定值 X 相等</strong>的数据元素。</p><p>由于线性表的元素都<strong>存储在数组Data</strong>中，所以这个查找的过程<strong>实际上就是在数组里顺序查找</strong>：</p><ul><li>从<strong>第 1 个元素 a1</strong> 起依次和 X 比较， 直到找到一个与 X <strong>相等</strong>的数据元素，返回它在顺序表中的<strong>存储下标</strong>；</li><li>或者<strong>查遍整个表</strong>都<strong>没有找到</strong>与 X 相等的元素，则返回错误信息 <strong>ERROR</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR -1  <span class="comment">/* 将错误信息 ERROR 的值定义为任一负数都可以 */</span></span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">While</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X)</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>( i &gt; L-&gt;Last)</span><br><span class="line">    <span class="keyword">return</span> ERROR;<span class="comment">/* 如果没有找到，则返回错误信息 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> i;<span class="comment">/* 找到后返回的是存储位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h5 id="4）顺序表的插入-时间复杂度为O-n">(4）顺序表的插入 (时间复杂度为O(n))</h5><blockquote><p>在表的插入是指在表的第 i（1≤ i ≤ n + 1）个位序上<strong>插入一个值为 X 的新元素</strong>（也可以理解为在第 i 个元素之前插入新的元素）</p><p>插入后使得<strong>原来长度为 n</strong> 的序列，变为<strong>长度为 n+1</strong>的序列（i = 1时插入序列的最前端，i = n+1 时插入序列的最后）</p><ul><li>将ai~an<strong>顺序向后</strong>移动（移动次序是从 an 到ai)，<strong>为新元素让出位置</strong>；</li><li>将 X 放入空出的<strong>第 i 个位序</strong>；</li><li><strong>修改</strong> Last 指针（相当于修改表长）,使之指向<strong>最后一个元素</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 在 L 的指定位序 i 前插入一个新元素 X； 位序 i 元素数组位置下标为 i-1 */</span></span><br><span class="line">    Postion j;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Last == MAXSIZE<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="comment">/* 表空间已满，不能插入 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表满！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( i&lt;<span class="number">1</span> || i &gt; L-&gt;Last+<span class="number">2</span>)</span><br><span class="line">    &#123;<span class="comment">/* 检查插入位序的合法性：是否在 1~n+1； n为当前元素个数，即Last+1 */</span></span><br><span class="line">        printf（<span class="string">&quot;位序不合法！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( j = L-&gt;Last; j &gt;= i<span class="number">-1</span>; j--) <span class="comment">/*Last 指向序列最后元素an */</span></span><br><span class="line">        L-&gt;Data[j+<span class="number">1</span>] = L-&gt;Data[j]; <span class="comment">/* 将位序为 i 及以后的元素顺序向后移动 */</span></span><br><span class="line">   L-&gt;Data[i<span class="number">-1</span>] = X;<span class="comment">/* Last 仍指向最后一个元素 */</span></span><br><span class="line">    L-&gt;Last++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure><h5 id="5-顺序表的删除（时间复杂度为O-n-）">(5)顺序表的删除（时间复杂度为O(n)）</h5><blockquote><p>将表中的位序为 i（1≤ i ≤ n + 1）的元素从线性表中去掉，删除后使原长度为 n 的数组元素序列,变为长度为 n-1 的序列</p><ul><li>将a[i+1]~a[n] <strong>顺序向前移动</strong> ，a[i] 元素被a[i+1]覆盖；</li><li><strong>修改</strong> Last 指针（相当于修改表长）使之仍指向<strong>最后一个元素</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Delete</span><span class="params">(List L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">/*从 L 中删除指定位序 i 的元素，该元素数组下标为 i-1*/</span></span><br><span class="line">Position j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;Last + <span class="number">1</span>)<span class="comment">/* 检查空表及删除位序的合法性*/</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;位序%d不存在元素&quot;</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>( j = i; i &lt;= L-&gt;Last; j++)</span><br><span class="line">L-&gt;Data[j<span class="number">-1</span>] = L-&gt;Data[j];<span class="comment">/*将位序 i+1 及以后的元素顺序向前移动*/</span> </span><br><span class="line">L-&gt;Last--;<span class="comment">/*Last 仍指向最后元素*/</span> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><h4 id="2、链表存储">2、链表存储</h4><h6 id="1）结构体的定义（时间复杂度为O-n-）">(1）结构体的定义（时间复杂度为O(n)）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> * PtrToLNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position; <span class="comment">/*这里的位置是结点的地址 */</span></span><br><span class="line"><span class="keyword">typedef</span> PreToLNode List;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h6 id="2-求表长（时间复杂度为O-n-）">(2)求表长（时间复杂度为O(n)）</h6><blockquote><p>在<strong>顺序存储</strong>中求表长是很容易的，<strong>直接返回 Last+1</strong> 就可以了。但在<strong>链式存储</strong>中，需要将链表<strong>从头到尾遍历一遍</strong></p><ul><li>设一个<strong>移动指针p和计数器cnt</strong>，初始化后，p从表的第 1 个结点开始逐步往后移，同时计数器 cnt+1.</li><li>当后面不再有结点时，cnt 的值就是结点个数，即 表长。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3dea89.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//默认该链表是有头结点的   </span></span><br><span class="line">Position p;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;  <span class="comment">/* 初始化计数器 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//单向链表的遍历(三部曲)</span></span><br><span class="line">p = L-&gt;next; <span class="comment">/* p指向表的第 1 个结点 */</span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123; <span class="comment">/* 遍历单链表，统计结点数 */</span> </span><br><span class="line">p=p-&gt;next;  </span><br><span class="line">i++; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h6 id="3-判空">(3)判空</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//若 L 为空，则返回1，否侧返回 0</span></span><br><span class="line"><span class="keyword">if</span>(L-&gt;Next) <span class="comment">//非空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h6 id="4-查找（时间复杂度为O-n-）">(4)查找（时间复杂度为O(n)）</h6><blockquote><p>有两种 按序号查找（FindKth）和 按值查找（Find）</p></blockquote><h6 id="①按序号查找-FindKth（时间复杂度为O-n-）">①按序号查找 FindKth（时间复杂度为O(n)）</h6><blockquote><p>对于<strong>顺序存储</strong>，按序号查找是很直接的事情，要得到<strong>第 K 个元素的值，直接取L-&gt;Data[K-1]即可</strong>。</p><p>但是对于<strong>链式存储</strong>则需要采用跟<strong>求表长类似的思路</strong>：</p><ul><li>从链表的<strong>第 1 个元素</strong>结点起，判断<strong>当前结点是否是第 K 个</strong>；</li><li>若<strong>是</strong>，则<strong>返回</strong>该结点的值，<strong>否</strong>则继续<strong>对比后一个</strong>，直到<strong>表结束为止</strong>。</li><li>如果<strong>没有</strong>第 K 个结点则返回<strong>错误信息</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR -1 <span class="comment">/* 一般定义为表中元素不可能取到的值 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">FindKth</span><span class="params">(List L, <span class="type">int</span> K)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/* 根据指定的位序 K， 返回 L 中相应的元素 */</span></span><br><span class="line">Position P;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>; <span class="comment">/* 位序从 1 开始 */</span></span><br><span class="line">p = L; <span class="comment">/* p 指向 L的第 1 个结点 */</span></span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; cnt &lt; K)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">cnt++</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((cnt == K) &amp;&amp; p)</span><br><span class="line"><span class="keyword">return</span> p-&gt;Data;<span class="comment">/* 返回第 K 个 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/* 否则返回错误信息 */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure><h6 id="②按值查找，即定位-Find（时间复杂度为O-n-）">②按值查找，即定位 Find（时间复杂度为O(n)）</h6><blockquote><p>基本方法：也是从头到尾遍历，直到找到为止：</p><ul><li>从链表的<strong>第 1 个元素</strong>结点起，判断<strong>当前结点的值是否等于 X</strong>；</li><li>若<strong>是</strong>，<strong>返回</strong>该结点的<strong>位置</strong>，<strong>否</strong>则继续<strong>对比后一个</strong>，直到<strong>表结束位置为止</strong>；</li><li><strong>找不到</strong>时返回<strong>错误信息</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR NULL <span class="comment">/*空地址表示错误 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position p = L;<span class="comment">/* p指向 L 的第 1 个元素 */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;Data != x)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><h6 id="5-链表的插入（时间复杂度为O-n-）">(5)链表的插入（时间复杂度为O(n)）</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f4967cd.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f4db83a.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i,ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp; j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="comment">//寻找第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;<span class="comment">//</span></span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//生成新结点s</span></span><br><span class="line">    s-&gt;data = e;<span class="comment">//将结点s 的数据域的值 更新为 e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">//将结点s 插入 L 中</span></span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><h6 id="6-创建链表（时间复杂度为O-n-）">(6)创建链表（时间复杂度为O(n)）</h6><h6 id="1、带头结点的【头插法】（时间复杂度为O-n-）">1、带头结点的【头插法】（时间复杂度为O(n)）</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3db996.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 带头结点的插入创建 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createListHead</span><span class="params">( Linklist L, <span class="type">int</span> n )</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">//建立头结点</span></span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//建立单链表（头插法）</span></span><br><span class="line">    LNode *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//申请空间，写入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode)); <span class="comment">/* 申请、填装结点 */</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp-&gt;Data);<span class="comment">//输入元素值</span></span><br><span class="line">            <span class="comment">//插入到头结点的后面</span></span><br><span class="line">        tmp-&gt;Next = L-&gt;Next; </span><br><span class="line">        L-&gt;Next = tmp;   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure><h6 id="2、带尾结点的插入【尾插法】（时间复杂度为O-n-）">2、带尾结点的插入【尾插法】（时间复杂度为O(n)）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*带尾结点的插入*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_L</span><span class="params">( Listlist &amp;L, <span class="type">int</span> n )</span></span><br><span class="line">&#123; <span class="comment">//正位序数输入 n 个元素的值，建立带表头结点的单链表L</span></span><br><span class="line">    <span class="comment">//建立头结点</span></span><br><span class="line">       L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">   L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//建立单链表（尾插法）</span></span><br><span class="line">    LNode r = L; <span class="comment">//尾指针指向头结点</span></span><br><span class="line">    <span class="comment">//申请空间，写入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           LNode *tmp = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode)); <span class="comment">/* 申请新结点 */</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp-&gt;Data); <span class="comment">//输入元素</span></span><br><span class="line">            tmp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//插入到尾结点后面</span></span><br><span class="line">        r-&gt;next = temp; </span><br><span class="line">        r = tmp;   <span class="comment">//r指向新的尾结点</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure><h6 id="7-删除（时间复杂度为O-n-）">(7)删除（时间复杂度为O(n)）</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f6b05c3.png" alt="在这里插入图片描述"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f75405a.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线性表L 中第 i 个数据元素删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElementType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="comment">//寻找第 i 个结点，并令p指向其前驱</span></span><br><span class="line">        p = p&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||j &lt; i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;<span class="comment">//删除位置不合理</span></span><br><span class="line">    </span><br><span class="line">    q = p-&gt;next;<span class="comment">//临时保存被删除结点的地址以备释放</span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">//改变被除结点的驱结点的指针域</span></span><br><span class="line">    e = q-&gt;data;<span class="comment">//保存被删除结点的数据域</span></span><br><span class="line">    <span class="built_in">free</span>(q);<span class="comment">//释放被删除结点的空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure><h4 id="3、二者时间复杂度和优缺点的比较">3、二者时间复杂度和优缺点的比较</h4><h5 id="1、两者复杂度比较">1、两者复杂度比较</h5><table><thead><tr><th></th><th>查找</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>顺序表</td><td>O(1)</td><td>O(1)</td><td>O(n)通过下标直接找到待操作元素，主要时间花在移动元素上。</td></tr><tr><td>链表</td><td>O(n)</td><td>O(n)主要时间用于找到插入元素的位置</td><td>O(n)主要时间用于找到待删除元素的位置</td></tr></tbody></table><h5 id="2、两者优缺点比较">2、两者优缺点比较</h5><table><thead><tr><th>数组</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td></td><td>随机访问性强；查找速度快</td><td>插入和删除效率低；可能浪费内存；内存空间要求高，必须有足够的连续内存空间；数组大小固定，不能动态拓展</td></tr></tbody></table><table><thead><tr><th>链表</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td></td><td>插入删除速度快；内存利用率高，不会浪费内存；大小没有固定，拓展很灵活。</td><td>不能随机查找，必须从第一个开始遍历，查找效率低</td></tr></tbody></table><blockquote><p>两者的区别在于<strong>顺序结构</strong>的要求一片连续的存储空间，而<strong>链式结构</strong>的不要求存储空间连续。</p></blockquote><h3 id="三、栈">三、栈</h3><h4 id="1、栈的顺序存储实现">1、栈的顺序存储实现</h4><blockquote><p>通常由一个<strong>一维数组</strong>和一个记录<strong>栈顶</strong>元素位置的变量组成。</p></blockquote><h5 id="1-顺序栈结构体的定义">(1)顺序栈结构体的定义</h5><blockquote><p><strong>当 Top = -1时，表示栈空；当Top = MaxSize -1 时，栈满！</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElementType * Data;  <span class="comment">/*存储元素的数组*/</span></span><br><span class="line">Position Top; <span class="comment">/*栈顶指针*/</span></span><br><span class="line"><span class="type">int</span> MaxSize; <span class="comment">/*堆栈最大容量*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Stack;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h5 id="2-顺序栈的创建">(2)顺序栈的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">(<span class="type">int</span> MaxSize)</span> <span class="comment">/*顺序栈的创建*/</span> </span><br><span class="line">&#123;</span><br><span class="line">Stack S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">S-&gt;Data = (ElementType *)<span class="built_in">malloc</span>(MaxSize * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">S-&gt;Top = <span class="number">-1</span>;       <span class="comment">/*&quot;-1&quot;表示空栈  &quot;MaxSize-1&quot;表示满栈*/</span> </span><br><span class="line">S-&gt;MaxSize = MaxSize;      <span class="comment">/*指定栈的最大容量*/</span> </span><br><span class="line"><span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h5 id="3-判满">(3)判满</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(Stack S)</span><span class="comment">/*判断栈是否满了*/</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>(S-&gt;Top == S-&gt;MaxSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="4-判空">(4)判空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span><span class="comment">/*判断堆栈是否为空*/</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>(S-&gt;Top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="5-入栈">(5)入栈</h5><blockquote><p>在执行堆栈 Push 操作时，先判断栈是否满；</p><ul><li>若不满，Top 加1，并将新元素放入 Data数组的Top位置上</li><li>若满，则返回错误标志</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(Stack S, ElementType X)</span><span class="comment">/*顺序栈的 入栈 操作*/</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">IsFull</span>(S)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆栈满！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">S-&gt;Data[++(S-&gt;Top)] = X;<span class="comment">/*若是栈不满，则Top加 1,并将新元素放入Data数组的Top位置中*/</span> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><h5 id="6-出栈">(6)出栈</h5><blockquote><p>执行Pop操作时，首先判别栈是否为空；</p><ul><li>若不为空，返回Data[Top]，同时将Top-1;</li><li>否则要返回错误标志</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span> <span class="comment">/*顺序栈 的 出栈 操作*/</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆栈空！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/*ERROR 是 ElementType 类型的特殊值，标志错误。必须是正常栈元素数据不可能取到的值 */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>(S-&gt;Data[(S-&gt;Top)--]);<span class="comment">/*若不空，返回Data[Top]，同时将Top减 1*/</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h4 id="2、栈的顺序存储实现">2、栈的顺序存储实现</h4><blockquote><p>链栈与单链表类似，但其操作受限制，插入和删除操作<strong>只能在链栈的栈顶进行。</strong></p></blockquote><h5 id="1-顺序栈结构体的定义-2">(1)顺序栈结构体的定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">PtrToSNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElementType Data;</span><br><span class="line">PtrToSNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSNode Stack;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h5 id="2-顺序栈的创建-2">(2)顺序栈的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">/*构建一个堆栈的头结点，返回该结点指针*/</span> </span><br><span class="line">Stack S;</span><br><span class="line">S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h5 id="3-判空-2">(3)判空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*判断堆栈 S 是否为空，若是返回 true，否则返回 false*/</span> </span><br><span class="line"><span class="keyword">return</span>(S-&gt;Next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="4-判满-注意：链栈，不必判断堆栈是否满">(4)判满 注意：链栈，不必判断堆栈是否满</h5><h5 id="5-入栈-2">(5)入栈</h5><blockquote><p>链栈，<strong>不必判断堆栈是否满</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(Stack S, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*将元素 X 压入堆栈 S */</span> </span><br><span class="line">PtrToSNode TmpCell;</span><br><span class="line">TmpCell = (PtrToSNode)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">TmpCell-&gt;Data = X;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">S-&gt;Next =TmpCell;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h5 id="6-出栈-2">(6)出栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span> ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;<span class="comment">/*删除并返回堆栈 S 的栈顶元素*/</span>  </span><br><span class="line">PtrToSNode FirstCell;</span><br><span class="line">ElementType TopElem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(IsEmpty(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆栈空！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">FirstCell = S-&gt;Next;</span><br><span class="line">TopElem = FirstCell-&gt;Data;</span><br><span class="line">S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line"><span class="built_in">free</span>(FirstCell);</span><br><span class="line"><span class="keyword">return</span> TopElem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*顺序栈 的 出栈 操作*/</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆栈空！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/*ERROR 是 ElementType 类型的特殊值，标志错误。必须是正常栈元素数据不可能取到的值 */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>(S-&gt;Data[(S-&gt;Top)--]);<span class="comment">/*若不空，返回Data[Top]，同时将Top减 1*/</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure><h4 id="3、栈的应用">3、栈的应用</h4><h3 id="四、队列">四、队列</h3><h4 id="1、队列的顺序存储实现">1、队列的顺序存储实现</h4><h5 id="1-循环队列的结构体定义">(1) 循环队列的结构体定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType; <span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line"><span class="type">int</span> front;    <span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="type">int</span> rear;<span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h5 id="2-生成空队列">(2)生成空队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化一个空队列Q */</span></span><br><span class="line">Status <span class="title function_">CreateQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    SqQueue *Q = (SqQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    Q-&gt;data = (ElementType*)<span class="built_in">malloc</span>(MaxSize * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h5 id="3-判空-3">(3)判空</h5><blockquote><p>队空的条件是：<strong>rear=front</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(Q-&gt;front == Q-&gt;rear);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="4-判满">(4)判满</h5><blockquote><p>队满的条件是：<strong>(rear+1)%数组的长度等于 front</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>((Q-&gt;rear+<span class="number">1</span>)% MaxSize == Q-&gt;front);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="5-入队">(5)入队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q,QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)<span class="comment">/* 队列满的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">Q-&gt;data[Q-&gt;rear]=e;<span class="comment">/* 将元素e赋值给队尾 */</span></span><br><span class="line">Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* rear指针向后移一位置， */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h5 id="6-出队">(6)出队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q,QElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)<span class="comment">/* 队列空的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e=Q-&gt;data[Q-&gt;front];<span class="comment">/* 将队头元素赋值给e */</span></span><br><span class="line">Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* front指针向后移一位置， */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h4 id="2、队列的链式存储实现">2、队列的链式存储实现</h4><blockquote><p>队列与堆栈一样，也可以采用链式存储结构，但队列的头（front）必须指向链表的头结点，队列的尾（rear）指向链表的尾结点。</p></blockquote><h5 id="1-队列的链式存储结构体定义">(1)队列的链式存储结构体定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType; <span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   QElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>/* 队列的链表结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   QueuePtr front,rear; <span class="comment">/* 队头、队尾指针 */</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h5 id="2-生成空队列-2">(2)生成空队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造一个空队列Q */</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123; </span><br><span class="line">Q-&gt;front=Q-&gt;rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!Q-&gt;front)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h5 id="3-判空-4">(3)判空</h5><blockquote><p>队空的条件是：<strong>rear=front</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h5 id="4-判满-链式队列，不必判断堆栈是否满">(4)判满 链式队列，不必判断堆栈是否满</h5><h5 id="5-入队-2">(5)入队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为Q的新的队尾元素 */</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q,QElemType e)</span></span><br><span class="line">&#123; </span><br><span class="line">QueuePtr s=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!s) <span class="comment">/* 存储分配失败 */</span></span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next=s;<span class="comment">/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */</span></span><br><span class="line">Q-&gt;rear=s;<span class="comment">/* 把当前的s设置为队尾结点，rear指向s，见图中② */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h5 id="6-出队-2">(6)出队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q,QElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p=Q-&gt;front-&gt;next;<span class="comment">/* 将欲删除的队头结点暂存给p，见图中① */</span></span><br><span class="line">*e=p-&gt;data;<span class="comment">/* 将欲删除的队头结点的值赋值给e */</span></span><br><span class="line">Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;rear==p)<span class="comment">/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */</span></span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h3 id="五、栈和队列操作的特点">五、栈和队列操作的特点</h3><table><thead><tr><th></th><th>相同点</th><th>不同点</th></tr></thead><tbody><tr><td>堆栈(FILO)</td><td>只允许在端点处插入和删除元素；</td><td>栈是先进后出或者后进先出；栈是只能在表的一端进行插入和删除操作的线性表</td></tr><tr><td>队列(FIFO)</td><td>只允许在端点处插入和删除元素；</td><td>队列是先进先出；队列是只能在表的一端进行插入，然后在另外一端进行删除操作的线性表</td></tr></tbody></table><h3 id="六、数组存储地址的计算">六、数组存储地址的计算</h3><table><thead><tr><th>数组类型</th><th>存储地址的计算（a是数组首地址，len是每个数组元素所占长度）</th></tr></thead><tbody><tr><td>一维数组</td><td>a[i]的存储地址：a+i*len</td></tr><tr><td>二维数组:a[m] [n]</td><td>按行存储：a+(i * n+j) * len；按列存储：a+(j * m+i) * len</td></tr></tbody></table><blockquote><p><strong>例子</strong>：数组存储地址的计算示例：<br>1）已知一维数组a中每个元素占用2个字节，求a[10]的存储地址？<br>答：a[10]的存储地址为：a+10*2=a+20<br>2）已知二维数组a[4][5]中, 每个元素占用2个字节，求元素a[3][2]按行为主序存储的存储地址和按列为主序存储的存储地址？<br>答： 按行存储：a+(35+2) *2 = a+34<br>按列存储：a+(24+3) *2 = a+22</p></blockquote><h2 id="———————树———————">———————树———————</h2><h3 id="一、二叉树">一、二叉树</h3><h4 id="1、定义">1、定义</h4><blockquote><p>二叉树是每个节点最多有两个子树的树结构。</p><p>它有五种基本形态:</p><ul><li>二叉树可以是空集;</li><li>根可以有空的左子树或右子树；</li><li>或者左、右子树皆为空。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f604bd3.png" alt="在这里插入图片描述"></p><h4 id="2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度">2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度</h4><h5 id="a-结点、叶子、树的度">a.结点、叶子、树的度</h5><blockquote><ul><li><strong>结点的度</strong>：结点拥有的子树的数目。</li><li><strong>叶子</strong>：度为零的结点。</li><li><strong>树的度</strong>：树中结点的最大的度</li></ul></blockquote><h5 id="b-孩子、双亲、兄弟、子孙、祖先">b.孩子、双亲、兄弟、子孙、祖先</h5><blockquote><ul><li><strong>双亲</strong>：若一个结点有子树，该结点称为子树根的&quot;双亲&quot;。</li><li><strong>孩子</strong>：子树的根是该结点的&quot;孩子&quot;。</li><li><strong>兄弟</strong>：有相同双亲的结点互为&quot;兄弟&quot;。</li><li><strong>子孙</strong>：一个结点的所有子树上的任何结点都是该结点的子孙。</li><li><strong>祖先</strong>：从根结点到某个结点的路径上的所有结点都是该结点的祖先。</li></ul></blockquote><h5 id="c-无序树、有序树、森林">c.无序树、有序树、森林</h5><blockquote><ul><li><strong>无序树</strong>：如果树中结点的各子树之间的次序是无次序的，<strong>可以交换位置</strong>。</li><li><strong>有序树</strong>：如果树中结点的各子树之间的次序是有次序的, <strong>不可以交换位置</strong>。</li><li><strong>森林</strong>：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</li></ul></blockquote><h5 id="d-层次、高度">d.层次、高度</h5><blockquote><p><strong>层次</strong>：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br><strong>树的深度和高度</strong>：二叉树中节点的最大层次称为二叉树的深度或高度。</p></blockquote><h4 id="2、性质">2、性质</h4><blockquote><p><strong>性质1</strong>：二叉树第 i 层上最多为 2^(i-1) (i≥1)个结点。</p><p><strong>性质2</strong>：深度为k的二叉树至多有2^k - 1个结点(k≥1)。</p><p><strong>性质3</strong>：具有n个结点的【完全二叉树】的高度k为(log&lt;2&gt;n) +1）（<strong>[log2n]表示不大于与其的整数</strong>）</p><p><strong>性质4</strong>：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。</p><p><strong>性质5</strong>：如果对一棵有 n个结点的完全二叉树（其深度为(log&lt;2&gt;n) +1）的结点按 【层序】编号（从第1层到第(log&lt;2&gt;n) +1） 层，每层从左到右），对任一结点 i （1≤ i ≤ n）有：</p><ul><li>如果 i = 1，则结点 i是二叉树的根，无双亲；如果 i ＞ 1，则其双亲是结点 [i/2];</li><li>如果2i ＞n，则结点 i 无左孩子（即结点 i 为叶子结点）；否则其左孩子是结点 2i；</li><li>如果 2i+1 ＞n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。</li></ul></blockquote><h4 id="3、满二叉树、完全二叉树和二叉排序树">3、满二叉树、完全二叉树和二叉排序树</h4><h5 id="a-满二叉树">a.满二叉树</h5><blockquote><p><strong>定义</strong>：高度为h，并且由2{h} –1个结点的二叉树，被称为满二叉树。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f6ddd79.png" alt="img"></p><h5 id="b-完全二叉树">b.完全二叉树</h5><blockquote><p><strong>定义</strong>：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。</p><p><strong>特点</strong>：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f80cde1.png" alt="img"></p><h5 id="c-二叉查找树">c.二叉查找树</h5><blockquote><p><strong>定义</strong>：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。左小右大，任意结点的左、右子树也是二叉查找树</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f8bd638.png" alt="img"></p><blockquote><p>在二叉查找树中：<br>(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>(03) 任意节点的左、右子树也分别为二叉查找树。<br>(04) 没有键值相等的节点（no duplicate nodes）。</p></blockquote><h3 id="二、静态查找">二、静态查找</h3><h4 id="1、顺序存储结构">1、顺序存储结构</h4><blockquote><p>指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标i－1的分量中。</p></blockquote><h4 id="2、顺序查找">2、顺序查找</h4><blockquote><p>从表的一端开始，逐个将记录的关键字和给定值比较，若找到一个记录的关键字与给定值相等，则查找成功；若整个表中记录均比较过，仍未找到关键字等于给定值的记录，则查找失败。</p></blockquote><p><strong>缺点</strong>：查找表的长度越长，查找效率越低。</p><p><strong>优点</strong>：简单、适应面广，对查找表结构没有要求，对顺序存储和链式存储都适用。</p><h4 id="3、二分查找（也称“折半查找”，是一棵“二叉排序树”）">3、二分查找（也称“折半查找”，是一棵“二叉排序树”）</h4><blockquote><p>设查找表元素存储在一维数组r[1,…,n]中，在表中的元素已经<strong>按关键字递增方式排序的</strong>情况下，</p><p>进行[折半查找]的方法是：首先将待查元素的关键字（key）值与表r中间位置上（下标为mid）记录的关键字关键字进行比较，</p><ul><li>若相等，则查找成功；</li><li>若key&gt;r[mid].key,则说明待查记录只可能在后半个子表r[mid+1,…,n]中；</li><li>若key&lt;r[mid].key，则说明待查记录只可能在前半个子表r[1,…,mid-1]中；</li></ul><p>这样逐步缩小范围，直到<strong>查找成功</strong>或<strong>子表为空时失败</strong>为止。</p></blockquote><p><strong>注意：每次缩小范围后，改变的下标是哪个</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递增的方式排序，则折半查找的算法为</span></span><br><span class="line"><span class="comment">//在数组r[low...high],在数组r中找值为key的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bsearch</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key == r[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; r[mid])</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//折半查找，递归算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bsearch_rec</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key == r[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; r[mid])</span><br><span class="line">            <span class="keyword">return</span> Bsearch_rec(r,low,mid<span class="number">-1</span>,key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Bsearch_rec(r,mid+<span class="number">1</span>,high,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f97218f.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VgJbPWx2-1641217649130)(myReviewPicture/带有11个结点的二分查找判定书.png)]"></p><p>折半查找的过程可以用一颗二叉树来描述，以当前查找区域间的中间位置序号作为根，左半个子表和右半个子表中的记录序号分别分别作为根的左子树和右子树上的结点，这样构造的二叉树称为折半查找判定树，从树上可以看出：</p><p>查找成功时，折半查找的过程恰好走了一条从根结点到被查找结点的路径，与关键字进行比较的次数即为被查找结点在树中的层数。因此，折半查找判定树在查找成功时进行比较的关键字个数最多不超过树的深度，而具有n个结点的判定树的深度为；所以折半查找在查找成功时和给定值进行比较的关键字个数最多为。</p><p><strong>优点</strong>：查找效率更高，但它要求查找表进行顺序存储并按关键字进行排序。<br><strong>缺点</strong>：对表进行插入或删除时，需要移动大量元素。<br><strong>适用</strong>：表不易变动，且又经常进行查找的情况</p><h4 id="4、二分查找判定树ASL计算">4、二分查找判定树ASL计算</h4><blockquote><p><strong>折半查找的过程看，可用二叉树来描述，二叉树中的每个结点对应有序表中的一个记录，结点中的值为该记录在表中的位置。通常称这个描述折半查找二叉树的过程称为折半查找判定树。</strong></p></blockquote><p><strong>例如：顺序存储的序列{1,2,3,4,5,6,7,8,9,10} 来构建二叉判定树，计算其ASL</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fa00a68.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-giB8nBKX-1641217649131)(myReviewPicture/二分查找判定书ASL成功-16411799392662.png)]"><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3faf1191.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rHJdmL7J-1641217649131)(myReviewPicture/二分查找判定书ASL不成功-16411799619963.png)]"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例如：长度为<span class="number">10</span>的折半查找判定树的具体生成过程：</span><br><span class="line">都遵循这个规律，左孩子结点&lt;根结点&lt;右孩子结点 【左小右大】</span><br><span class="line"></span><br><span class="line">    （<span class="number">1</span>）在长度为<span class="number">10</span>的有序表中进行折半查找，不论查找哪个记录，都必须和中间记录进行比较，而中间记录为</span><br><span class="line">（<span class="number">1</span>+<span class="number">10</span>）/<span class="number">2</span> =<span class="number">5</span>  (注意要取整)   即判定数的的根结点为<span class="number">5</span>，如图<span class="number">7</span><span class="number">-2</span>（a）所示。</span><br><span class="line"></span><br><span class="line">     （<span class="number">2</span>）考虑判定树的左子树，即将查找区域调整到左半区，此时的查找区间为[<span class="number">1</span>,<span class="number">4</span>],那么中间值为（<span class="number">1</span>+<span class="number">4</span>）/<span class="number">2</span> =<span class="number">2</span> (注意要取整) ，所以做孩子根结点为<span class="number">2</span>,如图<span class="number">7</span><span class="number">-2</span>（b）所示。</span><br><span class="line"></span><br><span class="line">     （<span class="number">3</span>）考虑判定树的右子树，即将查找区域调整到右半区，此时的查找区间为[<span class="number">6</span>,<span class="number">10</span>],那么中间值为（<span class="number">6</span>+<span class="number">10</span>）/<span class="number">2</span> =<span class="number">8</span> (注意要取整) ，所以做孩子根结点为<span class="number">8</span>,如图<span class="number">7</span><span class="number">-2</span>（c）所示。</span><br><span class="line"></span><br><span class="line">       (<span class="number">4</span>)重复以上步骤，依次去确定左右孩子、</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><blockquote><p>1.折半查找是一棵<strong>二叉排序树</strong>，每个根结点的值都大于左子树的所有结点的值，小于右子树所有结点的值。</p><p>2.折半查找判定数中的结点都是查找成功的情况，将每个结点的空指针指向一个实际上不存在的结点————<strong>外结点</strong>，所有外界点都是查找不成功的情况，如图7-2（e）所示。<strong>如果有序表的长度为n,则外结点一定有n+1个。</strong></p></blockquote><h5 id="（1）查找成功的ASL">（1）查找成功的ASL</h5><blockquote><p><strong>折半查找判定数中，某结点所在的层数就是即将要比较的次数，整个判定树代表的有序表的平均查找长度即为查找每个结点的比较次数之和除以有序表的 长度。</strong></p></blockquote><p><strong>ASL成功 = 每层结点所在高度×每层结点数 之和 除以 总结点数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 例如：长度为<span class="number">10</span>的有序表的平均查找长度为</span><br><span class="line"></span><br><span class="line">ASL=(<span class="number">1</span>×<span class="number">1</span>+<span class="number">2</span>×<span class="number">2</span>+<span class="number">3</span>×<span class="number">4</span>+<span class="number">4</span>×<span class="number">3</span>)/<span class="number">10</span>=<span class="number">29</span>/<span class="number">10</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h5 id="（2）查找不成功的ASL">（2）查找不成功的ASL</h5><blockquote><p><strong>折半查找判定数中，查找不成功的次数即为查找相应外结点(定义在上方）与内结点的比较次数。整个判定树代表的有序表的平均查找长度。查找失败时的有序表的平均查找长度即为查找每个外结点的比较次数之和除以外结点的个数。</strong></p></blockquote><p><strong>ASL失败 = （每层【补上的】结点所在高度-1）×每层【补上的】结点数 之和 除以 【补上的】总结点数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：查找失败时，长度为<span class="number">10</span>的有序表的平均查找长度为：</span><br><span class="line"></span><br><span class="line">ASL=(<span class="number">3</span>×<span class="number">5</span>+<span class="number">4</span>×<span class="number">6</span>)/<span class="number">11</span>=<span class="number">39</span>/<span class="number">11</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="三、动态查找">三、动态查找</h3><h4 id="1、二叉树链表结构描述如下：">1、二叉树链表结构描述如下：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree; <span class="comment">/* 二叉树类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">/*树结点定义 */</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 结点数据*/</span></span><br><span class="line">    BinTree Left; <span class="comment">/*指向左子树*/</span></span><br><span class="line">    BinTree Right;<span class="comment">/*指向右子树*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p><strong>二叉链表至少包含3个域：数据域 data、左指针域 lchild和右指针域 rchild</strong></p><p><strong>指针域</strong>： n个结点有2n个指针域。</p><p><strong>空指针域</strong>：n 个结点的二叉链表中含有 n+1 个空指针域。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fb17daa.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PqXCTOH8-1641217649132)(myReviewPicture/二叉树的链式存储结构.png)]"><br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fbb6b3f.png" alt="img"></p><h4 id="2、二叉搜索（排序、查找）树的构造过程">2、二叉搜索（排序、查找）树的构造过程</h4><h5 id="1-构造过程">(1)构造过程</h5><blockquote><p>构造二叉排序树的过程，就是从空二叉树开始，逐个向树中插入节点的过程。</p><p>设记录的关键码序列为：63,90,70,55,67,42,98,83,10,45,58</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fb8e575.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HIN82LwY-1641218126672)(myReviewPicture/二叉搜索树的排序.png)]"></p><h5 id="2-插入过程算法及其代码">(2)插入过程算法及其代码</h5><blockquote><p>设待插入节点关键码值为 X ：</p><p>（1）先在树中查找值为 X 的节点，若查找成功，说明节点已存在，无需插入；</p><p>（2）若查找失败，说明节点不存在，则将其插入到树中</p><p>因此，<strong>新插入节点一定是作为叶子节点插入的。</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Insert</span><span class="params">(Bintree BST, ElmentType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)</span><br><span class="line">    &#123;<span class="comment">/*若原来树为空，生成并返回一个结点的二叉搜索树*/</span></span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">/*开始查找插入元素的位置*/</span></span><br><span class="line">        <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Insert(BST-&gt;Left, X);<span class="comment">/*递归插入左子树*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Insert(BST-&gt;Right, X);<span class="comment">/*递归插入右子树*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><h5 id="2-删除过程算法及其代码">(2)删除过程算法及其代码</h5><blockquote><p>二叉搜索树的删除操作比其它操作更为复杂，要删除结点在<strong>树中的位置</strong>决定了操作所采用的<strong>策略</strong>。</p></blockquote><p>a.若要删除的结点是<strong>叶子结点</strong></p><p>可以直接删除，然后再修改其父结点的指针。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fc03da7.png" alt="在这里插入图片描述"></p><p>b.若要删除的结点<strong>只有一个孩子结点</strong>（该结点不一定是叶结点，可以是子树的根）</p><p>删除之前需要改变父结点的指针，指向要删除结点的孩子结点。<br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fc7c15f.png" alt="在这里插入图片描述"></p><p>c.若要删除的结点有左、右两棵子树，有两种选择：</p><p><strong>基本原则：保持二叉搜索树的有序性</strong></p><p>1、取其右子树中的最小元素；</p><p>2、取其左子树中的最大元素。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fc95c9e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Wzu1zptj-1641217649133)(myReviewPicture/具有两个子树的结点删除.png)]"></p><h5 id="3-查找过程算法及其代码">(3)查找过程算法及其代码</h5><blockquote><p>BST树的查找思想:</p><p>首先将<strong>给定的K值</strong>与二叉排序树的<strong>根节点</strong>的关键字进行比较：</p><ul><li>若<strong>相等</strong>，则<strong>查找成功</strong>；</li><li>若给定的K值<strong>小于</strong>BST树的根节点的关键字：继续在该节点的<strong>左子树上进行查找</strong>；</li><li>若给定的K值大于BST树的根节点的关键字：继续在该节点的<strong>右子树上进行查找</strong>。</li></ul></blockquote><h6 id="a-二叉搜索树的递归查找函数">a.二叉搜索树的递归查找函数</h6><blockquote><p>在二叉排序树上进行查找，则是从<strong>根结点</strong>出发走了一条从根到待查结点的路径；</p><p>若查找不成功，则是从根结点出发走了一条从跟到某一叶结点的路径。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">Find</span><span class="params">(BinTree BST,ElementType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* 查找失败 */</span></span><br><span class="line">    <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(BST-&gt;Right, X);<span class="comment">/* 在 右子树 中递归查找 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(BST-&gt;Left, X);<span class="comment">/* 在 左子树 中递归查找 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;<span class="comment">/* 在当前结点查找成功，返回当前结点的地址*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h6 id="b-迭代查找算法">b.迭代查找算法</h6><blockquote><p>由于非递归函数的执行效率高，一般采用非递归的迭代来实现查找。很容易将递归函数改为迭代函数</p><p>while循环 代替 Find递归调用即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">Find</span><span class="params">(BinTree BST,ElementType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Right;<span class="comment">/* 向 右子树 中移动，继续查找 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Left; <span class="comment">/* 向 右子树 中移动，继续查找 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data;*/</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">/* 在当前结点查找成功，跳出循环 */</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> BST;<span class="comment">/* 返回找到的结点地址，或是NULL */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><h5 id="4-查找最大值和最小值">(4)查找最大值和最小值</h5><blockquote><p>根据二叉搜索树的性质，<strong>最小元素</strong>一定是在树的<strong>最左分支的端点上</strong>。最左分支的端点：最左分支上无左孩子的结点。</p><p><strong>最大元素</strong>一定在<strong>最右分支的端结点上。</strong></p><ul><li>从根结点开始，当其不为空时，沿左分支或者右分支逐个判断各结点的指针，直到遇到空指针为止。</li><li>当左分支逐层推下来查找到的是最小元素。</li><li>反之，当右分支逐层推下来查找到的是最大元素。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fca30a0.png" alt="img"></p><h6 id="a-最小元素的递归函数">a.最小元素的递归函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">FindMin</span><span class="params">(BinTree BST)</span></span><br><span class="line">&#123; <span class="comment">/* 最小元素在最左端点 */</span></span><br><span class="line">    <span class="keyword">if</span>(!BST)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* 空的二叉搜素树，返回NULL */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">        <span class="keyword">return</span> BST;<span class="comment">/* 找到最左端点并返回 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin(BST-&gt;Left); <span class="comment">/*沿左分支递归查找 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h6 id="b-查找最大元素的迭代函数">b.查找最大元素的迭代函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">FindMax</span><span class="params">(BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right);</span><br><span class="line">    BST = BST-&gt;Right; <span class="comment">/*沿右分支一直向下，直到最右端点 */</span></span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h3 id="四、二叉树的遍历">四、二叉树的遍历</h3><blockquote><p>指按照某种次序访问二叉树的所有结点，并且每个结点仅访问一次，得到一个线性序列。</p></blockquote><h4 id="1、先序遍历">1、先序遍历</h4><blockquote><p>（1）访问根结点<br>（2）先序遍历左子树<br>（3）先序遍历右子树</p><p>-中序、后序遍历相似</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fcd7ec4.png" alt="img"></p><blockquote><p>先序遍历：A → B → D → C<br>中序遍历：B → D → A → C<br>后续遍历：D → B → C → A<br>层序遍历：A → B → C → D</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span>    <span class="comment">//链式二叉树先序遍历递归算法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf_s(<span class="string">&quot;%d &quot;</span>, T-&gt;data);    <span class="comment">//访问根结点</span></span><br><span class="line">PreOrderTraverse(T-&gt;lchild);    <span class="comment">//先序遍历左子树</span></span><br><span class="line">PreOrderTraverse(T-&gt;rchild);    <span class="comment">//先序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式二叉树中序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">InOrderTraverse(T-&gt;lchild);</span><br><span class="line">printf_s(<span class="string">&quot;%d &quot;</span>, T-&gt;data);</span><br><span class="line">InOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式二叉树后序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">printf_s(<span class="string">&quot;%d &quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure><h4 id="2、层序遍历-队列实现）">2、层序遍历(队列实现）</h4><blockquote><p>仔细看看层序遍历过程，其实就是从上到下，从左到右依次将每个数放入到队列中，然后按顺序依次打印就是想要的结果。</p></blockquote><blockquote><p>实现过程</p><ul><li>从队列中取出一个元素；</li><li>访问该元素所指结点；</li><li>若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。</li></ul><p>不断执行这三步操作，直到队列为空，再无元素可取，二叉树的程序遍历就完成了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelorDerTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    BinTree T;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!BT)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">/* 若是空树则直接返回 */</span></span><br><span class="line">    </span><br><span class="line">    Q = CreatQueue();<span class="comment">/* 创建空队列 */</span></span><br><span class="line">    AddQ(Q, BT);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        T = DeteleQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,T-&gt;Data); <span class="comment">/* 访问取出队列的结点 */</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left)</span><br><span class="line">            AddQ(Q, T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right)</span><br><span class="line">            AddQ(Q, T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure><h5 id="3、由遍历序列还原二叉树">3、由遍历序列还原二叉树</h5><blockquote><p>已知<strong>先</strong>序遍历和<strong>中</strong>序遍历，<strong>可以还原</strong>二叉树；<br>已知<strong>中</strong>序遍历和<strong>后</strong>序遍历，<strong>可以还原</strong>二叉树；<br>已知<strong>先序遍历和后序遍历，不可以</strong>还原二叉树.</p></blockquote><p>a.已知先序遍历和中序遍历还原二叉树</p><blockquote><p>算法思路：<br>1、根据先序遍历结果确定根节点。先序遍历的第一个节点为根节点。<br>2、 在中序遍历结果中找到根节点，根节点左侧的部分为左子树节点，根节点右侧的部分为右子树节点。<br>3、 将中序遍历的结果按根节点分为两部分，迭代的执行第一步和第二步，直到还原整个二叉树。</p></blockquote><p>例如：已知先序遍历的结果为：ABDHIEJKCFLMGNO,中序遍历的结果为：HDIBJEKALFMCNGO</p><p>则二叉树为以下结构：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fd8636e.png" alt="img"></p><p>其后序遍历结果为：HIDJKEBLMFNOGCA</p><h6 id="b-已知后序遍历和中序遍历还原二叉树">b.已知后序遍历和中序遍历还原二叉树</h6><blockquote><p><strong>算法思路</strong>：<br>1、根据后序遍历结果确定根节点。<br>后序遍历的最后一个节点为根节点。<br>2、在中序遍历结果中找到根节点，根节点左侧的部分为左子树节点，根节点右侧的部分为右子树节点。<br>3、将中序遍历的结果按根节点分为两部分，迭代的执行第一步和第二步，直到还原整个二叉树。</p></blockquote><p>例如：已知后序遍历的结果为：HIDJKEBLMFNOGCA,中序遍历的结果为：HDIBJEKALFMCNGO</p><p>则二叉树为以下结构：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fd86d86.png" alt="img"></p><p>其先序遍历结果为：ABDHIEJKCFLMGNO</p><h3 id="五、递归遍历算法的应用">五、递归遍历算法的应用</h3><h5 id="1、求二叉树的深度">1、求二叉树的深度</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeDeep</span><span class="params">(BiTree T)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> deep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> leftDeep = TreeDeep(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> rightDeep = TreeDeep(T-&gt;rchild);</span><br><span class="line">        deep = leftDeep &gt;= rightDeep ? leftDeep + <span class="number">1</span> : rightDeep + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h5 id="2、求二叉树的叶子树">2、求二叉树的叶子树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求叶子树</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LeafCount</span><span class="params">(BinTree T,<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!T-&gt;Left &amp;&amp; !T-&gt;Right)</span><br><span class="line">        &#123;</span><br><span class="line">            nm++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeDeep(T-&gt;lchild, num);</span><br><span class="line">        TreeDeep(T-&gt;rchild, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h5 id="3、交互（换）左、右子树">3、交互（换）左、右子树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(BiTree *&amp;right,BiTree *&amp;left)</span></span><br><span class="line">&#123;</span><br><span class="line">BiTree *temp=right;</span><br><span class="line">right=left;</span><br><span class="line">left=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SwapSubtrees</span><span class="params">(BiTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">SwapSubtrees(T-&gt;rchild);</span><br><span class="line">SwapSubtrees(T-&gt;lchild);</span><br><span class="line">Swap(T-&gt;rchild,T-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><h3 id="六、静态查找和动态查找的根本区别">六、静态查找和动态查找的根本区别</h3><ul><li>上述基于二叉排序树的动态查找，它的基本原理和基于线性表的静态二分查找很相似，都是利用有序性不断缩小查找空间。</li><li>而之所以有静态和动态之分，主要是为了适应不同的应用需求。</li></ul><table><thead><tr><th></th><th>适合用于</th></tr></thead><tbody><tr><td>静态查找</td><td>数据一旦建立好，不需要或者很少进行 删除 和 插入 操作</td></tr><tr><td>动态查找</td><td>频繁的数据变化，插入 和 删除 是基本操作</td></tr></tbody></table><h3 id="七、树-森林与二叉树的转换">七、树/森林与二叉树的转换</h3><h4 id="1、树、森林与二叉树的转换">1、树、森林与二叉树的转换</h4><p>由于二叉树是有序的，为了避免混淆，对于无序树，我们约定树中的每个结点的孩子结点按从左到右的顺序进行编号。</p><blockquote><p>将树转换成二叉树的步骤是：<br>（1）加线。就是在<strong>所有兄弟结点</strong>之间加一条连线；<br>（2）抹线。就是对<strong>树中的每个结点</strong>，只<strong>保留</strong>他与<strong>第一个孩子结点</strong>之间的连线，<strong>删除</strong>它与<strong>其它孩子</strong>结点之间的连线；<br>（3）旋转。就是<strong>以树的根结点为轴心</strong>，将整棵树顺时针旋转一定角度，使之结构层次分明。<br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe6e3a9.png" alt="img"></p></blockquote><h4 id="2、森林转换为二叉树">2、森林转换为二叉树</h4><p>森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。</p><blockquote><p>将森林转换为二叉树的步骤是：<br>（1）<strong>先把每棵树转换为二叉树</strong>；<br>（2）第一棵二叉树<strong>不动</strong>，从第二棵二叉树<strong>开始</strong>，依次把<strong>后一棵</strong>二叉树的根结点作为<strong>前一棵</strong>二叉树的<strong>根结点的右孩子结点</strong>，<strong>用线连接起来</strong>。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe7ed50.png" alt="img"></p><h4 id="3、二叉树转换为树">3、二叉树转换为树</h4><blockquote><p><strong>二叉树转换为树</strong>是<strong>树转换为二叉树</strong>的<strong>逆过程</strong>，其步骤是：<br>（1）若<strong>某结点</strong>的<strong>左孩子结点存在</strong>，将<strong>左孩子结点的右孩子结点、右孩子结点的右孩子结点</strong>……都作为<strong>该结点</strong>的孩子结点，将该结点与这些<strong>右孩子结点用线连接</strong>起来；<br>（2）<strong>删除原二叉树</strong>中所有结点与其右孩子结点的连线；<br>（3）整理（1）和（2）两步得到的树，使之结构层次分明。<br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe9c5ca.png" alt="img"></p></blockquote><h4 id="4、二叉树转换为森林">4、二叉树转换为森林</h4><blockquote><p>二叉树转换为森林比较简单，其步骤如下：<br>（1）先把每个结点与右孩子结点的连线删除，得到分离的二叉树；<br>（2）把分离后的每棵二叉树转换为树；<br>（3）整理第（2）步得到的树，使之规范，这样得到森林。</p></blockquote><h4 id="5、转换以后的特点：">5、转换以后的特点：</h4><p>(1、 根据树与二叉树的转换关系以及二叉树的遍历定义可以推知：</p><ul><li>树的先序遍历与其转换的相应的二叉树的先序遍历的结果序列相同；</li><li>树的后序遍历与其转换的二叉树的中序遍历的结果序列相同；</li><li>树的层序遍历与其转换的二叉树的后序遍历的结果序列相同。</li></ul><p>（2、 由森林与二叉树的转换关系以及森林与二叉树的遍历定义可知：</p><p>森林的先序遍历和中序遍历与所转换得到的二叉树的先序遍历和中序遍历的结果序列相同。</p><h3 id="八、线索二叉树">八、线索二叉树</h3><blockquote><p>传统的二叉链表仅能体现出一种父子关系，不能直接得到结点在遍历中的前驱或后继。引入【线索二叉树】正是为了<strong>加快查找结点前驱和后继的速度。</strong><br><strong>（1、定义</strong>：</p><ul><li><strong>前驱与后继</strong>：在二叉树的<code>先序、中序或后序遍历序列</code>中的两个<code>相邻的结点</code>；</li><li><strong>线索</strong>：指向前驱或后继的<code>结点的指针</code>；</li><li><strong>线索二叉树</strong>：<code>加上线索</code>的<code>二叉链表</code>的<code>二叉树</code>；</li><li><strong>线索化</strong>：对二叉树按<code>某个遍历次序</code>使其<code>变为线索二叉树</code>的过程。</li></ul><p><strong>（2、规定</strong>：<strong>【口诀：左前右后，0孩1前后】</strong></p><ul><li>若<code>无左子树</code>，令<code>lchild</code>指向其<code>前驱</code>结点；</li><li>若<code>无右子树</code>，令<code>rchild</code>执行指向其<code>后继</code>结点</li><li>增加<code>两个标志域标</code>识是指<code>左/右孩子</code>还是指向<code>前驱/后继</code>。</li></ul></blockquote><h4 id="1、存储结构">1、存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line"><span class="type">int</span> ltag, rtag;<span class="comment">// 左右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fea5ad1.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fXyUjz8c-1641217649133)(myReviewPicture/线索二叉树的结构.png)]"></p><h4 id="2、如何判断是孩子还是线索">2、如何判断是孩子还是线索</h4><p><strong>其标志位含义如下：</strong> <strong>【口诀：左前右后，0孩1前后】</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe9e318.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gl66MqHn-1641217649134)(myReviewPicture/线索二叉树的标识符含义.png)]"></p><ul><li>这种加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。</li><li>根据线索性质的不同， 线索二叉树可分为<strong>前序线索二叉树、 中序线索二叉树和后序线索二叉树</strong>三种。</li></ul><h4 id="3、三种遍历">3、三种遍历</h4><blockquote><p>因为线索化后， 各个结点指向有变化， 因此原来的遍历方式不能使用， 需要使用新的方式遍历线索化二叉树。</p><p>中序线索二叉树的结点中<strong>隐含</strong>了线索二叉树的<strong>前驱和后继信息</strong>。</p><p>在对其遍历时，需要找到第一个具有前驱结点的左结点，然后依次找结点的后继。</p><p>在中序线索二叉树中找结点后继的规律是:</p><ul><li>若其<strong>右标志为1</strong>，则<strong>右链为线索</strong>，指示其<strong>后继</strong>;</li><li>否则遍历<strong>右子树中第一个访问</strong>的结点（右子树中最左下的结点）为其后继。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiThrTree T)</span>&#123; <span class="comment">// 中序输出</span></span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; T-&gt;data;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h3 id="九、哈夫曼树">九、哈夫曼树</h3><h4 id="1、带权路径长度WPL">1、带权路径长度WPL</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fee2941.png" alt="img"></p><h4 id="2、哈夫曼树的构造（算法）">2、哈夫曼树的构造（算法）</h4><blockquote><p>构造 Huffman 树的基本思想：权值大的结点用短路径，权值小的结点用长路径。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3ffe9b85.png" alt="img"></p><blockquote><p>构造过程</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3ffe9963.png" alt="在这里插入图片描述"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4000e0f6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S9xCYfbA-1641217649135)(myReviewPicture/huffmantree2.png)]"></p><h4 id="3、哈夫曼树的性质">3、哈夫曼树的性质</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b400ae7d3.png" alt="img"></p><h4 id="4、哈夫曼编码">4、哈夫曼编码</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b400d4c84.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b400f253d.png" alt="img"></p><h2 id="———散列查找———">———散列查找———</h2><h3 id="一、散列查找">一、散列查找</h3><h4 id="1、基本概念-2">1、基本概念</h4><ul><li><strong>散列函数</strong></li></ul><p>在进行查找时，在记录的存储位置与它的关键字之间建立一个确定的对应关系h,以线性表中每个元素的关键字K为自变量，通过函数h(K)计算出该元素的存储位置，我们将h函数称为散列函数或哈希函数。h(K)的值称为散列地址或哈希地址。</p><ul><li><strong>冲突</strong></li></ul><p>在实际应用中，通常可能出现一个待插入元素的散列地址单元已被占用情况，使得该元素无法直接存入此单元，这种情况称为冲突。</p><ul><li><p><strong>同义词</strong></p><p>具有不同关键字而具有相同散列地址的元素称为同义词，即key1≠key2，但h(key1)=h(key2)。由同义词引起的冲突称作同义词冲突。</p></li><li><p><strong>装填因子(α)</strong></p><p>指散列表中已存入的元素数n与散列表空间大小m的比值,即：α=n/m。当α越小时，冲突可能性就越小，但同时，存储空间利用率就越低。</p></li></ul><p>散列表：根据设定的哈希函数及处理冲突的方法将一组关键字映象到一个有限的连续的地址集上，即把记录存放在表中映象的位置上，这种表便称为散列表(哈希表)。</p><ul><li>一个散列表的好坏与三个因素有关：1.装填因子 2、所采用的散列函数 3、解决冲突的方法</li></ul><blockquote><p>假定一个线性表为A=(18,75,60,43,54,90,46)，选取散列函数为：h(K)=K%m 取m=13<br>则得每个元素散列地址：<br>h(18)=18 % 13=5<br>h(75)=75 % 13=10<br>h(60)=60 % 13=8<br>h(43)=43 % 13=4<br>h(54)=54 % 13=2<br>h(90)=90 % 13=12<br>h(46)=46 % 13=7<br>根据散列地址，实现元素的存储映象H[m]：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th></th></tr></thead><tbody><tr><td>H</td><td></td><td></td><td>54</td><td></td><td>43</td><td>18</td><td></td><td>46</td><td>60</td><td></td><td>75</td><td></td><td>90</td></tr></tbody></table></blockquote><blockquote><p>例：如向下表中再插入元素70时，70%13=5，则出现了冲突</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td>H</td><td></td><td></td><td>54</td><td></td><td>43</td><td>18</td><td></td><td>46</td><td>60</td><td></td><td>75</td><td></td><td>90</td></tr></tbody></table></blockquote><h4 id="2、散列函数">2、散列函数</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OtlYI1uv-1641217649135)(myReviewPicture/散列函数.png)]</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 构造散列函数的目标是使散列地址尽可能均匀分布在散列空间上，同时使计算尽可能简单，以节省计算时间。</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h5 id="（1、关键词为数字时：">（1、关键词为数字时：</h5><h6 id="a-直接定址法">a.直接定址法</h6><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a426e7c26d23a12abae842ecc2e1ace.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VlxRhB6x-1641217649136)(myReviewPicture/直接定址法.png)]"></p><h6 id="b-除留余数法-常用">b.除留余数法(常用)</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b401eef26.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fZm4ezqe-1641217649136)(myReviewPicture/除留余数法.png)]"></p><h6 id="c-数字分析法">c.数字分析法</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址，如电话号码、身份证号码某几位会比较随机；</span><br><span class="line">1</span><br></pre></td></tr></table></figure><blockquote><p>**例：**有一组关键字如下：</p><p>92326875</p><p>92739628</p><p>92343634</p><p>92706816</p><p>92774638</p><p>92381262</p><p>92394220</p><p>通过分析：每个关键字从左到右第1、2、3位和第6位取值较集中，不宜作散列地址，其余的第4、5、7、8位取值分散，可以选择，若取最后两位作散列地址，得：<strong>(2,75,28,34,16,38,62,20)</strong></p></blockquote><h6 id="d-平方取中法">d.平方取中法</h6><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">key</span>取平方再取中间几位</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="（2、关键词为字符时：">（2、关键词为字符时：</h5><h6 id="a、ASCII码加和法">a、ASCII码加和法</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">h</span><span class="params">(key)</span></span>=(求和key<span class="selector-attr">[i]</span>)mod TableSize</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h6 id="b、前3个字符移位法">b、前3个字符移位法</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">h</span>(key)=(key[<span class="number">0</span>]*<span class="number">27</span>*<span class="number">27</span>+key[<span class="number">1</span>]*<span class="number">27</span>+key[<span class="number">2</span>])mod TableSize</span><br><span class="line"><span class="attribute">1</span></span><br></pre></td></tr></table></figure><h3 id="二、处理冲突的方法">二、处理冲突的方法</h3><h4 id="1、开放定址法">1、开放定址法</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4022f739.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-w3vCRkqI-1641217649137)(assets/开放定址法2.png)]"></p><h6 id="a-线性探测法">a.线性探测法</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b402672fe.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CKgRc9iU-1641217649138)(myReviewPicture/线性探测法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b402c6fc3.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dRJEytI9-1641217649139)(myReviewPicture/开放定址法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b402edf95.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-s9TU3kVj-1641217649139)(myReviewPicture/ASL.png)]"></p><p><strong>注意</strong>：查找某个值时，用散列函数计算完后，如果那个结果位置上的数字与关键词不一样时，并不能断定关键词不存在，还应该按照冲突解决策略继续找，直到找到空位置了还没找到，才能断定该关键词不存在。</p><h6 id="b、平方探测（二次探测）">b、平方探测（二次探测）</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b40381e62.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tK3J9VUv-1641217649140)(myReviewPicture/平方探测法5.png)]"></p><blockquote><p>举例：h(key)=key mod 11;</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4039a89b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jyTvTfbw-1641217649140)(myReviewPicture/平方探测法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b403ddb6c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XTqZBJVG-1641217649140)(myReviewPicture/平方探测法2.png)]"></p><p>**注意：**取素数是为了减少公因子（减少冲突）</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4049a4b5.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RL4wdkRn-1641217649142)(myReviewPicture/散列表的装填因子.png)]"></p><h6 id="c-在散列法">c.在散列法</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4047fb3b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sXqpjUkM-1641217649142)(myReviewPicture/再散列法.png)]"></p><h4 id="2、分离链接法">2、分离链接法</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b404ef82b.png" alt="在这里插入图片描述"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b405908a6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QpGllGXr-1641217649142)(myReviewPicture/链地址法.png)]"></p><h2 id="———————————————图————————————————">———————————————图————————————————</h2><h3 id="一、图的基本概念">一、图的基本概念</h3><blockquote><p><strong>集合只有同属于一个集合；线性结构存在一对一的关系；树形结构存在一对多的关系；图状结构存在多对多的关系</strong>。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4059a033.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50ea5e8c.png" alt="img"></p><h4 id="1、简单图">1、简单图</h4><blockquote><p>简单图满足以下两条内容：</p><p><strong>1）不存在重复边</strong></p><p><strong>2）不存在顶点到自身的边</strong></p></blockquote><h4 id="2、完全图">2、完全图</h4><blockquote><p>任意两顶点之间都存在边</p></blockquote><h4 id="3、连通分量">3、连通分量</h4><blockquote><p>在无向图中，两顶点有路径存在，就称为连通的。若图中任意两顶点都连通，同此图为连通图。无向图中的极大连通子图称为连通分量。</p></blockquote><h4 id="4、强连通分量">4、强连通分量</h4><blockquote><p>在有向图中，两顶点两个方向都有路径，两顶点称为<strong>强连通</strong>。</p><p>若任一顶点都是强连通的，称为强连通图。有向图中极大强连通子图为有向图的强连通分量。</p></blockquote><h4 id="5-顶点的度、入度和出度">5.顶点的度、入度和出度</h4><blockquote><p><strong>顶点的度</strong>为以该顶点为一个端点的<strong>边的数目</strong>。</p><p>对于<strong>无向图</strong>，顶点的边数为度，<strong>度数之和是顶点边数的 2 倍</strong>。</p><p>对于<strong>有向图</strong>，入度是以顶点为终点，出度相反。有向图的<strong>全部顶点入度之和等于出度之和且等于边数</strong>。<strong>顶点的度等于入度与出度之和</strong></p></blockquote><p><strong>注意</strong>：入度与出度是针对有向图来说的</p><h3 id="二、图的存储">二、图的存储</h3><h4 id="1、数组（邻接矩阵）表示法">1、数组（邻接矩阵）表示法</h4><ul><li><p>建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间关系）。</p></li><li><p>设图A=（V，E）有n个顶点，则</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50e89c5e.png" alt="åœ¨è¿™é‡Œæ’å ¥å›¾ç‰‡æè¿°"></p></li><li><p>图的邻接矩阵是一个二位数组A.arcs[n] [n]，定义为：</p></li></ul><p>åœ¨è¿™é‡Œæ’å<br>¥å›¾ç‰‡æè¿°</p><h5 id="a-无向图的邻接矩阵表示法">a.无向图的邻接矩阵表示法</h5><blockquote><p>分析1：<strong>无向图</strong>的邻接矩阵是<strong>对称</strong>的；<br>分析2：顶点i的度=第i行（列）中1的个数；<br><strong>特别：完全图的邻接矩阵中，对角元素为0，其余1。</strong></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50e9cb15.png" alt="åœ¨è¿™é‡Œæ’å ¥å›¾ç‰‡æè¿°"></p><h5 id="b-有向图的邻接矩阵表示法">b.有向图的邻接矩阵表示法</h5><blockquote><p>注：在有向图的邻接矩阵中，<br>第 i <strong>行</strong>含义：以结点vi为尾的弧（即<strong>出度边</strong>）<br>第 i <strong>列</strong>含义：以结点vi为头的弧（即<strong>入度边</strong>）<br>分析1：有向图的邻接矩阵<strong>可能是不对称</strong>的；<br>分析2：<strong>顶点的出度 = 第 i 行元素之和</strong><br><strong>顶点的入度 = 第 i 列元素之和</strong><br><strong>顶点的度 = 第 i 行元素之和 + 第 i 列元素之和</strong></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50ed60f0.png" alt="在这里插入图片描述"></p><h5 id="c-有权图（网）的邻接矩阵表示法">c.有权图（网）的邻接矩阵表示法</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50eb310f.png" alt="在这里插入图片描述"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50f02fc2.png" alt="在这里插入图片描述"></p><h4 id="2-邻接表（顺序存储与链式存储结合）">2.邻接表（顺序存储与链式存储结合）</h4><p>![<img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50f9e1aa.png" alt="åœ¨è¿™é‡Œæ’å"><br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50fd32c4.png" alt="在这里插入图片描述"></p><h5 id="a-无向图的邻接表">a.无向图的邻接表</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5105fedc.png" alt="img"></p><h5 id="b-有向图的邻接表与逆邻接表">b.有向图的邻接表与逆邻接表</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5108eb3f.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-trpuTIAt-1641217649145)(myReviewPicture/有向图的邻接表.jpeg)]"></p><h5 id="c-带权值的网图">c.带权值的网图</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b510a808e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ah5zBlPv-1641217649146)(myReviewPicture/网图的邻接表.png)]"></p><h3 id="三、图的遍历">三、图的遍历</h3><h5 id="1、深度优先遍历算法">1、深度优先遍历算法</h5><blockquote><p>深度优先搜索类似于树的先序遍历。</p><p>其基本思想是：</p><ul><li>首先访问起始顶点v，然后由v出发，访问与<strong>v 邻接且未被访问</strong>的任一顶点w1，再访问<strong>与w1 邻接且未被</strong>访问的任一顶点W2……重复上述操作。</li><li>当<strong>不能再继续向下访问</strong>时，依次<strong>退回到最近被访问的顶点</strong>，若它还有邻接顶点<strong>未被访问过</strong>，则从该点开始<strong>继续上述搜索过程</strong>，直至图中所有顶点均被访问过为止。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5107057c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tAlBFL32-1641217649146)(myReviewPicture/深度优先遍历.png)]"></p><blockquote><p>从顶点a 出发，进行深度优先遍历，可以得到的一种顶点序列为：a e d f c b</p></blockquote><h5 id="2、广度优先遍历算法">2、广度优先遍历算法</h5><blockquote><p>广度优先搜索类似于二叉树的层序遍历算法。</p><p>其基本思想是：</p><ul><li>首先访问起始顶点v，接着由ν出发，依次访问v 的各个<strong>未访问过的邻接顶点</strong>W1，W2，…，Wi，然后依次访问W1，W2，…，Wi的<strong>所有未被访问过的邻接顶点</strong>；</li><li>再从<strong>这些访问过的顶点</strong>出发，访问它们<strong>所有未被访问过的邻接顶点</strong>，直至图中的<strong>所有顶点都被访问过为止</strong>。</li><li>若此时图中<strong>尚有顶点未被访问</strong>，则另选图中的<strong>一个未被访问的顶点作为始点</strong>，重复上述过程，直至图中<strong>所有顶点都被访问到为止</strong>。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b510a84bf.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4dDjFgZo-1641217649147)(myReviewPicture/广度优先遍历.png)]"></p><blockquote><p>从顶点1 出发，按照广度优先规则遍历，可以得到的一种顶点序列是： 1234576</p></blockquote><h3 id="二、最小生成树">二、最小生成树</h3><h5 id="1、性质">1、性质</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51135fb1.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hfg0lPhL-1641217649147)(myReviewPicture/最小生成树的性质.png)]"></p><h5 id="2、Prim算法">2、Prim算法</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5117aae2.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uhZfCQrh-1641217649147)(myReviewPicture/Prim算法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b511db373.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hrqqoFVo-1641217649148)(myReviewPicture/最小生成树Prim算法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b511dbe59.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-te5iPtxy-1641217649149)(myReviewPicture/最小生成树Prim算法2.png)]"></p><h5 id="3、Kruskal算法">3、Kruskal算法</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51210bca.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-l7q0KxrC-1641217649149)(myReviewPicture/Kruskal算法.png)]"></p><h4 id="三、拓扑排序">三、拓扑排序</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51278094.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UnFfZk1Y-1641217649149)(myReviewPicture/拓扑排序.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b512b3ab5.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zr1pgvkl-1641217649150)(myReviewPicture/拓扑排序例题.png)]"></p><h5 id="四、最短路径">四、最短路径</h5><h6 id="迪杰斯特拉算法">迪杰斯特拉算法</h6><blockquote><p>通过迪杰斯特拉算法计算图G中的最短路径时，需要指定起点s。</p><p>此外，需要引进两个集合S和U。</p><ul><li>S的作用：记录<strong>已求出最短路径的顶点</strong>（以及<strong>相应的最短路径长度</strong>），</li><li>U的作用：记录<strong>还未求出最短路径的顶点</strong>（以及<strong>该顶点到起点s的距离</strong>）。</li><li>初始时，S中只有起点s；</li><li>U中是除s之外的顶点，并且U中顶点的路径是“起点s到该顶点的路径”。</li><li>然后，从U中找到路径最短的顶点，并将其加入到S中；<ul><li>接着，更新U中的顶点和顶点对应的路径。</li><li>然后，再从U中找到路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。</li><li>重复上述操作，直到遍历完所有顶点。</li></ul></li></ul></blockquote><h6 id="具体过程">具体过程</h6><p><strong>1、初始化，所有顶点的距离初始化为无穷大（INFINITY)</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51308072.png" alt="img"></p><p><strong>2、选定点A，更新（A-A距离设为0)</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b514afd17.png" alt="img"></p><p><strong>3、S集合为{A,B}，考察B的所有邻接点</strong></p><blockquote><p><strong>为什么选定B加入集合S？</strong><br><strong>因为不可能还有其他路径比2还短，我不管经过C到B还是D到B都不可能是路径小于2，所以我们得到了A-&gt;B的最短路径</strong></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b514ca7e1.png" alt="img"></p><blockquote><p>做完这一步，下一步加入集合S的是D<br>因为目前A-&gt;D的路径长度最短，为3（我已经知道了A直接到D和A经过B到D的路径长度）<br>如果A-&gt;B-&gt;X-&gt;D小于min{A-&gt;D,A-&gt;B-&gt;D},那么A-&gt;B-&gt;X小于min{A-&gt;D,A-&gt;B-&gt;D}，那么加入集合的应该是X，这是矛盾的（接下来的操作都是一样的道理</p></blockquote><p><strong>4、S集合为{A,B,D}，在U中没有D的邻接点，不操作</strong></p><p><strong>5、S集合为{A,B,D,C}，在U中没有C的邻接点，不操作</strong></p><p><strong>6、S集合为{A,B,D,C,F}，更新</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5151bee3.png" alt="img"></p><p><strong>7、S集合为{A,B,D,C,F,E}，在U中没有E的邻接点，不操作</strong></p><p><strong>8、S集合为{A,B,D,C,F,E,G}，在U中没有G的邻接点，不操作</strong></p><p><strong>9、最终结果如上图</strong>。</p><h2 id="———排序———">———排序———</h2><h3 id="一、排序的类别">一、排序的类别</h3><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b515628d0.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBiNgFub-1641217649151)(myReviewPicture/排序.png)]"></p><h3 id="1、插入排序">1、插入排序</h3><h4 id="基本思想：">基本思想：</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5159f561.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-W5Hwkv7f-1641217649151)(assets/插入排序基本思想.png)]"></p><h5 id="【1】直接插入排序">【1】直接插入排序</h5><h6 id="（1、基本思想：">（1、基本思想：</h6><blockquote><p>1）、将待排序的一组序列（有N个数）分为<strong>已排好的</strong>和<strong>未排好的</strong> 2个部分；</p><p>2）、初始状态时，已排序序列<strong>仅包含第1 个元素</strong>，未排序序列中的元素为除去<strong>第1 个元素意外的N-1 个元素</strong>；</p><p>3）、此后，将未排序序列中的元素逐一插入到已排序的序列中；</p><p>4）、如此往复，经过<strong>N-1 次</strong>插入后，未排序序列中元素个数为0 ，则排序完成。</p></blockquote><h6 id="（2、执行过程">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b514dae70.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7EB0PiaP-1641217649152)(myReviewPicture/直接插入排序例题1.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b516309b7.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-59uBl571-1641217649152)(myReviewPicture/直接插入排序2.png)]"></p><h6 id="（3、时空效率及稳定性">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5165dced.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SxUpnfwg-1641217649152)(myReviewPicture/直接插入时空效率.png)]"></p><h5 id="【2】希尔排序">【2】希尔排序</h5><h6 id="（1、基本思想：-2">（1、基本思想：</h6><blockquote><p>1）、将带排序序列的一组元素按<strong>一定间隔</strong>分为<strong>若干序列</strong>分别进行<strong>插入排序</strong>；</p><p>2）、开始时设置的“<strong>间隔</strong>”较大，在每轮排序中，将**”间隔“逐步缩小**</p><p>3）、直到“间隔”为 1，也就到了最后一步，做<strong>简单插入排序</strong>。</p></blockquote><h6 id="（2、执行过程-2">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51667024.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-auVhyLOw-1641217649153)(myReviewPicture/希尔排序2.png)]"></p><h6 id="（3、时空效率及稳定性-2">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5168aecd.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ux0GsKAK-1641217649153)(myReviewPicture/希尔排序3.png)]"></p><h3 id="2、交换排序">2、交换排序</h3><h4 id="基本思想：-2">基本思想：</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5172f337.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZgGwNJn5-1641217649154)(myReviewPicture/交换排序基本思想.png)]"></p><h5 id="【1】冒泡排序">【1】冒泡排序</h5><h6 id="（1、基本思想：-3">（1、基本思想：</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5172fa98.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zJfYxzHa-1641217649155)(myReviewPicture/冒泡排序基本思想.png)]"></p><h6 id="（2、执行过程-3">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5177290b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-95qkCnr1-1641217649155)(myReviewPicture/冒泡排序执行过程.png)]"></p><h6 id="（3、时空效率及稳定性-3">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51775f1e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xRUZHEtW-1641217649155)(myReviewPicture/冒泡排序时空效率.png)]"></p><h5 id="【2】快速排序">【2】快速排序</h5><h6 id="（1、基本思想：-4">（1、基本思想：</h6><blockquote><p>1)、将未排序元素根据一个作为<strong>基准</strong>的“主元（pivot）分为<strong>两个子序列</strong>；</p><p>2）、其中一个子序列的记录<strong>均大于</strong>“主元”，另一个序列则<strong>均小于</strong>“主元；</p><p>3）、<strong>递归</strong>地对两个子序列用<strong>类似的方法</strong>进行排序。</p></blockquote><h6 id="（2、执行过程-4">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51776a58.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8y2pVgAJ-1641217649155)(myReviewPicture/快速排序例题1.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b517d5abc.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Q4MhHTt1-1641217649156)(myReviewPicture/插入排序例题2.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51915b7d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YNkG7K8J-1641217649156)(myReviewPicture/插入排序3.png)]"></p><h6 id="（3、时空效率及稳定性-4">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51986b15.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E3u9CHCI-1641217649156)(myReviewPicture/插入排序时空效率.png)]"></p><h3 id="3、选择排序">3、选择排序</h3><h4 id="基本思想：-3">基本思想：</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519c39ea.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6WCpUUz3-1641217649157)(myReviewPicture/选择排序的基本思想.png)]"></p><h4 id="【1】简单选择排序">【1】简单选择排序</h4><h6 id="（1、基本思想：-5">（1、基本思想：</h6><blockquote><p>1）、在未排序的序列中选出最小元素和序列的<strong>首位元素</strong>交换，</p><p>2）、再在剩下的排序序列中再选出最小元素与序列的第2 个位置元素交换</p><p>3）、以此类推，最后形参从小到大的已排序序列。</p></blockquote><h6 id="（2、执行过程-5">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519bfb9d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eenzDDlH-1641217649158)(myReviewPicture/简单选择排序执行过程.png)]"></p><h6 id="（3、时空效率及稳定性-5">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519d7fa4.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HhrGBaPc-1641217649158)(myReviewPicture/简单选择排序3.png)]"></p><h4 id="【2】堆排序">【2】堆排序</h4><h6 id="（1、基本思想：-6">（1、基本思想：</h6><blockquote><p>1）、利用**最大堆（或最小堆）*<em>输出*<em>堆顶元素</em></em>，即最大值（或最小值）；</p><p>2）、将剩余元素重新生成<strong>最大堆（或最小堆）</strong>，继续输出<strong>堆顶元素</strong>；</p><p>3）、重复此过程，知道全部元素都已输出，得到的输出元素序列即为有序序列</p></blockquote><h6 id="（2、执行过程要点">（2、执行过程要点</h6><h6 id="1-初始化堆的过程">&lt;1&gt;初始化堆的过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519d2889.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BUmqOTks-1641217649159)(myReviewPicture/执行过程.png)]"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/da8a3cffadcfae675e33943af636920d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-amUvD16w-1641217649159)(myReviewPicture/堆排序.png)]"></p><blockquote><p><strong>下面是构建初始堆的过程</strong></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b18889.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WbussFeE-1641217649160)(myReviewPicture/堆排序2.png)]"></p><blockquote><p>下面是堆排序的过程</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b3f894.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jBlnfC3t-1641217649160)(myReviewPicture/堆排序1.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b4c648.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sWcyGiCK-1641217649160)(assets/image-20220103210541040.png)]"></p><h6 id="（3、时空效率及稳定性-6">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b4c652.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GOajy21Q-1641217649161)(myReviewPicture/堆排序空间效率.png)]"></p><h4 id="4、归并排序">4、归并排序</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51bacb3c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-g1lLA8Bd-1641217649161)(myReviewPicture/归并排序.png)]"></p><h4 id="二、各种排序的比较">二、各种排序的比较</h4><h4 id="口诀：快选堆希不稳，选堆归基不变">口诀：快选堆希不稳，选堆归基不变</h4><blockquote><p>不稳：说的是 算法不稳定</p><p>不变：说的是 关于移动次数和关键字顺序无关的排序</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51c46944.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Srey30WJ-1641217649161)(myReviewPicture/各种排序的比较.png)]"></p><p>end</p>]]></content>
    
    
    <summary type="html">数据结构知识点总结其二</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构复习其一</title>
    <link href="https://zhongye1.github.io/posts/4536146e.html"/>
    <id>https://zhongye1.github.io/posts/4536146e.html</id>
    <published>2024-07-25T18:24:14.000Z</published>
    <updated>2024-07-26T16:22:31.611Z</updated>
    
    <content type="html"><![CDATA[<p>明明大一下数据结构泡图书馆战斗几个星期从日到夜好不容易勉强过了</p><p>大二选修课还敢选数据结构</p><p>我也是个狠人</p><p>艹</p><img src="https://pic2.zhimg.com/80/v2-5570178f83684b066dfd65d5255fe6a5_720w.webp" alt="img" width=53%  /><center>这下真的完蛋了.jpg</center><hr><h2 id="第一章：数据结构绪论">第一章：数据结构绪论</h2><h3 id="一、数据">一、数据</h3><p>1.数据是<strong>信息的载体</strong>，是描述客观事物的数、字符、以及所有能输入到<a href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA&amp;spm=1001.2101.3001.7020">计算机</a>中，被计算机程序识别和处理的<strong>符号的集合</strong>。</p><p>2.数据分为：数值性数据和非数值性数据。</p><h3 id="二、数据元素">二、<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0&amp;spm=1001.2101.3001.7020">数据元素</a></h3><p>1.数据元素是数据的<strong>基本单位</strong>，是<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88&amp;spm=1001.2101.3001.7020">数据集合</a>的个体。</p><p>2.一个数据元素可以由若干<strong>数据项</strong>组成（此时数据元素被称为记录）。</p><p>3.数据元素又称为元素、结点、记录。</p><h3 id="三、数据项">三、数据项</h3><p>1.数据项是具有独立含义的<strong>最小</strong>标识单位。</p><p>2.数据项是数据的最小单位。</p><h3 id="四、数据对象">四、数据对象</h3><p>1.数据对象是具有相同性质的<strong>数据元素的集合</strong>，是数据的一个子集。</p><p>（整数数据对象，字母字符数据对象）</p><h3 id="五、结构">五、结构</h3><p>1.结构是元素之间的。</p><p>2.结构包含空间位置关系，相互作用和依赖关系。</p><p>3.四种基本结构：<strong>集合</strong>结构、<strong>线性</strong>结构、<strong>树形</strong>结构、<strong>图形</strong>结构。</p><p>(1)集合结构：结构中的数据元素之间除“同属一个集合”外，别无其他关系。</p><p>(2)线性结构：数据元素一对一关系。</p><p>(3)树形结构：一对多。</p><p>(4)图形结构：多对多。</p><h3 id="六、数据结构">六、数据结构</h3><p>1.形式定义：某一数据对象的所有数据成员之间的关系。记为：</p><p>Data_Structure={D,S}</p><p>其中,D是某一<strong>数据对象</strong>，即数据元素的有限集合，S是该对象中所有<strong>数据成员之间的关系</strong>的<strong>有限集合</strong>。</p><p>2.数据结构是相互之间存在一种或多种特点<strong>关系</strong>的<strong>数据元素的集合</strong>。</p><p>3.数据结构包含三方面的内容：<strong>逻辑</strong>结构，<strong>存储</strong>结构和数据的<strong>运算</strong>。</p><p>2.线性数据结构：L={K,R}（其中K为点集，R为关系&lt;&gt;）</p><p>3.树形数据结构：T={K,R}（其中K为点集，R为关系&lt;&gt;）</p><p>4.图形数据结构：G={K,R}（其中K为点集，R为关系() ）</p><h3 id="七、数据结构要解决的问题">七、数据结构要解决的问题</h3><p>1.从广义上讲，数据结构描述现实世界实体的数学模型及其上的操作在计算机中的表示和实现。</p><h3 id="八、逻辑结构">八、逻辑结构</h3><p>1.逻辑结构描述<strong>数据元素之间的关系</strong>。</p><p>2.逻辑结构包括线性结构和非线性结构。</p><p>（1）线性结构包括线性表（表、栈、队列、串）。栈、队列、串是受限线性表。</p><p>（2）非线性结构包括树（二叉树、赫夫曼树、二叉排序树）和图（有向图、无向图）。</p><h3 id="九、物理结构（存储结构）">九、物理结构（存储结构）</h3><p>1.物理结构是数据结构在计算机中的表示（或映像）。（存储结构是逻辑结构在计算机中的存储映像，包括数据元素映像和关系映像，但是逻辑结构是独立于存储结构的。）</p><p>2.物理结构包括：顺序存储表示、非顺序存储（链式存储表示、索引存储表示、散列存储表示）。</p><p><em><strong>注意：有序表属于逻辑结构；顺序表、哈希表、单链表属于存储结构</strong></em></p><p>(1)顺序存储：逻辑上相邻的元素，存储的物理位置也相邻。优点：随机存取，每个元素占用最少的存储空间；缺点：只能使用相邻的一整块存储单元，可能产生较多的外部碎片。</p><p>(2)链式存储：不要求逻辑上相邻的元素，存储的物理位置也相邻。借助指针表示元素之间的逻辑关系。优点：不会出现碎片现象，充分利用所有存储单元；缺点：每个元素因存储指针占用额外的存储空间，且只能实现顺序存取。</p><p>(3)索引存储：建立附加索引表。优点：检索速度快；缺点：附加的索引表占内存，增加和删除数据也会修改索引表，花费较多时间。</p><p>(4)散列存储：根据关键字直接计算存储地址。优点：检索、删除、增加都很快；缺点：会发生冲突，花费时间。</p><h3 id="十、数据类型">十、数据类型</h3><p>1.数据类型是<strong>一个值的集合</strong>和定义在这个值集上的<strong>一组操作</strong>的总称。</p><p>（如<strong>int整型</strong>变量，其值集为某个区间上的整数，定义在其上的操作为+、-、x、/等)</p><p>2.<strong>原子</strong>数据类型是不可分解的数据类型（如int、float、char、*等等）。</p><p>3.<strong>结构</strong>数据类型</p><p>（1）由若干成分（原子类型或结构类型）按照某种结构组成的数据类型）</p><p>（2）<strong>结构数据类型</strong>可以看做是<strong>一种数据结构</strong>和定义在其上的<strong>一组操作</strong>组成的整体。</p><p>（3）如数组，由若干个分量组成，每个分量可以是整数，也可以是数组（int A[10]）。</p><p>4.<strong>抽象</strong>数据类型</p><p>（1）由用户定义，用以表示应用问题的数据模型。</p><p>（2）由基本的数据类型组成，并包括一组相关的操作。</p><p>（3）信息隐蔽和数据封装，使用与现实相分离。</p><p>（4）抽象数据类型ADT是一个<strong>数学模型</strong>以及定义在该模型上的<strong>一组操作</strong>。</p><p>（5）<strong>抽象数据类型=数据结构+定义在此数据结构上的一组操作</strong>。</p><p>（6）（D，S，P）三元组表示。（D是<strong>数据对象</strong>，S是D上的<strong>关系</strong>集，P是对D的基本<strong>操作</strong>集）</p><p>（7）ADT定义：</p><p>ADT 抽象数据类型名{</p><p>数据对象：&lt;数据对象的定义&gt;</p><p>数据关系：&lt;数据关系的定义&gt;</p><p>基本操作：&lt;基本操作（函数）的定义&gt;</p><p>}ADT 抽象数据类型名</p><p>例子：</p><p>ADT Triplet {</p><p>数据对象：D = {e1,e2,e3 | e1,e2,e3∈ElemSet}</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据关系：R = &#123;<span class="attribute">&lt;e1,e2&gt;</span>, <span class="attribute">&lt;e2,e3&gt;</span>&#125;</span><br><span class="line"></span><br><span class="line">基本操作：Max(T, &amp;e)                           </span><br></pre></td></tr></table></figure><p>初始条件：三元组T已存在。</p><p>操作结果：用e返回T的3个元素中的最大值。</p><p>Min(T, &amp;e)</p><p>初始条件：三元组T已存在。</p><p>操作结果：用e返回T的3个元素中的最小值。</p><p>} ADT Triplet</p><p>（7）抽象数据类型可以通过固有的数据类型来实现：</p><p><strong>抽象数据类型：类class</strong></p><p>数据对象：数据成员</p><p>基本操作：成员函数（方法）</p><h3 id="十一、算法">十一、算法</h3><p>1.算法是对特定问题求解步骤的一种描述。</p><p>2.算法是一有限长的操作序列。</p><p>3.算法特性：</p><p>（1）<strong>有穷性</strong>：算法在执行有穷步后能结束。</p><p>（2）<strong>确定性</strong>：每步定义都是确切、无歧义，相同输入相同输出。</p><p>（3）<strong>可行性</strong>：每一条运算应足够基本（已验算正确）。</p><p>（4）<strong>输入</strong>：有0个或多个输入。</p><p>（5）<strong>输出</strong>：有1个或多个输出。</p><p>4.算法设计要求（目标）：</p><p>（1）<strong>正确性</strong>：满足具体题目的需求。</p><p>（2）<strong>可读性</strong>：便于理解和修改。</p><p>（3）<strong>健壮性</strong>：当输入数据非法时，也能适当反应。</p><p>（4）<strong>效率高</strong>：执行时间少。</p><p>（5）<strong>空间省</strong>:执行中需要的<strong>最大</strong>存储空间少。</p><h3 id="十二、时间复杂度">十二、时间复杂度</h3><p>1.算法效率的度量是通过时间复杂度和空间复杂度来描述的。</p><p>衡量算法的效率，主要依据算法执行所需要的时间，即时间复杂度。</p><p><em><strong>注意：算法分析的目的：分析算法的效率以求改进。</strong></em></p><p>2.事后统计法：计算算法开始时间与完成时间差值。</p><p>缺点：（必须执行程序；其它因素遮盖算法本质）</p><p>3.事前统计法：依据算法选用何种策略及问题的规模n，是常用的方法。</p><p>4.（事前统计法）和算法执行时间相关的因素：</p><p>（1）<strong>算法选用的策略</strong>（主要）</p><p>（2）<strong>问题的规模</strong>（主要）</p><p>（3）编写的语言</p><p>（4）编译程序产生的机器代码的质量</p><p>（5）计算机执行指令的速度</p><p>5.一般情况下，算法中<strong>基本操作重复执行的次数</strong>是问题规模n的某个函数，算法的<strong>时间量度记作 T(n)=O(f(n))</strong>，称作算法的渐近时间复杂度,简称时间复杂度。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同。</p><p>（1）加法规则：T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))</p><p>（2）乘法规则：T(n)=T1(n)*T2(n)=O(f(n)) * O(g(n))=O(f(n)*g(n))</p><p>6.时间复杂度除常量阶[O(1)], 线性阶[O(n)], 平方阶[O(n^2)]外，还有对数阶[O(logn)]，排列阶[O(n!)]，指数阶[O(2^n)]等，是相对于问题规模n的增长率的表示方法。</p><p>（1）多项式：O(1)&lt;O(log2(n))&lt;O(n)&lt;O(nlog2(n))&lt;O(n^2)&lt;O(n^3)</p><p>（2）指数时间：O(2^n)&lt;O(n!)&lt;O(n^n)</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=n)i=i*<span class="number">2</span>;</span><br><span class="line"><span class="comment">//令执行x次，2^x=n，x=log2(n)，即时间复杂度为O(log2(n))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归算法，时间复杂度是O(n)</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;                 </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> (n*rec(n<span class="number">-1</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>7.如果算法的执行有<strong>多种可能</strong>的操作顺序，则求其<strong>平均</strong>时间复杂度。</p><p>如果<strong>无法求取平均</strong>时间复杂度，则采用<strong>最坏</strong>情况下的时间复杂度。</p><p>时间复杂度是衡量算法好坏的一个最重要的标准。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void bubble-sort<span class="params">(int a[]，int n)</span></span><br><span class="line">&#123;</span><br><span class="line">    for<span class="params">(<span class="attr">i</span>=n-1,<span class="attr">change</span>=TURE;i&gt;1 &amp;&amp; change;--i)</span></span><br><span class="line">      &#123;</span><br><span class="line">           change=<span class="literal">false</span>;</span><br><span class="line">           for<span class="params">(<span class="attr">j</span>=0;j&lt;i;++j)</span></span><br><span class="line">               <span class="keyword">if</span> <span class="params">(a[j]&gt;a[j+1])</span> &#123;</span><br><span class="line">                     a[j] ←→a[j+1];</span><br><span class="line">                    change=TURE&#125;</span><br><span class="line">       &#125;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="string">//</span>最好情况：0次（全部升序排列）</span><br><span class="line"><span class="string">//</span>最坏情况：n*<span class="params">(n-1)</span><span class="string">/2</span>次（全部降序排列）</span><br><span class="line"><span class="string">//5</span> 4 3 2 1（5要比较（n-1）次，1被移到最前面了，比较0次，共有n个元素，使用求和公式0+1+<span class="string">...</span>+<span class="params">(n-1)</span>=n*<span class="params">(n-1+0)</span><span class="string">/2</span></span><br><span class="line"><span class="string">//</span>平均时间复杂度：O<span class="params">(n^2)</span></span><br></pre></td></tr></table></figure><h3 id="十三、空间复杂度">十三、空间复杂度</h3><p>1.空间复杂度指算法执行时，所需要<strong>存储空间</strong>的量度，它也是问题规模的函数，即：S(n) = O(f(n))。</p><p>2.算法的存储量包括：</p><p>（1）<strong>程序本身</strong>所占空间（与算法无关）</p><p>（2）<strong>输入数据</strong>所占空间（与算法无关）</p><p>（3）<strong>辅助变量</strong>所占空间（若所需额外空间相对于输入数据量来说是<strong>常数</strong>，则称此算法为<strong>原地工作</strong>。否则,按最坏情况分析）</p><p><em><strong>注意：只有辅助变量所占空间与算法有关</strong></em></p><h2 id="第二章：线性表">第二章：线性表</h2><h3 id="一、线性数据结构的特点">一、线性数据结构的特点</h3><p>在<strong>数据元素</strong>的<strong>非空有限</strong>集中 ：</p><p>1.存在惟一的一个被称作“第一个”的数据元素。</p><p>2.存在惟一的一个被称作“最后一个”的数据元素。</p><p>3.除第一个元素外，每个数据元素均只有一个前驱 。</p><p>4.除最后一个元素外，每个数据元素均只有一个后继 。</p><h3 id="二、线性表">二、线性表</h3><p>1.线性表是最简单的一类线性数据结构。</p><p>2.线性表是由n个<strong>数据元素</strong>组成的<strong>有限</strong>序列，相邻数据元素之间存在着序偶关系，可以写为：(a1, a2,…ai-1, ai, ai+1,…an-1, an)其中,ai是表中元素,i表示元素ai的位置,n是表的长度。</p><p>3.线性表中的<strong>元素</strong>具有<strong>相同</strong>的特性，属于<strong>同一数据对象</strong>，如：1.26个字母的字母表: (A,B,C,D,…,Z)2.近期每天的平均温度:(30℃, 28℃, 29℃,…)。</p><h3 id="三、顺序表">三、顺序表</h3><p>1.顺序表是线性表的顺序表示。（线性表的顺序存储称为顺序表）</p><p>2.用一组地址连续的存储单元依次存储线性表的数据元素。逻辑相邻，物理也相邻。</p><p>3.顺序表数据元素的位置：</p><p>loc(a[i])=loc(a[i-1])+length</p><p>loc(a[i])=loc(a[1])+(i-1)*length</p><p>其中length表示元素占用的内存单元数。</p><p>4.顺序表的插入操作：</p><p>（1）顺序表的插入操作是指在顺序表的第i-1个数据元素和第i个数据元素之间插入一个新的数据元素，即将长度为n的顺序表：(a1,…ai-1, ai, …, an) 变成长度为n+1的顺序表：(a1,…ai-1, e, ai, …, an)</p><p>（2）在顺序表中的第i个位置插入一个元素，需要向后移动的元素个数为：<strong>n-i+1</strong></p><p>（3）平均移动元素数为（假设在第i个元素之间插入的概率为pi）：Eis = ∑ pi x (n-i+1) 其中i从1到n+1。</p><p>（4）当插入位置等概率时pi=1/(n+1)，因为可以插在最后面。因此：</p><p>Eis = ∑ [1/(n+1)] x (n-i+1) = n/2其中i从1到n+1。</p><p><img src="./../assets/d3d5befebcaaadca3725f68af9556728.png" alt="img"></p><p><em><strong>注意：顺序表插入平均移动元素数为n/2</strong></em></p><p>（5） 顺序表插入操作的时间复杂度为<strong>O(n)</strong>。</p><p>5.顺序表的删除操作：</p><p>（1）顺序表的删除操作是指将顺序表的第i个数据元素删除，即将长度为n的顺序表：(a1,…ai-1, ai, ai+1,…, an) 变成长度为n-1的顺序表：(a1,…ai-1, ai+1, …, an)</p><p>（2）在顺序表中删除一个元素，需要向前移动元素个数为：<strong>n-i</strong>（不用加一）</p><p>（3）平均移动元素数为：Edl = ∑ qi x (n-i) 其中i从1到n。</p><p><img src="./../assets/ee1f23913aa2d443340c3c4ea317b586.png" alt="img"></p><p>（4）当删除位置等概率时qi=1/n，因为只有n个元素可以删除。因此：</p><p>Edl = ∑ [1/n] x (n-i) = (n-1)/2其中i从1到n。</p><p><img src="./../assets/72ab2edd476db5d70bf3380c5e4ddf47.png" alt="img"></p><p><em><strong>注意：顺序表删除平均移动元素数为(n-1)/2</strong></em></p><p>（5）顺序表删除操作的时间复杂度为<strong>O(n)</strong>。</p><p>6.顺序表的其它操作:</p><p>（1）查找第i个位置的元素值。</p><p>（2）查找元素所在位置。</p><p>（3）得到表长。</p><p>（4）置空表。</p><p>（5）销毁表(析构函数~SqList())。</p><p>7.顺序表的优缺点：</p><p>（1）优点：元素可以<strong>随机存取</strong>；<strong>元素位置</strong>可用一个简单、直观的公式表示并求取。通过首地址和元素序号,<strong>O(1)内找到</strong>指定元素。存储密度高，每个结点只存储数据元素。</p><p>（2）缺点：在作<strong>插入或删除</strong>操作时，需要移动大量元素 。</p><p><em><strong>注意：一个顺序表的第一个元素存储地址为2001,每个元素占用4个地址单元，第6个元素的存储地址为：2001+（6-1）5=2021；对于顺序存储的线性表，删除、增加结点的时间复杂度为O(n)</strong></em></p><h3 id="四、链表">四、链表</h3><p>1.链表是线性表的<strong>链式存储</strong>表示。</p><p>2.链表中逻辑关系相邻的元素不一定在存储位置上相连，用指针表示元素之间的邻接关系。</p><p>3.线性表的链式存储表示主要有三种形式：<strong>线性链表、循环链表、双向链表</strong>。</p><p>4.线性链表：</p><p>（1）线性链表的<strong>元素称为结点</strong>。</p><p>（2）结点除包含数据元素信息的<strong>数据域</strong>外，还包含指示直接后继的<strong>指针域</strong>。</p><p>（3）每个结点，在需要时<strong>动态生成</strong>，在删除时释放。</p><p>（4）N个结点(ai(1≤i ≤ n)的存储映像)链结成一个链表,即为线性表的链式存储结构。</p><p>（5）链表的每个结点中<strong>只包含一个指针域</strong>,故又称<strong>线性</strong>链表或<strong>单</strong>链表。</p><p>（6）线性链表可由<strong>头指针</strong>惟一确定。</p><p>（7）以线性表中的第一个数据元素a1的存储地址作为线性表的地址，称作线性表的头指针。</p><p>（8）有时为了操作方变，在第一个节点之前虚加一个&quot;<strong>头结点</strong>&quot;，以<strong>指向头结点的指针为链表的头指针</strong>。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LNode *head;//头指针</span><br><span class="line">head = new LNode;//生成头结点  head-&gt;[ |<span class="type">^]</span></span><br><span class="line"><span class="type">//head</span>-&gt;[ |<span class="type">-]-&gt;[a</span>|<span class="type">-]-&gt;[b</span>|<span class="type">-]-&gt;....</span></span><br></pre></td></tr></table></figure><p><em><strong>注意：头结点和头指针区分：不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中第一个结点，结点内通常不存储信息。增加头结点的目的是为了方便运算。</strong></em></p><p><em><strong>头结点的优点:(1)由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无需进行特殊处理；(2)无论链表是否为空，其头指针都指是向头结点的非空指针（空表中头结点的指针域为空）</strong></em></p><p><em><strong>单链表的头指针为head，不带头结点的判空条件：head==NULL</strong></em></p><p><em><strong>带头结点的判空条件：head-&gt;next==NULL (L -&gt;[ |^] (head-&gt;next==NULL))</strong></em></p><p>（9）<strong>找第i个</strong>元素getelement：在线性链表中找到第i个元素，并返回指针；从头结点开始，顺链一步步查找；查找第i个数据元素的基本操作为：移动指针，比较k和i（k为当前指针所指向的结点序号）。时间复杂度为<strong>O(n)</strong>。</p><p>（10）线性链表的<strong>插入</strong>：在线性链表的第i-1个元素与第i和元素之间插入一个新元素。<strong>s-&gt;next=p-&gt;next;p-&gt;next=s</strong>。（其中s为新元素）时间复杂度主要取决于getelement的时间复杂度，getelement的时间复杂度为<strong>O(n)</strong>，因此线性链表插入的时间复杂度为O(n)。</p><p><em><strong>注意：在单链表中第i个结点之前进行插入的基本操作：找到线性表中的第i-1个结点p，创建新结点s，然后修改第i-1个结点和s结点的后继指针。s-&gt;next=p-&gt;next;p-&gt;next=s</strong></em></p><p>（11）线性链表的<strong>删除</strong>：将线性链表的第i个元素删除。</p><p>找到线性表中第i-1个结点p，修改其指向后继的指针。</p><p>q=p-&gt;next;p-&gt;next=q-&gt;next;(e=q-&gt;data)delete q;（删除p-&gt;next这个结点）时间复杂度主要取决于getelement的时间复杂度，getelement的时间复杂度为O(n)，因此线性链表删除的时间复杂度为<strong>O(n)</strong>。</p><p>（12）线性链表的创建：链表是一个<strong>动态</strong>的结构，不需要预分配空间，生成链表的过程是一个结点&quot;<strong>逐个插入</strong>&quot;的过程。依次调用insert即可，<strong>时间复杂度O(n^2)</strong>。n个结点，每个结点每次插入Insert函数，头指针指向最后，表尾插入故为n*n。</p><p>（13）线性链表的创建-头插法：即表头不断插入新结点。逆序输入数据值。<strong>头插法时间复杂度O(n)</strong>。</p><p>（14）线性链表的创建-尾插法：即表尾不断插入新结点。按链表序输入数据值。为记录尾结点，增加一个尾指针tail，指向最后一个结点。<strong>尾插法时间复杂度O(n)</strong></p><p>（15）单链表的合并：将两个<strong>有序</strong>链表合并成一个有序链表。</p><p>（16）拷贝构造函数被调用的三种情况：一个对象以值传递的方式传入函数体；一个对象以值传递的方式从函数返回；一个对象需要通过另一个对象进行初始化。</p><p>（17）赋值函数被调用的时机：当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。</p><p>（18）拷贝构造函数与赋值函数比较：</p><p>调用拷贝构造函数来初始化一个对象：</p><p>A a;A b(a); A b=a;</p><p>都是<strong>拷贝构造函数来创建对象b（b还不存在）</strong></p><p>调用赋值函数对对象复制：</p><p>A a;A b;b=a;</p><p>强调：<strong>这里a,b对象是已经存在的，是用a 对象来赋值给b</strong>的！！</p><p>5.静态链表：线性链表也可以采用静态数组实现。</p><p>与顺序表有两点不同：</p><p>（1）每个元素包括数据域和指针域。</p><p>（2）元素的逻辑关系由指针确定。</p><p>与单链表的区别：</p><p>（1）静态链表暂时不用结点，链成一个<strong>备用链表</strong>。</p><p>（2）插入时，从备用链表中<strong>申请结点</strong>。</p><p>（3）删除结点时，将结点放入备用链表。</p><p>6.循环链表：</p><p>（1）循环链表是一种特别的线性链表。</p><p>（2）循环链表中最后一个结点的指针域指向头结点，整个链表形成一个环。</p><p>（3）在<strong>只有尾指针的单循环链表</strong>中：</p><p>表头插入结点：在只有尾指针的情况下，要在表头插入结点，首先需要找到尾结点，然后将新结点插入到尾结点之后。因此，表头插入结点的时间复杂度为 O(1)（常数时间），因为无论链表有多长，插入操作所需的时间都是相对固定的。</p><p>虽然在只有尾指针的情况下，插入结点时需要找到尾结点，但这并不会导致时间复杂度变为 O(n)。在单循环链表中，尾结点指向头结点，因此我们可以<strong>直接通过尾指针找到头结点，然后在头结点之后插入新结点。</strong></p><p>因此，<strong>表头插入结点的时间复杂度仍然是 O(1)</strong>，因为无论链表有多长，插入操作所需的时间都是相对固定的。</p><p>表尾插入结点：由于只有尾指针，直接<strong>在尾结点之后插入新结点</strong>即可。因此，表尾插入结点的时间复杂度同样为 <strong>O(1)</strong>。</p><p>（4）查找、插入和删除：与线性链表基本一致，差别仅在于算法中的循环条件不是p-&gt;next或p是否为空（^)，而是它们是否等于头指针(L)。</p><p><strong>注意循环链表带头结点判空：head-&gt;next==head</strong></p><p>7.双向链表</p><p>（1）双向链表是一种特殊的线性链表：每个结点有<strong>两个指针</strong>，一个指针指向直接后继(next)，另一个指针指向直接前驱(prior)。</p><p>（2）对于任何一个中间节点有：p=p-&gt;next-&gt;prior/p=p-&gt;prior-&gt;next。</p><p>（3）插入操作需要改变两个方向的指针：s-&gt;next=p;s-&gt;prior=p-&gt;prior;p-&gt;prior-&gt;next=s;p-&gt;prior=s;</p><p>（4）删除操作需要改变两个方向的指针：p-&gt;prior-&gt;next=p-&gt;next;p-&gt;next-&gt;prior=p-&gt;prior;</p><p>8.双向循环链表</p><p>（1）存在两个环：一个是直接后继环，另一个是直接前驱环。</p><h3 id="五、一元多项式">五、一元多项式</h3><p><a href="http://1.pn">1.pn</a> (x) = p0 + p1x + p2 x^ 2 + … + pn x^ n</p><p>在计算机中，可以用一个线性表来表示：P = (p0 , p1 , …，pn)</p><p><a href="http://2.pn">2.pn</a>(x)=p1x^e1+p2x^e2+…+pmx^em</p><p>线性表示((p1,e1),(p2,e2),…,(pm,em))</p><h3 id="六、顺序表与链表的比较">六、顺序表与链表的比较</h3><p>1.基于<strong>空间</strong>的比较</p><p>（1）存储分配的方式：<strong>顺序表</strong>的存储空间是<strong>静态</strong>分配的，<strong>链表</strong>的存储空间是<strong>动态</strong>分配的。</p><p>（2）存储密度=结点数据本身所占的存储量/结点结构所占的存储总量</p><p><strong>顺序表的存储密度=1，链表的存储密度&lt;1</strong></p><p>2.基于<strong>时间</strong>的比较</p><p>（1）存取方式：顺序表可以随机存取也可以顺序存取，<strong>链表必须顺序存取</strong>。</p><p>（2）插入、删除时移动元素个数：顺序表平均需要移动近一半元素，链表不需要移动元素只需要修改指针。</p><p>3.基于<strong>应用</strong>的比较 （1）线性表主要是<strong>存储大量数据</strong>，并用于<strong>查找</strong>时，采用顺序表比较好。</p><p>（2）若线性表存储的数据元素要<strong>经常插入和删除</strong>，采用链表比较好。</p><p><em><strong>注意：某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用带尾指针的单循环链表最节省时间。</strong></em></p><p><em><strong>仅有尾指针的单循环链表，可以非常方便地找到尾结点，尾结点后面的第一个结点往往是头结点，头结点的下一个结点就是线性表的第一个结点。对最后一个元素和第一个元素操作对带尾指针的单循环链表是非常方便的</strong></em></p><p><em><strong>循环链表是线性表，它是线性表的链表存储结构之一。</strong></em></p><p><em><strong>在一个以h为头的单循环链表中，p指针指向链尾的条件是p-&gt;next=h。</strong></em></p><h2 id="第三章：栈和队列">第三章：栈和队列</h2><h3 id="一、栈">一、栈</h3><p>1.栈是限定仅在<strong>表尾</strong>(top)进行插入或删除操作的<strong>线性表</strong>。</p><p>2.允许插入和删除的一端称为栈顶(top，表尾)，另一端称为栈底(bottom，表头）</p><p>3.特点：后进先出 (LIFO)</p><p>4.栈的<strong>存储结构：顺序栈和链式栈</strong>。</p><p>5.顺序栈：</p><p>（1）顺序栈是栈的顺序存储结构。</p><p>（2）利用<strong>一组地址连续</strong>的存储单元依次存放自栈底到栈顶的数据元素。</p><p>（3）指针top指向栈顶元素在顺序栈中的下一个位置，base为栈底指针，指向栈底的位置。</p><p>（4）<strong>top=0 或top=base 表示空栈</strong>。</p><p>（5）<strong>base=NULL表示栈不存在</strong>。</p><p>（6）当插入新的栈顶元素时,指针top+1。</p><p>（7）删除栈顶元素时，指针top-1。</p><p>（8）当top&gt;stacksize时，栈满，溢出。</p><p><em><strong>注意：向顺序表中压入新元素，应当先移动栈顶指针，再入栈，出栈时先取栈顶元素再移动指针</strong></em></p><p>6.链栈：</p><p>（1）栈的链式存储结构称为链栈，它是运算受限的单链表，可插入和删除操作仅限制在<strong>表头</strong>位置上进行。</p><p>（2）由于<strong>只能在链表头部</strong>进行操作，故链表<strong>没有必要像单链表那样附加头结点</strong>。<strong>栈顶指针就是链表的头指针</strong>。</p><p>（3）链栈中为何不设头指针？因为链栈<strong>只在链表头</strong>插入和删除结点,不可能在链表中间插入或删除结点,算法实现很简单,所以一般不设置头结点。</p><p>（4）链栈对比顺序栈主要优点在于，通常<strong>不会栈满</strong>的情况</p><p>7.C++中栈容器：</p><p>（1）stack 模板类的定义在<stack>头文件中。</p><p>（2）定义stack 对象的示例代码如下：stack<int> s1;stack<string> s2;</p><p>（3）stack 的基本操作有：</p><p>入栈，如例：s.push(x);</p><p>出栈，如例：s.pop();注意，出栈操作只是删除栈顶元素，并不返回该元素。</p><p>访问栈顶，如例：s.top()</p><p>判断栈空，如例：s.empty()，当栈空时，返回true。</p><p>访问栈中的元素个数，如例：s.size()。</p><p>8.栈的应用举例</p><p>（1）数值转换：</p><p>将十进制转换为其他进制（d）：N=(N*d)*d+N mod d</p><p>（<strong>计算顺序与输出顺序相反</strong>）</p><p>（2）行编辑程序</p><p>（3）迷宫求解（用一个栈来记录已走过的路径）</p><p>设定当前位置为入口位置</p><p>do {若当前位置可通，则 {</p><p>将该位置插入栈顶(Push)；若该位置是出口，则结束</p><p>否则切换当前位置的东邻方块为当前位置；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125; 否则 &#123;      　</span><br></pre></td></tr></table></figure><p>若栈不空则｛</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    　  如果栈顶位置的四周均不可通,则删除栈顶位置(<span class="built_in">Pop</span>)</span><br><span class="line"></span><br><span class="line">      　并重新测试新的栈顶位置</span><br></pre></td></tr></table></figure><p>如果找到栈顶位置的下一方向未经探索，则将该方向</p><p>方块设为当前位置}}}while(栈不空)；找不到路径；</p><p>（4）表达式求值：表达式由操作数、运算符和界限符组成，它们皆称为单词。</p><p>操作数：常数或变量。运算符：+, -, *, / 等。界限符：(, ), #(表达式开始及结束符)。</p><p>计算步骤：假设操作数栈NS和运算符栈OS，</p><p>–（1）依次读取表达式，若为操作数，则直接进栈；</p><p>若为运算符(记为op2)，转（2）</p><p>–（2）将op2与运算符栈顶元素(记为op1)按P53的表3.13 比较优先权，并按如下规则进行操作：</p><p>若prec(op1) &lt; prec(op2), 则op2入OS;</p><p>若prec(op1) = prec(op2), 则op1出栈，回到（1）；</p><p>若prec(op1) &gt; prec(op2), 则NS出2个操作数 num2,num1,op1出栈，</p><p>计算num2 op1 num2，结果入NS；回到(2) 。</p><p>–（3）重复（1）、（2）直至整个表达式求值完毕。</p><p><img src="./../assets/5522aca5dc9f7fa1b30012ec5cc23a76.jpeg" alt="img"></p><p>例如: Exp = a x b + (c - d / e) x f</p><p>前缀式: + x a b x - c / d e f</p><p>中缀式: a x b + c - d / e x f</p><p>后缀式: a b x c d e / - f x +</p><p>前缀式的运算规则为:连续出现的两个操作数和在它们之前且紧靠它们的运算符构成一个最小表达式;</p><p>中缀式丢失了括弧信息,致使运算的次序不确定;（编译系统中：中缀转后缀进行计算）</p><p>后缀式的运算规则为: 运算符在式中出现的顺序恰为表达式的运算顺序; 每个运算符和在它之前出现 且 紧靠它的两个操作数构成一个最小表达式。</p><p>结论：操作数之间的相对次序不变；运算符的相对次序不同。</p><p>得到后缀表达式后，我们在计算表达式时，可以设置一个栈，从左到右扫描后缀表达式，每读到一个操作数就将其压入栈中；每到一个运算符时，则从栈顶取出两个操作数进行运算，并将结果压入栈中，一直到后缀表达式读完。最后栈顶就是计算结果。</p><p><img src="./../assets/73bcc40a165c14288da3c69aa7b777e3.jpeg" alt="img"></p><p>9.栈与递归的实现</p><p>（1）当在一个函数的运行期间调用另一个函数时，在运行该被调用函数之前，需先完成三项任务：将所有的实在参数、返回地址等信息传递给被调用函数<strong>保存</strong>；为被调用函数的局部变量分配存储区；将控制转移到被调用函数的入口。</p><p>（2）从被调用函数返回调用函数之前，应该完成下列三项任务：保存被调函数的计算结果；释放被调函数的数据区；依照被调函数保存的返回地址将控制转移到调用函数</p><p>（3）多个函数嵌套调用：后调用先返回！此时的内存管理实行“栈式管理”。</p><p>（4）递归函数执行的过程可视为同一函数进行嵌套调用。</p><p><em><strong>注意：n个不同元素进栈，出栈元素不同排列个数为：(1/(n+1))C(2n,n)其中C为组合数，从2n个选n个</strong></em></p><h3 id="二、队列">二、队列</h3><p>1.队列是只允许在<strong>表的一端</strong>进行插入，而在<strong>另一端</strong>删除元素的线性表。</p><p>2.在队列中，允许插入的一端叫队尾（rear），允许删除的一端称为对头(front)。特点：先进先出 (FIFO)</p><p>3.<strong>顺序</strong>队列：采用一组地址连续的存储单元依次存储从队列头到队列尾的元素。顺序队列有两个指针：队头指针front和队尾指针rear</p><p>4.顺序队列的进队和出队原则：进队时，新元素按rear指针位置插入，然后队尾指针增一，即 rear = rear + 1；出队时，将队头指针位置的元素取出，然后队头指针增一，即 front = front + 1；队头指针始终指向队列头元素；队尾指针始终指向队列尾元素的下一个位置。</p><p>5.顺序队列存在的问题：</p><p>（1）当队尾指针指向队列存储结构中的最后单元时，如果再继续插入新的元素，则会产生溢出当队列发生溢出时。</p><p>（2）不能用rear==maxsize判断队满。</p><p>（3）队列存储结构中可能还存在一些空白位置（已被取走数据的元素），<strong>假上溢</strong>。(前面还有空位)</p><p><img src="./../assets/a26ad1874b5dd398e0729183cd513b19.png" alt="img"></p><p>（3）解决办法之一：将队列存储结构首尾相接，形成循环(环形)队列。</p><p>6.循环队列：</p><p>（1）循环队列采用一组地址连续的存储单元。</p><p>（2）将整个队列的存储单元<strong>首尾相连</strong>。</p><p>（3）判断对空和队满：</p><p>对循环队列而言，无法通过front==rear来判断队列“空”还是“满”。 解决此问题的方法至少有三种：</p><p>其一是另设一个布尔变量以匹别队列的空和满；</p><p>其二是<strong>少用一个元素的空间</strong>，约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满（<strong>注意：rear所指的单元始终为空！！</strong>）；</p><p><strong>front = rear，（都指向空）循环队列空；(rear+1) % MAXQSIZE = front，循环队列满。</strong></p><p><img src="./../assets/84cb2d96787f14704d54a3051de22c89.png" alt="img"></p><p>其三是使用一个计数器记录队列中元素的总数（实际上是队列长度）。</p><p>（4）循环队列：</p><p>初始时：front=rear=0</p><p>出队，队首指针加一：front=(front+1)%maxsize</p><p>进队，队尾指针加一：rear=(rear+1)%maxsize</p><p><strong>队列长度：(rear-front+maxsize)%maxsize</strong></p><p>若牺牲一个单元来区分队列空和队列满，队列少用一个队列单元：</p><p><strong>队满：(rear+1)%maxsize==front</strong></p><p>队空：front==rear</p><p><strong>题目</strong>：假设Q[ 11] (下标为从0到10)是一个循环队列,初始状态为front=rear=0;画出分别做完下列操作后队列的头尾指针的装填变化情况,若不能入队,请指出其元素,说明理由…(采用少用一个元素空间的方式)</p><p>d,e,b,g,h入队</p><p>d,e出队</p><p>i,j,k,l,m入队</p><p>b 出队</p><p>n,o,p,q,r 入队</p><p><img src="./../assets/8d1d75223b9b6c9ef846de9c3d1a8206.png" alt="img"></p><p>(上述答案采用front指向空，应改为rear时刻指向空！)</p><p>7.链队列</p><p>（1）链队列采用链表存储单元链队列中，有<strong>两个</strong>分别指示队头和队尾的<strong>指针</strong>。</p><p>（2）链式队列在进队时无队满问题，但<strong>有队空问题</strong>。</p><p>（3）链队列是链表操作的子集。</p><p><strong>设长度为n的链队列用单循环链表表示，若只设头指针，则入度时间复杂度为O(n)，出队时间复杂度为O(1);若只设尾指针，则入队时间复杂度和出队时间复杂度都为O(1)，出队队头之间是tail-&gt;next即可。</strong></p><p><strong>删除一个结点，即出队时的指针操作为：front=front-&gt;next</strong></p><p>8.C++中的队列容器</p><p>（1）queue 模板类的定义在<queue>头文件中。</p><p>（2）定义queue 对象的示例代码如下：queue<int> q1;queue<double> q2;</p><p>（3）queue 的基本操作有：</p><p>入队，如例：q.push(x); 将x 接到队列的末端。</p><p>出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。</p><p>访问队首元素，如例：q.front()，即最早被压入队列的元素。</p><p>访问队尾元素，如例：q.back()，即最后被压入队列的元素。</p><p>判断队列空，如例：q.empty()，当队列空时，返回true。</p><p>访问队列中的元素个数，如例：q.size()</p><p>9.C++中的map容器</p><p>（1）map是c++的一个标准容器，提供了key和value的映射。map 模板类定义在<map>头文件中。</p><p>（2）map对象定义：map&lt;string , int &gt; mapstring;</p><p>（3）map添加数据：map&lt;int ,string&gt; maplive; -1.maplive.insert(pair&lt;int,string&gt;(102,“aclive”));</p><p>-2.maplive.insert(map&lt;int,string&gt;::value_type(321,“hai”));</p><p>-3.maplive[112]=“April”;//map中最简单最常用的插入添加！</p><p>（4）map中查找数据：</p><p>-1.使用map的下标运算符重载</p><p>map&lt; std::string,int&gt; mapTest;</p><p>cout&lt;&lt;mapTest[“index”]&lt;&lt;endl;</p><p>-2.使用map的find接口。</p><p>map&lt; std::string,int&gt; mapTest;</p><p>map&lt; std::string,int&gt;::iterator it = mapTest.find(“index”);</p><p>if(it!=mapTest.end()) cout&lt;&lt; it-&gt;second&lt;&lt;endl;</p><p><strong>大题重点：表达式求值</strong></p><p><img src="./../assets/43b43b7ce2fa49529495aeb5c9e63e37.png" alt="img"></p><p>(同种符号比较，先出现的优先级高)</p><h2 id="第四章：串">第四章：串</h2><h3 id="一、字符串">一、字符串</h3><p>1.字符串是n个字符的有限序列。</p><p>2.字符串术语：</p><p>（1）空串：不含任何字符的串，串长度=0。</p><p>（2）空格串：仅由一个或多个空格组成的串。</p><p>（3）子串：由串中任意个连续的字符组成的子序列。</p><p>（4）主串：包含子串的串。</p><p>（5）位置：字符在主串中的序号。子串在主串中的位置以子串第一个字符在主串中的位置来表示。</p><p>（6）串相等的条件：当两个串的长度相等且各个对应位置的字符都相等时才相等。</p><p>（7）<strong>模式匹配</strong>：确定子串在主串中<strong>首次</strong>出现的位置的运算</p><p>3.字符串与线性表的关系</p><p>—串的逻辑结构和线性表极为相似：</p><p>（1）它们都是<strong>线性结构</strong>。</p><p>（2）串中的<strong>每个字符</strong>都仅有一个<strong>前驱</strong>和一个<strong>后继</strong>。</p><p>—串与线性表又有区别，主要表现为：</p><p>（1）串的<strong>数据对象</strong>约定是<strong>字符集</strong>。</p><p>（2）在线性表的基本操作中，以“<strong>单个元素</strong>”作为操作对象。</p><p>（3）在串的基本操作中，通常以“<strong>串的整体</strong>”作为操作对象，如：在串中查找某个子串、在串的某个位置上插入一个子串等。</p><p>4.字符串的操作</p><p>13种操作中的<strong>最小</strong>操作子集(五种)：串<strong>赋值</strong>StrAssign;串<strong>比较</strong>StrCompare;求<strong>串长</strong>StrLength;串<strong>联接</strong>Concat;求<strong>子串</strong>SubString。</p><p>最小操作集：</p><p>这些操作不可能利用其他串操作来实现，反之，其他串操作（除串清除ClearString和串销毁DestroyString外）可在这个最小操作子集上实现。</p><p>5.字符串的操作(index)</p><p>（1）串匹配(查找)的定义: INDEX (S, T, pos)</p><p>（2）初始条件：串S和T存在，T是非空串，1≤pos≤StrLength(S)。</p><p>（3）操作结果：若主串S中存在和串T值相同的子串返回它在主串S中第pos个字符之后第一次出现的位置；否则函数值为0。</p><h3 id="二、串的表示和实现">二、串的表示和实现</h3><p>1.定长顺序存储表示（静态存储分配）</p><p>（1）用一组地址连续的存储单元存储字符序列。</p><p>（2）如C语言中的字符串定义(以“\0”为串结束标志) char Str[MAXSTRLEN+1];</p><p>（3）定义了长度为MAXSTRLEN字符存储空间字符串长度可以是小于MAXSTRLEN的任何值（最长串长度有限制，多余部分将被截断）</p><p>（4）隐含：一般可使用一个不会出现在串中的特殊字符在串值的尾部来表示串的结束。</p><p>优点:便于系统自动实现。</p><p>缺点:不利于某些操作(如合并).</p><p>例如，C语言中以字符‵\0′表示串值的终结，这就是为什么在上述定义中，串空间最大值maxstrlen为256，但最多只能存放255个字符的原因。</p><p>（5）显式：若不设终结符，可用一个整数来表示串的长度，那么该长度减1的位置就是串值的最后一个字符的位置（下标）。</p><p>优点:便于在算法中用长度参数控制循环过程。</p><p>2.<strong>堆分配存储</strong>表示</p><p>（1）在程序执行过程中，动态分配（malloc）一组地址连续的存储单元存储字符序列。</p><p>（2）在C++语言中，由new和delete动态分配与回收的存储空间称为堆。</p><p>（3）堆分配存储结构的串既有顺序存储结构的特点，处理方便,操作中对串长又没有限制,更显灵活。</p><p>3.链存储表示</p><p>（1）采用链表方式存储串值。</p><p>（2）每个结点中，可以存放一个字符，也可以存放多个字符。</p><p>（3）存储密度=数据元素所占存储位/实际分配的存储位。</p><h3 id="三、串的匹配算法">三、串的匹配算法</h3><p>1.求子串位置函数Index()</p><p>（1）子串的定位操作通常称做串的模式匹配。</p><p>（2）算法（穷举法，朴素算法，BF(Brute-Force)算法）：</p><p>从主串的指定位置开始，将主串与模式（要查找的子串）的第一个字符比较：</p><p>若相等，则继续逐个比较后续字符；若不等，从主串的下一个字符起再重新和模式的字符比较。</p><p>（3）在<strong>最好</strong>的情况下，除比较成功的位置外，其余位置仅需比较一次（模式第一个字符），其时间复杂度为：<strong>O(n+m)</strong>(n，m分别为主串和模式的长度)</p><p>（4）但在<strong>最坏</strong>的情况下，如模式为‘00000001’，主串为‘0000000000000000000000000000000001’,则每次模式的前7个0都要与主串逐一比较，因此，其时间复杂度为：<strong>O(n*m)</strong></p><p>2.<strong>KMP算法（时间复杂度O(n+m))</strong></p><p>（1）当一趟匹配过程中出现字符比较不等(失配)时</p><p>–1.不需回溯i指针</p><p>–2.利用已经得到的“部分匹配”的结果</p><p>–3.将模式向右“滑动”尽可能远的一段距离(next[j])后，继续进行比较</p><p>（2）在模式串中第j个字符“失配”时,模式串第k个字符再同主串中对应的失配位置(i)的字符继续进行比较 ：‘p1p2…pk-1’ = ‘pj-k+1pj-k+2…pj-1’</p><p>k值可以在做串的匹配之前，求出一般用next函数求取k值。</p><p>（3）next函数定义为（下标从1开始）：</p><p>–当j=1时next[j] = 0；</p><p>–next[j] = max{k | 0&lt;k&lt;j且‘p1…pk-1’=‘pj-k+1…pj-1’}；(直接等于0~j-1的字符串的最长公共前后缀的长度+1)</p><p>–当其它情况时next[j]=1。</p><p><img src="./../assets/a7bb8cd87669683e21ee0c6045b5b29a.png" alt="img"></p><p>（4）next函数定义为（下标从0开始）：</p><p>–当j=0时next[j] = -1；</p><p>–next[j] = max{k | 0&lt;k&lt;j且‘p0…pk-1’=‘pj-k…pj-1’}；(直接等于0~j-1的字符串的最长公共前后缀的长度)</p><p>–当其它情况时next[j]=0。</p><p><img src="./../assets/9577123652917070830d2fcb363afd76.png" alt="img"></p><p>即寻找当前j前可相互重叠（不完全重叠）的最长真子串的长度。从第一个字符开始的子串的下一个元素的下标，指示出，如果j所指示的模式串的字符与目标串中的当前字符不相等时，j应回退的位置。</p><p><img src="./../assets/eff141823a0bacc009d06798baccd5ac.png" alt="img"></p><p>（5）求next[j]值的算法：</p><p>–1. j的初值为0, next[0]=-1, k=-1</p><p>–2. While(j&lt;模式串长度-1) {</p><p>–(1).若k=-1或者Tj=Tk,则j++,k++,next[j]=k</p><p>–(2).否则,k=next[k]</p><p>}</p><p>这实际上也是一个匹配的过程，不同在于：主串和模式串是同一个串。</p><p>（6）KMP算法：</p><p>–1.令i的初值为pos,j的初值为0</p><p>–2. While((i&lt;主串长度)且(j&lt;模式串长度)) {</p><p>–(1).若j=－1或者si=pj,则i++, j++</p><p>–(2).否则,j=next[j]</p><p>}//j=－1表示第一个字符失配</p><p>（7）时间复杂度：</p><p>KMP()函数的时间复杂度为<strong>O(n)</strong>，为了求模式串的next值,其算法与KMP很相似,其时间复杂度为O(m)，因此,KMP算法的时间复杂度为O(n+m)。</p><p>（8）nextval：</p><p>–1.首先计算next</p><p>–2.比较当前字符t.ch[j]与其next值k所指字符 <a href="http://t.ch">t.ch</a>[k]</p><p>–（1）不等： nextval[j]=next[j]（即维持不变）</p><p>–（2）相等： nextval[j]=nextval[k]</p><p><img src="./../assets/6eded62fff34634d7b295031adc29c58.png" alt="img"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> getnext(string p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k;</span><br><span class="line">    j=<span class="number">0</span>,k=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">0</span>]=-<span class="number">1</span>;<span class="comment">//!</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;p.<span class="keyword">size</span>()-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k==-<span class="number">1</span>||T[j]==T[k])</span><br><span class="line">            <span class="keyword">next</span>[++j]=++k;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k=<span class="keyword">next</span>[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大题题目重点：字符串匹配</strong></p><p><strong>题目</strong>：求串eefegeef的next值。写出计算过程。假设主串为eefeefegeebeefegeeb，写出KMP算法查找串eefegeef的过程。</p><p><img src="./../assets/5cdb8d7fb335cf3a79cf57baf9d6cd65.jpeg" alt="img"></p><h2 id="第五章：数组和广义表">第五章：数组和广义表</h2><h3 id="一、数组的定义">一、数组的定义</h3><p>1.数组</p><p>数组是<strong>相同类型的数据元素</strong>的集合</p><p>数组是一种<strong>定长</strong>的线性表</p><p>数组一般<strong>不作插入和删除</strong>操作</p><p>一旦建立了数组，则结构中的数据<strong>元素个数</strong>和数据<strong>元素之间的关系</strong>就不再发生变动</p><p>判断：“数组的处理比其它复杂的结构要简单”，对吗？</p><p>答：对的。因为——① 数组中各元素具有统一的类型；② 数组元素的下标一般具有固定的上界和下界，即数组一旦被定义，它的维数和维界就不再改变。③数组的基本操作比较简单，除了结构的初始化和销毁之外，只有存取元素和修改元素值的操作。</p><p>2.一维数组</p><p>一维数组是一种简单的定长线性表</p><p>一维数组中的每个数据元素是一个(数)值</p><p>(原子)如：int A[8]={8,7,5,4,6,1,3,2} b=8，有8个数据元素，每个元素都是一个数值</p><p>3.二维数组</p><p>二维数组是这样一个定长线性表，其<strong>每个数据元素</strong>也是一个<strong>定长线性表</strong>(一维数组)</p><p><img src="./../assets/57dd2c37a21026474b0b944e9d5c492d.png" alt="img"></p><p>Amxn= ((a00 a01…a0,n-1), (a10 a11…a1,n-1),…,(am-1,0 …am-1,n-1))</p><p>4.多维数组</p><p>多维数组是这样一个定长线性表，其每个数据元素也是一个定长线性表(降一维)</p><p>如果其数据元素不是一维数组，则其数据元素的每个数据元素也是一个定长线性表</p><p>一直到最后一个定长线性表是一维数组，其每个数据元素为一个(数)值</p><h3 id="二、数组的表示">二、数组的表示</h3><p>1.数组的顺序表示</p><p>顺序存储：数组由相同类型的数据组成，且一般不作插入和删除操作，一般采用顺序存储结构表示数组</p><p>次序约定：<strong>计算机中，存储单元是一维结构</strong>，而数组为多维结构，则用一组连续的存储单元存放数组的数据元素时，有一个次序约定问题</p><p><img src="./../assets/e1980f3ff7be1b49d5d995da6f9d3987.png" alt="img"></p><p>Amxn= ((a00 a01…a0,n-1), (a10 a11…a1,n-1),…,(am-1,0 …am-1,n-1))</p><p>Amxn= ((a00 a10…am-1,0), (a01 a11…am-1,1),…,(a0,n-1 …am-1,n-1))</p><p>（1）行序（m行n列）</p><p>LOC(aij) = LOC(a00) + (i x n + j) x L</p><p>LOC(a00)是二维数组的起始存储地址</p><p>L为每个数据元素占用存储单元的长度(数目)</p><p>Loc(aij)=Loc(a11)+[<strong>(j-1)</strong> +<strong>(i-1)</strong> * n ]*K</p><p>（2）列序（m行n列）</p><p>LOC(aij) = LOC(a00) + (i + j x m) x L</p><p>LOC(a00)是二维数组的起始存储地址</p><p>L为每个数据元素占用存储单元的长度(数目)</p><p>Loc(aij)=Loc(a11)+[<strong>(j-1)</strong> * m+<strong>(i-1)</strong>]*K</p><p><strong>注意：已知二维数组Am,m按行存储的元素地址公式是： Loc(aij)= Loc(a11)+[(i-1) * m+(j-1)]K , 请问按列存储的公式相同吗？</strong></p><p><strong>答：尽管是方阵，但公式仍不同。应为： Loc(aij)=Loc(a11)+[(j-1) * m+(i-1)]K</strong></p><p>2.多维数组的顺序表示</p><p>（1）以行序为主序存储,多(K)维数组元素存储位置</p><p>LOC(aj1,j2,…,jk) = LOC(a00 0) + ((b2xb3x…xbkxj1)+(b3x…xbkxj2)+…+jk) x L</p><p>（2）以列序为主序存储,多(K)维数组元素存储位置</p><p>LOC(aj1,j2,…,jk) = LOC(a00 0) + ((b1xb2x…xbk-1xjk)+(b1x…xbk-2xjk-1)+…+j1)xLp</p><h3 id="三、矩阵的压缩存储">三、矩阵的压缩存储</h3><p>1.矩阵的压缩存储</p><p>（1）如果矩阵中有许多值相同的元素或者零元素(特殊矩阵、稀疏矩阵)，为了节省存储空间，可以对这类矩阵进行压缩存储</p><p>（2）压缩存储：为<strong>多个值相同</strong>的元素只分配<strong>一个</strong>存储空间；对<strong>零</strong>元素<strong>不分配</strong>空间</p><p>2.特殊矩阵</p><p>（1）特殊矩阵：矩阵中，值相同的元素或者零元素的分布有一定规律</p><p>（2）对称矩阵：矩阵中，对角线两边对应位置上元素的值相同(aij=aji)</p><p>（3）三角矩阵：矩阵中，对角线**上(下)<strong>边元素值为常数(或者0)，称</strong>下(上)**三角矩阵</p><p>（4）如果只存储对称矩阵对角线上的值和对角线以上部分的值，则与上三角矩阵存储方法相同；如果只存储对称矩阵对角线上的值和对角线以下部分的值，则与下三角矩阵存储方法相同。</p><p><img src="./../assets/071cd89e8abac33c6a3987de5e1fe6ca.png" alt="img"></p><p>LOC(aij) = LOC(a00) + ((i+1)*i/2+j) *L</p><p>若i&gt;=j，数组元素a[i] [j]在数组B中的存放位置为：1+2+…+i+j=(i+1)*i/2+j</p><p>(i+1)*i/2为前i行元素总数，j为第i行第j个元素前元素个数（因为下标都从0开始）</p><p>若 i &lt; j，数组元素 a[i] [j] 在矩阵的上三角部分, 在数组 B 中没有存放，可以找它的对称元素a[j] [i]：= j *(j +1) / 2 + i (在上则找对称到下)</p><p><img src="./../assets/463fd5089b37496e8ed73e3764832d28.png" alt="img"></p><p>若i &lt;= j，数组元素A[i] [j]在数组B中的存放位置为 n + (n-1) + (n-2) + … + (n-i+1) + j-i=(2*n-i-1) * i/2+j-i</p><p>其中(2*n-i-1) *i/2为前i行元素总数，j-i为第i行第j个元素前元素个数</p><p>若i &gt; j，数组元素A[i] [j]在矩阵的下三角部分，在数组 B 中没有存放。因此，找它的对称元素A[j] [i]。 A[j] [i]在数组 B 的第 (2*n-j-1) * j / 2 + i 的位置中找到。</p><p>3.稀疏矩阵</p><p>（1）稀疏矩阵：矩阵中有许多值相同的元素或者零元素，而且分布没有任何规律</p><p>假设在mxn的矩阵中，有t个非零元素，令：</p><p>δ= t /(m x n)</p><p>如果稀疏因子δ≤0.05，则称该矩阵为稀疏矩阵</p><p>（2）用三元组存储稀疏矩阵中的非零元素</p><p>三元组(i,j,aij)表示矩阵中i行、j列位置的值为aij</p><p><img src="./../assets/8ea5fb68ee91da2e2dbf1833ce003490.png" alt="img"></p><p>（3）转置</p><p>设矩阵列数为m，对矩阵三元组表扫描m次</p><p>第k次扫描，找寻所有列号为k的项</p><p>将其行号变列号、列号变行号，顺次存于转置矩阵三元组表中</p><p><img src="./../assets/556b73736783266e0ba02a137c255653.png" alt="img"></p><h3 id="四、广义表">四、广义表</h3><p>1.广义表的定义</p><p>（1）广义表：由n(≥0)个表元素组成的<strong>有限序列</strong>：</p><p>LS = (a0, a1, a2, …, an-1)</p><p>（2）LS是广义表的名称</p><p>（3）ai是广义表的元素，既可以是表(称为子表)，也可以是数据元素(称为原子)</p><p>（4）n为广义表的长度(n=0的广义表为空表)</p><p>2.广义表的举例</p><p>A=( ); //表A是一个空表</p><p>B=(e); //表B有一个原子</p><p>C=(a,(b,c,d)); //两个元素，分别为原子a和子表(b,c,d)</p><p>D=(A,B,C); //有三个元素均为列表</p><p>E=(a,E); //递归的列表</p><p>其中，“表”以及“列表”，均指广义表</p><p>3.广义表的存储</p><p>广义表一般采用链式存储结构</p><p>表结点[Tag=1|hp|tp]；原子结点[Tag=0|atom]；hp表示表头，tp表示表尾</p><p><img src="./../assets/fbd17a823db129904dbdde90f0366d97.png" alt="img"></p><p>4.广义表的表头</p><p>表头(head)：广义表的第一个<strong>元素</strong></p><p>表头既可以是原子，也可以是列表(广义表)</p><p>GetHead(B) = e；GetHead(D) = A；GetHead((B,C)) = B</p><p>5.广义表的表尾</p><p>表尾(tail)：广义表中，<strong>除表头外的部分</strong></p><p><em><strong>注意：表尾一定是列表，要加括号！</strong></em></p><p>GetTail(B) = ()；GetTail(D) = (B,C)；GetTail((B,C)) = ©</p><ul><li>GetTail【(b, k, p, h)】＝ （k,p,h） ;</li><li>GetHead【( (a,b), (c,d) )】＝ （a,b） ;</li><li>GetTail【( (a,b), (c,d) )】＝（(c,d)） ;</li><li>GetTail【 GetHead【((a,b),(c,d))】】＝（b）;</li><li>GetTail【（e）】＝（）;</li><li>GetHead 【 ( ( ) )】＝（）；</li><li>GetTail【 ( ( ) ) 】＝ （）；</li></ul><h2 id="第六章：树与二叉树">第六章：树与二叉树</h2><h3 id="一、树的概念与基本术语">一、树的概念与基本术语</h3><p>1.树的定义(Tree)</p><p>（1）树是有n(n≥0)个结点的<strong>有限</strong>集合。</p><p>（2）如果 n=0，称为空树；</p><p>（3）如果 n&gt;0,称为非空树,对于非空树,<strong>有且仅有一个</strong>特定的称为根(Root)的节点(无直接前驱)</p><p>（4）如果 n&gt;1，则除根以外的其它结点划分为 m (m&gt;0)个互不相交的有限集 T1, T2 ,…, Tm，其中<strong>每个集合本身又是一棵树</strong>，并且称为<strong>根的子树</strong>(SubTree)。(此为递归定义)</p><p>（5）每个结点都有<strong>唯一的直接前驱</strong>，但可能有<strong>多个后继</strong>。</p><p>2.树的基本术语</p><p>（1）<strong>结点</strong>：包含一个<strong>数据元素及</strong>若干指向其子树的<strong>分支</strong>；（包括分支！）</p><p>（2）结点的<strong>度</strong>：结点拥有的<strong>子树数</strong>；结点的<strong>深度</strong>是从根结点开始<strong>自顶向下</strong>逐层累加；结点的<strong>高度</strong>是从叶节点开始<strong>自底向上</strong>逐层累加。</p><p>（3）<strong>叶</strong>结点：<strong>度为0</strong>的结点[没有子树的结点] (终端结点 )</p><p>（4）<strong>分支</strong>结点：<strong>度不为0</strong>的结点[包括根结点]，也称为<strong>非终端结点</strong>。除根外称为内部结点。</p><p><em><strong>注意：除根之外都是内部结点！</strong></em></p><p>（5）孩子：结点的子树的根[<strong>直接</strong>后继，可能有多个]</p><p>（6）双亲：孩子的<strong>直接</strong>前驱[最多只能有一个]</p><p>（7）兄弟：同一双亲的孩子</p><p>（8）子孙：以某结点为根的树中的<strong>所有结点</strong></p><p>（9）祖先：从根到该结点所经分支上的<strong>所有结点</strong></p><p>（10）层次：<strong>根结点为第一层</strong>，其孩子为第二层，依此类推</p><p>（11）深度：树中结点的最大层次（从根算第一层），也为树的高度。</p><p>（12）有序树：子树之间存在确定的次序关系。</p><p>（13）无序树：子树之间不存在确定的次序关系。</p><p>（14）森林：<strong>互不相交</strong>的树的集合。对树中每个结点而言，其子树的集合即为森林。<strong>任何一棵非空树是一个二元组</strong> Tree = （root，F）其中：root 被称为根结点 ，F 被称为子树森林。</p><p>3.树型结构与线性结构的区别在于：一个元素可以有<strong>多个后继</strong>。</p><p>4.树的相关性质：</p><p>（1）树中的结点数等于所有结点的度数加一</p><p>（2）度为m的树中第i层上至多有m^(i-1)个结点</p><p>（3）高度为h的m叉树至多有(m^h-1)/(m-1)个结点</p><p>（4）具有n个结点的m叉树的最小高度为logm(n(m-1)+1)</p><h3 id="二、二叉树">二、二叉树</h3><p>1.二叉树是一种特殊的树，每个结点<strong>最多</strong>有<strong>2棵子树</strong>，子树有左右之分。</p><p>2.在二叉树的<strong>第i层</strong>上最多有**2^(i-1)**个结点。</p><p>3.<strong>深度为k</strong>的二叉树最多有<strong>2^k-1</strong>个结点。</p><p>4.如果二叉树终端结点数为n0(也为叶子结点数),度为2的结点数为n2,则<strong>n0=n2+1</strong></p><h3 id="三、满二叉树">三、满二叉树</h3><p>1.一个<strong>深度为k且有2^k-1个结点</strong>的二叉树。</p><p>2.每层上的结点数都是最大数。</p><p>3.可以自上而下、自左至右连续编号。</p><h3 id="四、完全二叉树">四、完全二叉树</h3><p>1.当且仅当<strong>每一个结点</strong>都与<strong>深度相同的满二叉树中编号从1到n的结点一一对应</strong>的二叉树。</p><p>2.叶子结点只在最大两层上出现。</p><p>3.左子树深度与右子树深度<strong>相等或大１</strong>。</p><p>4.具有<strong>n个结点</strong>的完全二叉树,其深度为<strong>floor(log2(n)) +1</strong></p><p>5.在完全二叉树中，结点i的双亲为 <strong>i/2</strong>;</p><p>结点i的左孩子LCHILD(i)=<strong>2i</strong>;</p><p>结点i的右孩子RCHILD(i)=<strong>2i+1</strong>.</p><h3 id="五、二叉树的顺序存储结构">五、二叉树的顺序存储结构</h3><p>1.用一组连续的存储单元依次<strong>自上而下,自左至右</strong>存储结点。</p><p><img src="./../assets/656470a8d16c33b20e5602d8d230b148.png" alt="img"></p><h3 id="六、二叉树的链式存储结构">六、二叉树的链式存储结构</h3><p>1.二叉链表：二叉链表结点由一个数据域和两个指针域组成，采用数据域加上左、右孩子指针。</p><p><img src="./../assets/71d85e351ec79c63300125079ef06c0a.png" alt="img"></p><p>2.三叉链表：采用数据域加上左、右孩子指针及双亲指针。</p><p><img src="./../assets/53d66d8bd69370e1df1575328bc86df1.png" alt="img"></p><h3 id="七、遍历二叉树">七、遍历二叉树</h3><p>1.遍历二叉树：树的遍历就是按某种次序访问树中的结点，要求每个结点访问一次且仅访问一次（<strong>非线性结构线性化</strong>）。</p><p>2.一个二叉树由根节点与左子树和右子树组成，设访问根结点用D表示，遍历左、右子树用L、R表示，如果规定先左子树后右子树，则共有三种组合</p><p>（1）DLR [先序遍历]</p><p>（2）LDR [中序遍历]</p><p>（3）LRD [后序遍历]</p><p><img src="./../assets/18ab07f635c22b73c124fdf7d5b597af.png" alt="img"></p><h3 id="八、线索二叉树">八、线索二叉树</h3><p>1.利用空指针</p><p>（1）在有<strong>n个</strong>结点的二叉树中，必定存在<strong>n+1个</strong>空链域；</p><p>（2）因为<strong>每个结点有两个链域</strong>（左、右孩子指针），因此共有<strong>2n</strong>个链域；</p><p>（3）除根结点外，每个结点都有且仅有一个分支相连，即<strong>n-1个</strong>链域被使用。</p><p><img src="./../assets/114e01c162ea71094f42200231084a02.png" alt="img"></p><h3 id="十、树与森林">十、树与森林</h3><p>1.树的存储结构</p><p>（1）双亲表示法：采用一组连续的存储空间；由于每个结点只有一个双亲，只需要一个指针。</p><p><img src="./../assets/14534fe942e56381de7a12ec1b1fad8a.png" alt="img"></p><p>（2）孩子表示法：可以采用多重链表，即每个结点有多个指针，最大缺点是空链域太多[(d-1)n+1个]。将每个结点的孩子排列起来，用单链表表示；将每个结点排列成一个线性表。</p><p><img src="./../assets/e48970eaff818db8ba39af07ad1da42d.png" alt="img"></p><p>（3）孩子兄弟表示法（常用）：采用<strong>二叉链表</strong>左边指针指向第一个孩子，右边指针指向兄弟。</p><p><img src="./../assets/8534f045d3416d9f80456e392b98a81c.png" alt="img"></p><p>2.树与二叉树的对于关系</p><p>（1）树与二叉树都可以采用二叉链表作存储结构。</p><p>（2）任意给定一棵<strong>树</strong>，可以找到一个<strong>唯一的二叉树(没有右子树)</strong>。</p><p><img src="./../assets/e59356587a1801aae6c1ac38588d5e37.png" alt="img"><img src="./../assets/d8f5145c4fd5a4606ecb16653b7d7281.png" alt="img"></p><p>3.森林与二叉树的对应关系</p><p><img src="./../assets/fbe8c5e22651b6cdb5b93f224c528875.png" alt="img"></p><p>4.树的遍历：</p><p>（1）先根（次序）遍历（树的先根-----二叉树的先序）</p><p><img src="./../assets/17cfdc5def54dadd0bb73b28512a9adb.png" alt="img"></p><p>（2）后根（次序）遍历（树的后根-----二叉树的中序）</p><p><img src="./../assets/63e5036c2fcce2ebe01fa2615b36c67c.png" alt="img"></p><p>5.森林的遍历：</p><p>（1）先序遍历：<strong>依次从左至右</strong>对森林中的每一棵树进行<strong>先根</strong>遍历。</p><p>（2）中序遍历：<strong>依次从左至右</strong>对森林中的每一棵树进行<strong>后根</strong>遍历。</p><p><img src="./../assets/bad0cef11a7be064726b0848ea787ab2.png" alt="img"></p><h3 id="十一、赫夫曼树及其应用">十一、赫夫曼树及其应用</h3><p>1.最优二叉树</p><p>（1）路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径</p><p>（2）路径长度：路径上的<strong>分支数目</strong></p><p>（3）<strong>树的路径长度</strong>：从树根到<strong>每个结点</strong>的路径长度之和</p><p>（4）<strong>结点</strong>的<strong>带权路径长度</strong>：从结点到树根之间的<strong>路径长度</strong>与结点上<strong>权</strong>的乘积</p><p>（5）<strong>树的带权路径长度(WPL)</strong>：树中<strong>所有叶子结点</strong>的<strong>带权路径长度之和</strong>（是<strong>叶子</strong>结点！）</p><p>（6）<strong>最优</strong>二叉树：假设二叉树有n个叶子，其每个叶子结点带权wi，则带权路径长度<strong>WPL最小</strong>的二叉树称为最优二叉树</p><p>（7）赫夫曼(Huffman)树就是一棵最优二叉树</p><p>2.赫夫曼树</p><p>（1）在Huffman树中，权值最<strong>大</strong>的结点离根最<strong>近</strong>；权值最<strong>小</strong>的结点离根最<strong>远</strong>。</p><p>（2）构建算法：</p><p>—1.根据给定的n个权值(w1, w2, …, wn)构成n棵二叉树的集合F={T1, T2, …, Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，左右子树为空。</p><p>—2.在F中选取两棵根结点的<strong>权值最小</strong>的树作为左右子树构造一棵新的二叉树，且置其根结点的权值为其左右子树根结点的权值之和。</p><p>—3.在F中删除这两棵树，同时将新得到的二叉树加入F中。</p><p>—4.重复2, 3，直到F只含一棵树为止。</p><p><img src="./../assets/1c2c12147af6f73def5faa3dbb57796d.png" alt="img"></p><p><em><strong>注意：画图时每一次要把所有点都画出来！</strong></em></p><p>（3）编码算法：（从叶子开始！）</p><p>—1.从Huffman树的<strong>每一个叶子结点</strong>开始</p><p>—2、依次沿结点到根的路径，判断该结点是父亲结点的左孩子还是右孩子，如果是<strong>左孩子则得到编码‘0’，否则得到编码‘1’</strong>，先得到的编码放在后面</p><p>----3、直到到达根结点，编码序列即为该叶子结点对应的Huffman编码</p><p>（4）译码算法：</p><p>—1.指针指向Huffman树的<strong>根结点</strong>，取第一个Huffman码</p><p>—2、如果Huffman码为‘0’，将指针指向当前结点的左子树的根结点；如果Huffman码为‘1’，将指针指向当前结点的右子树的根结点</p><p>—3、如果指针指向的当前结点为叶子结点，则输出叶子结点对应的字符；否则，取下一个Huffman码，并返回2</p><p>—4、如果Huffman码序列未结束，则返回1继续译码</p><p><strong>题目：</strong>（4）设给出一段报文：GOOD_GOOD_GOOD_GOOOOOOOO_OFF字符集合是 { O, G, _, D, F}，各个字符出现的频度(次数)是 W＝{ 15, 4, 4, 3, 2}。</p><p>若给每个字符以等长编码 O: 000 G: 001 _: 010 D: 011 F: 100</p><p>则总编码长度为 (15+4+4+3+2) * 3 = 84.</p><p>若按各个字符出现的概率不同而给予不等长编码，可望减少总编码长度。</p><p>各字符{ O, G, _, D, F }出现概率为</p><p>{ 15/28, 4/28, 4/28, 3/28, 2/28 },<strong>化整</strong>为 { 15, 4, 4, 3, 2 }</p><p>令左孩子分支为编码‘0’，右孩子分支为编码‘1’将根结点到叶子结点路径上的分支编码，组合起来，作为该字符的Huffman码，则可得到：</p><p><img src="./../assets/bed5089b63111fc7b2651629600dbdb9.png" alt="img"></p><p>O:1 _:011 G:010 D:001 F:000</p><p>则总编码长度为 15*1+(2+3+4+4) *3 = 54 &lt; 84</p><p><strong>Huffman是一种前缀编码</strong>，解码时不会混淆</p><p>如GOOD编码为：01011001</p><p>如Huffman编码序列01011001，译码后的字符串为GOOD</p><p>（5）<strong>前缀编码</strong>：指的是，任何<strong>一个字符的编码</strong>都<strong>不是同一字符集中另一个字符</strong>的编码的<strong>前缀</strong>。利用赫夫曼树可以构造一种不等长的二进制编码，并且构造所得的赫夫曼编码是一种最优前缀编码，即使所传电文的总长度最短。</p><p><strong>题目</strong>：（1）设有字符集{A, B, C, D}，各字符在电文中出现的次数集为{1, 3, 5, 7}，则哈夫曼树构造过程如下图所示：</p><p><img src="./../assets/ac00597aff82726c37d09a46419e1f6c.png" alt="img"></p><p><img src="./../assets/3ccd86622ea5cdeb3d5756a855a900ba.png" alt="img"></p><p>（最终哈夫曼树的构造结果如上，一定要记得写结果！）</p><p><img src="./../assets/ed524901d81ea79326dffdce275fe4f8.png" alt="img"></p><p>（2）已知一颗完全二叉树第7层有20个结点，则整棵树的结点数？</p><p>83</p><p>（3）在二叉树中，指针p指向的结点是叶子，则p满足条件？</p><p>p-&gt;leftChild==NULL&amp;&amp;p-&gt;rightChild==NULL</p><p>（4）由3个结点组成的二叉树最多有多少种形态？</p><p>5</p><p>（5）已知一棵完全二叉树有100个结点，根节点编号为1，按层次遍历编号，则结点45的父亲编号为？结点50的孩子编号情况如何？</p><p>22;100,101</p><h2 id="第七章：图">第七章：图</h2><h3 id="一、图的定义与术语">一、图的定义与术语</h3><p>1.图是由顶点集合(vertex)及顶点间的关系集合组成的一种数据结构： Graph＝( V, E )</p><p>其中V = {x | x属于数据对象}是顶点的有穷非空集合</p><p>E是顶点之间关系的有穷集合，包括E1 = {(x, y) | x, y 属于 V } 边的集合或E2 = {&lt;x, y&gt; | x, y 属于 V } 弧的集合</p><p><em><strong>注意：在一个图中，所有顶点的度数之和等于边数的2倍！</strong></em></p><p>2.无向图（无向图的邻接矩阵是对称矩阵）</p><p>用(x,y)表示两个顶点x,y之间的一条边(edge)N={V,E}，V={0,1,2,3,4,5}，E={(0,1), (0,4), (0,5), (1,2), (1,3), (1,5), (2,3), (3,4), (3,5), (4,5)}</p><p>（1）邻接点：如果(x,y)属于E,称x,y互为邻接点，即x,y相邻接</p><p>（2）依附：边(x,y)依附于顶点x,y</p><p>（3）相关联：边(x,y)与x,y相关联</p><p>（4）顶点的度：和顶点相关联的边的数目，记为TD(x)</p><p>3.无向图（完全图）：如果无向图有<strong>n(n-1)/2</strong>条边，则称为<strong>无向完全图</strong>。</p><p>4.有向图</p><p>用&lt;x,y&gt;表示从x到y的一条弧(Arc)，且称x为弧尾，y为弧头，N={V,E}，V={0,1,2,3,4}，E={&lt;0,1&gt;，&lt;0,3&gt;，&lt;0,4&gt;，&lt;1,2&gt;，&lt;2,4&gt;，&lt;3,2&gt; }</p><p>（1）邻接：如果&lt;x,y&gt;属于E,称x邻接到y,或y邻接</p><p>（2）自x相关联：弧&lt;x,y&gt;与x,y相关联</p><p>（3）入度：以顶点为头的弧的 数目，记为ID(x)</p><p>（4）出度：以顶点为尾的弧的 数目，记为OD(x)</p><p>（5）度：TD(x)=ID(x)+OD(x)</p><p>4.有向图（完全图）：如果有向图有n(n-1)条边，则称为有向完全图。</p><p>5.路径：是一个从顶点x到y的顶点序列(x, vi1, vi2,…, vin, y)其中，(x,vi1),(vij-1,vij),(vin,y)皆属于E。</p><p>6.回路：</p><p>（1）回路或环：路径的开始顶点与最后一个顶点相同，即路径中(x, vi1, vi2,…, vin, y)，x=y</p><p>（2）简单路径：路径的顶点序列中，<strong>顶点不重复</strong>出现</p><p>7.连通：</p><p>（1）连通：如果顶点x到y有路径，称x和y是连通的</p><p>（2）连通图：图中所有顶点都连通</p><p>8.子图：</p><p>设有两个图 G＝(V, E) 和 G’＝(V’, E’)。</p><p>若 V’包含于 V 且 E’包含于E, 称图G’是图G的子图</p><p>9.生成树</p><p>一个连通图的生成树是一个<strong>极小连通子</strong>图，它含图中全部n个顶点，但只有足以构成一棵树的<strong>n-1</strong>条边。</p><h3 id="二、图的存储结构">二、图的存储结构</h3><p>图的存储结构有4种：邻接矩阵，邻接表，十字链表（有向），邻接多重表（无向）</p><p>1.邻接矩阵</p><p>（1）邻接矩阵：记录图中各顶点之间关系的二维数组。</p><p>（2）对于不带权的图，以1表示两顶点存在边(或弧)(相邻接)，以0表示两顶点不邻接，即 如果(i,j)属于E 或 &lt;i,j&gt;属于E，A[ i ] [ j ] =1 否则等于0。</p><p>（3）无向图的邻接矩阵为对称矩。</p><p>（4）其第i行1的个数等于顶点i的出度OD(i)，第j列1的个数等于顶点j的入度ID(j)。</p><p>2.邻接矩阵（网络）</p><p>在网络中，两个顶点如果不邻接，则被视为距离为无穷大；如果邻接，则两个顶点之间存在一个距离值(即权值)，即如果(i,j)属于E 或 &lt;i,j&gt;属于E，A[ i ] [ j ] =wi,j 否则等于<strong>∞</strong>。</p><p><img src="./../assets/d93f3d11bdb4c58ce33ea1094c7a74e5.png" alt="img"></p><p>3.邻接表</p><p>（1）邻接表是图的一种<strong>链式</strong>存储结构。</p><p>（2）在邻接表中，每个顶点设置一个单链表，其<strong>每个结点都是依附于该顶点</strong>的边（或以该顶点为尾的弧）。</p><p><img src="./../assets/383520efc5c6bba4ae4bf9884a2d4425.png" alt="img"></p><p>无向图中，注意左侧的表格数组！</p><p><img src="./../assets/4f58f13bd0f18a35c444508e63cb4784.png" alt="img"></p><p>（邻接表（有向网络））</p><p>（3）在一个<strong>无向图的邻接表</strong>表示中，每个顶点对应一个链表，链表中包含该顶点相邻的其他顶点。每条边在邻接表中对应两个链表结点，因为无向图的边是双向的。给定图包含 10 个顶点和 20 条边，那么每个顶点的平均度数是 2×边数/顶点数=4。</p><p><strong>由于每个链表结点对应一条边，总的链表结点数是 2×边数</strong>。所以，邻接表包含 2×20=40 个链表结点。</p><p><em><strong>注意：n个结点，e条边的无向图邻接表中，有n个头结点和2e个表结点</strong></em></p><p>（4）在有向图的邻接表中<strong>不易找到指向该顶点的弧</strong>。</p><p>（5）对于有向图的邻接表，其第i个链表中结点的个数只是该顶点的出度；如果要计算入度，必须遍历整个邻接表[也可以建立一个逆邻接表]要判定两个顶点i和j是否有边（或弧），必须搜索整个第i个和第j个链表，不及邻接矩阵方便。</p><p>在有向图的逆邻接表找每个结点入度：</p><p><img src="./../assets/c5d0d6be7909f29e3e22c4e864a0f801.png" alt="img"></p><p>（5）无向邻接表所需存储空间O(|V|+2|E|)，有向邻接表所需存储空间O(|V|+|E|)</p><p>（6）对于稀疏图，采用邻接表能极大节省空间。</p><p>4.十字链表（有向图！）</p><p>（1）十字链表是<strong>有向图</strong>的另一种存储结构</p><p>（2）十字链表是将有向图的邻接表和逆邻接表结合起来的一种存储结构</p><p><img src="./../assets/868cb857d23f81b231662163e8fb5816.png" alt="img"></p><p><img src="./../assets/d67f3dd68092a3c19c8295039057e985.png" alt="img"></p><p>绿色代表：相同弧尾（邻接表）</p><p>红色代表：相同弧头（逆邻接表）</p><p>5.邻接多重表（无向图！）</p><p>（1）邻接多重表是<strong>无向图</strong>的另一种存储结构</p><p>（2）在无向图中，一条边要用2个结点表示(分别从2个顶点的角度看)</p><p>（3）在邻接多重表中，<strong>一条边只用一个结点</strong>表示</p><p>（4）将所有具有某顶点的结点，全部用链连结起来，链所在的域为该顶点对应的指针域</p><p><img src="./../assets/408ad7415c9875ee908456fced546e95.png" alt="img"></p><h3 id="img"><img src="./../assets/0016dd515a022fdf2ce4174f3adf52e0.png" alt="img"></h3><h3 id="三、图的遍历">三、图的遍历</h3><p>1.从图的某一顶点开始，访遍图中其余顶点，且使<strong>每一个顶点仅被访问一次</strong></p><p>2.图的遍历主要应用于<strong>无向图</strong></p><p>3.深度优先搜索DFS</p><p>（1）图的深度优先搜索是<strong>树的先根遍历</strong>的推广</p><p>（2）图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。</p><p>（3）为了避免重复访问，可设置一个标志顶点是否被访问过的辅助数组 visited [ ]</p><p>（4）算法：</p><p>所有顶点访问标志visited[]设置为FALSE</p><p>从某顶点v0开始，设v=v0</p><p>–1.如果visited[v]=FALSE，则访问该顶点，且设visited[v]=TRUE</p><p>–2.如果找到当前顶点的一个新的相邻顶点w,设v=w,重复1</p><p>–3.否则(说明当前顶点的所有相邻顶点都已被访问过，或者当前顶点没有相邻顶点)，如果当前顶点是v0，退出；否则返回上一级顶点，重复2</p><p>（5）<strong>存储结构未定，则遍历顺序不确定</strong>。</p><p><img src="./../assets/4cf9c9a96cca249a714f2697756b73ec.png" alt="img"></p><p>4.广度优先搜索（BFS）</p><p>（1）广度优先搜索(BFS)是一种分层搜索方法</p><p>（2）BFS每向前走一步可能访问一批顶点, 不存在往回退的情况</p><p>（3）BFS不是一个递归的过程。</p><p>（4）算法：</p><p>所有顶点访问标志visited[]设置为FALSE</p><p>从某顶点v0开始，访问v0，visited[v0]=TRUE，将v0插入队列Q</p><p>–1.如果队列Q不空，则从队列Q头上取出一个顶点v,否则结束</p><p>–2.依次找到顶点v的所有相邻顶点v’，如果visited[v’]=FALSE，访问该顶点v’，visited[v’]=TRUE，将v’插入队列Q</p><p>–3.重复1,2</p><p>5.结论</p><p>（1）如果图为<strong>连通图</strong>，则从该图的任意一个顶点开始执行一次深度优先遍历或广度优先遍历，即可访问该连通图的所有顶点。</p><p>（2）如果图为非连通图，则<strong>依次从未访问过的顶点</strong>开始执行深度优先遍历或广度优先遍历，直至所有的顶点均被访问。</p><p>（3）事实上执行一次深度优先可以遍历一个连通分支。<strong>图有多少个连通分支，就调用多少次深度优先遍历。</strong></p><p>6.时间复杂度</p><p>（1）可以看出无论是深度优先遍历还是广度优先遍历,其实质都是透过边或弧找邻接点的过程,只是访问的顺序不同。</p><p>（2）两者的时间复杂度相同，<strong>取决于采取的存储结构</strong>，若用<strong>邻接矩阵为O(N^2)</strong>,若 用<strong>邻接表则为O(N+E) 即O(n)</strong>。</p><p>注意：深度优先搜索遍历类似于树的先根遍历，广度优先搜索遍历类似于树的层次遍历。</p><p>**题目：**假设用邻接表存储，下图中边上序号表示边输入顺序(链表头插入)，画出该图邻接表，写出用该邻接表存储时其深度优先顺序和广度优先顺序。</p><p><img src="./../assets/469bd9200a84d1d1b72c67f54b0522fc.jpeg" alt="img"></p><h3 id="四、图的连通性问题">四、图的连通性问题</h3><p>1.无向图的连通性</p><p>如果无向图中，存在不连通的顶点，则该图称为非连通图。</p><p>2.无向图的连通分量</p><p>（1）<strong>非</strong>连通图的<strong>极大连通子图</strong>叫做<strong>连通分量</strong>。</p><p>（2）若从无向图的每一个连通分量中的一个顶点出发进行DFS或BFS遍历，可求得无向图的所有连通分量的生成树(DFS或BFS生成树)。</p><p>（3）所有连通分量的生成树组成了非连通图的生成森林。</p><p>（4）连通分量是无向图的极大连通子图，其中极大的含义是将依附于连通分量中顶点的所有边都加上，所以连通分量中可能存在回路。</p><p>（5）<strong>生成树是一个连通图的极小连通子图</strong>，包含连通图的所有顶点，且使其连通的边数最少。</p><p>（6）<strong>极大连通子图是无向图（不一定连通）的连通分量</strong>。极小连通子图是连通无向图的生成树。</p><p>（7）<strong>任何连通图的连通分量只有一个，即使其自身</strong>。</p><p>3.无向图的生成树</p><p>（1）由DFS遍历，求得连通分量称为DFS生成树</p><p>（2）由BFS遍历，求得连通分量称为BFS生成树</p><p>4.有向图的强连通分量</p><p>强连通图是指在有向图中，对于每一对不同的顶点u和v，都存在从u到v及v到u的路径，n个顶点用弧向同一方向连接形成一个环时，就是强连通图，需要弧最少。</p><p>（1）深度优先搜索算法是求有向图的强连通分量的有效方法。</p><p>（2）在有向图G上，从某个顶点出发沿该顶点为尾的弧进行深度优先搜索，并按其所有邻接点的搜索都完成（即退出dfs函数）的顺序将顶点排列起来。</p><p>（3） 在有向图G上，从最后搜索的顶点出发，沿着以该顶点为头的弧作逆向的深度优先搜索遍历。若此次遍历不能访问到有向图中的所有顶点，则从余下顶点中最后完成搜索的顶点出发继续进行逆向的深度优先搜索遍历。</p><p>（4）每次调用dfs作逆向深度优先遍历所访问到的顶点集便是有向图G中的一个强连通分量的顶点集。</p><p>（5）为了实现以上遍历，需要对深度优先遍历算法作以下修改</p><p>–1.在进入DFStraverse函数时，对计数变量count进行初始化，count=0</p><p>–2.在退出DFS函数之前，将完成搜索的顶点号记录在另一个辅助数组finish【vernum】中，在DFS函数结束之前加上finished【++count】=v</p><p>5.最小生成树</p><p>（1）如果无向图中，边上有权值，则称该无向图为无向网</p><p>（2）如果无向网中的每个顶点都相通，称为连通网</p><p>（3）最小生成树(Minimum Cost Spanning Tree)是代价最小的连通网的生成树，即该<strong>生成树上的边的权值和最小</strong></p><p>（4）准则：必须使用且仅使用连通网中的<strong>n-1</strong>条边来联结网络中的n个顶点；不能使用产生回路的边；各边上的权值的总和达到最小。常用于道路建设、线路铺设等应用中计算成本。</p><p>6.Prim普里姆算法生成最小生成树</p><p>（1）假设N=(V,E)是连通网</p><p>（2）TE是N上最小生成树中边的集合</p><p>–1.U={u0}，(u0属于V), TE={}</p><p>–2.在所有u属于U,v属于V-U的边(u,v)属于E中找一条代价最小的边(u,v0)并入集合TE，同时v0并入U</p><p>–3.重复2，直到U=V。T=(V，TE)即为所求最小生成树。</p><p><img src="./../assets/4f70445cd5f97fdabec9d530d18dae14.png" alt="img"></p><p>（记得每一次画上所有点！）</p><p><img src="./../assets/f070197a7eb9641b7b362a26b542ad99.png" alt="img"></p><p>（Prim V1-Vn mindis flag U)</p><p>（3）在生成树的构造过程中，图中 n 个顶点分属两个集合：已落在生成树上的顶点集 U 和尚未落在生成树上的顶点集V-U，应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边逐渐加入TE,相应顶点加入U中。</p><p>7.Kruscal克鲁斯卡尔算法生成最小生成树</p><p>（1）假设N=(V,E)是连通网</p><p>–1.非连通图T={V,{}}，图中每个顶点自成一个连通分量</p><p>–2.在E中找一条代价最小，且其两个顶点分别依附不同的连通分量的边，将其加入T中</p><p>–3.重复2，直到T中所有顶点都在同一连通分量上</p><p><img src="./../assets/60ad49f5dc33ad7e92983ebf47214a6f.png" alt="img"></p><p>（2）把边按照从小到大的顺序排序；</p><p>判断边的顶点不在同一个联通分支-》并查集。</p><p>8.生成最小生成树：</p><p>当为稠密图（邻接矩阵）prim算法 O(n^2)</p><p>当为稀疏图（邻接表）Kruscal算法O(eloge)</p><p><img src="./../assets/ad079dbda9a728b7e8a6266668cf7d2c.png" alt="img"></p><h3 id="五、最短路径">五、最短路径</h3><p>1.最短路径</p><p>（1）最短路径是求从图（或网）中某一顶点，到其余各顶点的最短路径</p><p>（2）最短路径与最小生成树主要有三点不同：</p><p>–1.最短路径的操作对象主要是有向图(网)，而最小生成树的操作对象是无向图</p><p>–2.最短路径有一个始点，最小生成树没有（Prim算法有起点）</p><p>–3.最短路径关心的是始点到每个顶点的路径最短，而最小生成树关心的是整个树的代价最小</p><p>2.基本概念</p><p>（1）路径长度:一条路径上所经过的<strong>边的数目</strong></p><p>（2）带权路径长度:路径上<strong>所经过边的权值之和</strong></p><p>（跟树的带权路径长度区分好！）</p><p>（3）最短路径:(带权)路径长度(值)最小的那条路径</p><p>（4）最短路径长度或最短距离:最短路径长度</p><p>3.Dijkstra算法(O(n^3))</p><p>（1）Dijkstra算法思想：采用按<strong>路径长度递增</strong>的次序产生最短路径</p><p>–1.设置两个顶点的集合U和T，集合U中存放已找到最短路径的顶点，集合T中存放当前还未找到最短路径的顶点。</p><p>–2.初始状态时，集合U中只包含源点，设为v0；</p><p>–3.然后从集合T中选择到源点v0路径长度最短的顶点u加入到集合U中；</p><p>–4.集合U中每加入一个新的顶点u都要修改源点v0到集合T中剩余顶点的当前最短路径长度值，集合T中各顶点的新的当前最短路径长度值，为原来的当前最短路径长度值与从源点过顶点u到达该顶点的路径长度中的较小者。</p><p>–5.转到3，此过程不断重复，直到集合T中的顶点全部加入到集合U中为止。</p><p>（2）在Dijkstra算法中，引进了一个<strong>辅助向量D</strong></p><p>每个分量D[i]表示当前所找到的从始点到每个终点vi的最短路径长度。</p><p>D[i]初值为始点v0到各终点vi的直接距离，即若从始点到某终点有(出)弧，则为弧上的权值，否则为∞。</p><p>（3）得到路径：</p><p>–1.设置另一个辅助向量path[]，用来存放得到的从源点v0到其余各顶点的最短路径上到达目标顶点的前一顶点下标。</p><p>–2.为每一个顶点i设置辅助向量path<a href="https://blog.csdn.net/gyeolhada/article/details/135513487?ops_request_misc=%7B%22request%5Fid%22%3A%22172193217416800227432269%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=172193217416800227432269&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-135513487-null-null.142%5Ev100%5Epc_search_result_base6&amp;utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0#">i</a>，用来存放得到的从源点v0到该顶点的最短路径中依次访问过的顶点。第一个值是路径上的顶点数。</p><p>**题目：**对下图求从V0出发到各顶点的最短路径。</p><p><img src="./../assets/3a54777867e8f7fbae29f16b34f66b3d.png" alt="img"></p><p><img src="./../assets/f8a7036d84c09217468d3af882f4ccad.png" alt="img"></p><p>（最后的过程5“无”一定要加，且要补充最后最短路径的结果!)</p><p>4.求n个顶点之间的最短路径</p><p>（1）用Dijkstra算法也可以求得有向图G=(V，E)中每一对顶点间的最短路径。</p><p>方法是： 设置二维数组D [i] [j]，数组每一行D[i]表示从顶点vi出发到其它顶点的最短路径，即每次以一个不同的顶点vi为源点重复Dijkstra算法便可求得每一对顶点间的最短路径，<strong>时间复杂度是O(n^3)</strong> 。</p><p>（2）<strong>弗罗伊德(Floyd)算法，其时间复杂度仍是O(n^3)</strong> ， 但算法形式更为简明，步骤更为简单，数据结构是基于图的邻接矩阵。</p><p><img src="./../assets/ffa174a05f2bcade597ccdb74e9735d6.png" alt="img"></p><p>将图中一个顶点Vk 加入到S中，修改A[i] [j]的值，修改方法是：</p><p><strong>A[i] [j] = Min{ A[i] [j] , (A[i] [k]+A[k] [j]) }</strong></p><p>找路径：定义二维数组Path[n] [n] (n为图的顶点数) ，元素Path<a href="https://blog.csdn.net/gyeolhada/article/details/135513487?ops_request_misc=%7B%22request%5Fid%22%3A%22172193217416800227432269%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=172193217416800227432269&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-135513487-null-null.142%5Ev100%5Epc_search_result_base6&amp;utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0#">i</a>保存从Vi到Vj的最短路径所经过的顶点。若Path[i] [j]=k：从Vi到Vj 经过Vk ，最短路径序列是(Vi , …, Vk , …, Vj) ，则路径序列：(Vi , …, Vk)和(Vk , …, Vj)一定是从Vi到Vk和从Vk到Vj 的最短路径。从而可以根据Path[i] [k]和Path[k] [j]的值再找到该路径上所经过的其它顶点，…依此类推。</p><p>初始时令Path[i] [j]=-1，表示从Vi到Vj 不经过任何(S中的中间)顶点。当某个顶点Vk加入到S中后使A[i] [j]变小时，令Path[i] [j]=k。</p><h3 id="六、有向无环图及其应用">六、有向无环图及其应用</h3><p>1.<strong>AOV</strong>网（<strong>有向图</strong>！）</p><p>（1）如果用有向图的顶点表示活动，用弧表示活动间的优先关系，则称该有向图为顶点表示活动的网AOV(Activity On Vertex Network)</p><p>（2）AOV的应用包括流程图、工程安排等。对AOV网，应判定图中不存在环，因为存在环意味着某项活动应以自己为先决条件。</p><p>2.有向无环图(DAG)Directed Acycline Graph</p><p>3.检查有向图中是否有回路：</p><p>（1）深度优先搜索 ：从某个顶点v出发，进行DFS，如果存在一条从顶点u到v的回边，则有向图中存在环。</p><p>（2）拓扑排序：由严格偏序定义得到的拓扑有序的操作称拓扑排序。</p><p>若集合X上的关系R是：⑴.自反的：x R x⑵.反对称的：x R y =&gt; y R x⑶.传递的：xRy &amp; yRz =&gt; xRz 则称R是集合X上的偏序关系。</p><p>全序：设关系R是集合X上的偏序，如果对每个x,y属于X，必有xRy或者yRx，则称R是X上的全序关系。</p><p>偏序：指集合中仅有部分成员之间可比较。</p><p>全序：指集合中全体成员之间均可比较</p><p>算法：⑴.在有向图中选一个<strong>没有前驱</strong>的顶点(无入度)且输出之⑵.从图中删除该顶点和所有以它为尾的弧；重复⑴⑵两步，直到所有顶点输出为止或跳出循环。</p><p>（3）拓扑排序与AOV网：</p><p>拓扑排序可检测AOV网是否存在环。如果通过拓扑排序能将AOV网络的所有顶点都排入一个拓扑有序的序列中, 则该网络中必定不会出现有向环。反之其中存在环。</p><p>4.拓扑排序实现</p><p>（1）没有前驱的顶点 == 入度为零的顶点</p><p>（2）删除顶点及以它为尾的弧 == 弧头顶点的入度减1</p><p><strong>题目</strong>:写出某AOV网的邻接表存储结构如下，写出分别用队列和栈存储入读为零的顶点时的拓扑排序序列。</p><p><img src="./../assets/4f1a89160a1628b14847d098811eb582.png" alt="img"></p><p>栈的拓扑：C4,C0,C2,C1,C3,C5</p><p>队列的拓扑：C2,C4,C0,C1,C5,C3</p><p>5.AOV-网</p><p>（1）如果用有向图的<strong>顶点表示事件</strong>，用<strong>弧表示活动</strong>，则称该有向图为边表示活动的网AOE(Activity On Edge)</p><p>（2）AOE应该同样是DAG，AOE包括估算工程的完成时间。</p><p>注意：AOE网和AOV网都是有向无环图，不同在于AOE网中的边有权值；而AOV网中的边无权值，仅表示顶点之间的前后关系。</p><p>6.关键路径</p><p>（1）工程问题的AOE网中，从工程开始(顶点)到工程结束(顶点)之间<strong>路径长度最长</strong>的路径叫关键路径（<strong>最长</strong>路径！）</p><p>（2）提前完成<strong>关键路径上的活动</strong>，工程进度会加快</p><p>（3）提前完成非关键路径上的活动，对工程无帮助</p><p>7.关键活动</p><p>（1）关键路径上的所有活动称为关键活动</p><p>（2）<strong>找到工程AOE中的所有关键活动，即找到了关键路径</strong></p><p>8.关键活动有关的量</p><p>（1）e(i)：活动ai最早开始时间</p><p>（2）l(i)：活动ai最迟开始时间</p><p>（3）l(i)-e(i)：活动ai开始时间余量</p><p>（4）如果l(i)=e(i)，则称活动ai为关键活动</p><p>（5）ve(j)：事件vj最早开始时间</p><p>（6）vl(j)：事件vj最迟开始时间</p><p>（7)e(i)=ve(j)</p><p>（8）l(i)=vl(k)-dut(&lt;j,k&gt;)</p><p>dut(&lt;j,k&gt;)为活动ai的持续时间</p><p>（9）活动的最早开始时间是活动的弧尾事件的最早发生时间，</p><p>活动的最晚发生时间是活动的弧头事件的最晚发生时间减去活动的持续时间。</p><p>j------&gt;k(此边即活动的编号为i)</p><p>（10）从ve(0)=0开始向前递推（事件的最早发生时刻）</p><p>事件的最早发生时间是以其为弧头事件的所有弧尾事件的最早发生时间与对应弧活动的持续时间之和的最大值</p><p>（11）从vl(n-1)=ve(n-1)起向后递推（事件的最晚发生时刻）</p><p>事件的最晚发生时间是以其为弧尾事件的所有弧头事件的最晚发生时间与对应弧活动的持续时间之差的最小值。</p><p>9.求关键活动算法（先计算事件，再计算活动）</p><p>（1）从始点v0出发，令ve[0]=0（源点），按拓扑有序求ve[j]</p><p>&lt;vj,vk&gt;即vk为vj的任意后续</p><p>ve[k]=max{ve[j]+Weight(vj,vk)}</p><p>（2）从终点vn-1出发，令vl[n-1]=ve[n-1]（汇点），按逆拓扑有序求vl[i]</p><p>&lt;vk,vj&gt;即vk为vj的任意前驱</p><p>vl[k]=min{ vl[j]-Weight(vk,vj)}</p><p>（简单记忆：我们都想晚点开学早点放假，晚点开学即最早开始取max，早点放假即最晚开始取min)</p><p>（3）根据各顶点的ve和vl值，求每条弧(活动)ai的最早开始时间e[ai]和最迟开始时间l[ai]</p><p>若边&lt;vk,vj&gt;表示活动ai,则e(i)=ve[k]</p><p>l[i]=vl[j]-Weight(vk,vj)</p><p>（4）如果e[ai]=l[ai]，则ai为关键活动(e[i]-l[i]==0)</p><p>（5）如果ve[i]=vl[i]，则vi为关键路径上的事件</p><p>**题目：**下表给出了某工程各工序之间的优先关系和各工序所需的时间。</p><table><thead><tr><th style="text-align:left">工序代号</th><th style="text-align:left">A</th><th style="text-align:left">B</th><th style="text-align:left">C</th><th style="text-align:left">D</th><th style="text-align:left">E</th><th style="text-align:left">F</th><th style="text-align:left">G</th><th style="text-align:left">H</th></tr></thead><tbody><tr><td style="text-align:left">所需时间</td><td style="text-align:left">3</td><td style="text-align:left">2</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">4</td><td style="text-align:left">3</td><td style="text-align:left">2</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">先驱工序</td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">A</td><td style="text-align:left">A</td><td style="text-align:left">B</td><td style="text-align:left">B</td><td style="text-align:left">C,E</td><td style="text-align:left">D</td></tr></tbody></table><p>问: 该工程是否能够顺利进行? 如果能，请问要花多长时间？ 缩短那些工序可以缩短整个工程的完工时间？</p><p><img src="./../assets/c40cb5ac29419114a476bfbf5cacd5b8.jpeg" alt="img"></p><h2 id="img-2"><img src="./../assets/907dddd28d84e699540a8fc0d555556d.jpeg" alt="img"></h2><h2 id="img-3"><img src="./../assets/ad46540e54f0b67fd768aafe047adf64.jpeg" alt="img"></h2><h2 id="第九章：查找">第九章：查找</h2><h3 id="一、查找的概念">一、查找的概念</h3><p>1.查找表</p><p>（1）查找表是由<strong>同一类型的数据元素</strong>(或记录)构成的集合</p><p>（2）对查找表的操作:</p><p>–1.查询某个“特定的”数据元素是否在查找表中；</p><p>–2.检索某个“特定的”数据元素的各种属性；</p><p>–3.在查找表中插入一个数据元素；</p><p>–4.从查找表中删去某个数据元素</p><p>（3）<strong>静态</strong>查找表：仅作<strong>查询和检索</strong>操作的查找表。</p><p>（4）<strong>动态</strong>查找表：在查找过程中同时<strong>插入</strong>查找表中不存在的数据元素，或者从查找表中<strong>删除</strong>已存在的某个数据元素。</p><p>2.关键字</p><p>（1）<strong>关键字</strong>是数据元素（或记录）中<strong>某个数据项的值</strong>，用以标识（识别）一个数据元素（或记录</p><p><em><strong>注意：关键字是某个数据项的值！不是数据元素</strong></em></p><p>（2）主关键字：可以识别<strong>唯一</strong>的一个记录的关键字</p><p>（3）次关键字：能识别若干记录的关键字</p><p>3.查找</p><p>（1）查找是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><p>（2）查找成功：在查找表中查找到指定的记录。</p><p>（3）查找不成功：在查找表中没有找到指定记录。</p><p>4.衡量<strong>查找算法</strong>的标准</p><p>（1）时间复杂度</p><p>（2）空间复杂度</p><p>（3）<strong>平均查找长度ASL</strong></p><p>5.平均查找长度ASL</p><p>（1）平均查找长度定义为确定记录在表中的位置所进行的和关键字比较的次数的平均值。</p><p>（2）ASL = ∑ PiCi （i为1到n）</p><p><img src="./../assets/2a10c2cf525d93f886530b184f66f0ff.png" alt="img"></p><p>n为查找表的长度，即表中所含元素的个数；Pi为<strong>查找第i个元素的概率</strong>(∑Pi=1)；Ci是查找第i个元素时同给<strong>定值K比较的次数</strong>。</p><h3 id="二、静态查找表（顺序、折半、分块）">二、静态查找表（顺序、折半、分块）</h3><p>1.顺序查找</p><p>（1）顺序查找算法是<strong>顺序表</strong>的查找方法。</p><p>（2）在顺序查找算法中，以<strong>顺序表或线性链表</strong>表示静态查找表。</p><p>（3）顺序查找算法：</p><p>–1.从表中最后一个记录开始</p><p>–2.逐个进行记录的关键字和给定值的比较</p><p>–3.若某个记录比较相等，则查找成功</p><p>–4.若直到第1个记录都比较不等，则查找不成功</p><p>（4）算法性能分析</p><p>对顺序表而言，Ci=n-i+1</p><p>在等概率查找的情况下，Pi=1/n</p><p><strong>ASL（成功）=n*P1 +(n-1)P2 +…+ 2Pn-1+ Pn = (n+1)/2</strong></p><p>（5）顺序查找(不等概率)</p><p>如果被查找的记录概率不等时，取 Pn≥Pn-1≥···≥P2≥P1；</p><p>若查找概率无法事先测定，则查找过程采取的改进办法是，在每次查找之后，将刚刚查找到的记录直接移至表尾的位置上。</p><p>（6）特点：</p><p>优点：1.简单2.适应面广(对表的结构无任何要求)</p><p>缺点：1.平均查找长度较大2.特别是<strong>当n很大时，查找效率很低</strong>。</p><p>2.折半查找（有序表！）</p><p>（1）折半查找算法是<strong>有序表</strong>的查找方法。</p><p>（2）在折半查找算法中，静态查找表按<strong>关键字</strong>大小的次序，<strong>有序</strong>地存放在顺序表中。</p><p>（3）折半查找的原理是：1.先确定待查记录所在的范围(前部分或后部分)2.逐步缩小(一半)范围直到找(不)到该记录为止。</p><p>（4）算法：</p><p>–1.n个对象从小到大存放在有序顺序表ST中，k为给定值</p><p>–2.设low、high指向待查元素所在区间的下界、上界，即low=1, high=n</p><p>–3.设mid指向待区间的中点，即mid=(low+high)/2</p><p>–4.让k与mid指向的记录比较若k=ST[mid].key，查找成功</p><p>若k&lt;ST[mid].key，则<strong>high=mid-1</strong> [上半区间]</p><p>若k&gt;ST[mid].key，则<strong>low=mid+1</strong> [下半区间]</p><p>–5.重复3,4操作，直至<strong>low&gt;high</strong>时，查找失败。（严格大于）</p><p>（5）折半查找（判定树）</p><p>判定树：描述查找过程的二叉树。</p><p><strong>有n个结点的判定树的深度为floor(log2(n)) +1（与含有 n 个结点的完全二叉树的深度相同）</strong></p><p>折半查找法在查找过程中进行的比较次数最多不超过floor(log2(n)) +1</p><p><strong>题目</strong>：假设某有序表查找中有12个元素，请问该查找表查找成功时的平均查找长度为多少？（查找失败的ASL：为白块到根结点的路径长度之和/白块个数；ASL=1/2 * 成功+1/2* 失败）</p><p><img src="./../assets/77ae298f7eef0b5219571ecb1debc241.jpeg" alt="img"></p><p>（6）性能分析</p><p>设有序表的长度n=2^h-1（即h=log2(n+1)）,则描述折半查找的判定树是深度为h的满二叉树。</p><p>树中层次为1的结点有1个，层次为2的结点有2个，层次为h的结点有2^(h-1)个。</p><p>假设表中每个记录的查找概率相等，则查找成功时折半查找的平均查找长度：<strong>ASL（成功）=[(n+1)/n]*log2(n+1)-1</strong></p><p>（7）特点</p><p>折半查找的效率比顺序查找高(特别是在静态查找表的长度很长时)。</p><p>折半查找只能适用于<strong>有序</strong>表，并且以顺序存储结构存储。</p><p>3.分块查找</p><p>（1）分块查找是一种索引顺序表(分块有序表)查找方法，是折半查找和顺序查找的简单结合。</p><p>（2）**索引顺序表(分块有序表)**将整个表分成几块，块内无序，块间有序。</p><p>（3）所谓块间有序是指后一块表中所有记录的关键字均大于前一块表中的最大关键字。</p><p>（4）分块查找(分块有序表)</p><p>主表：用数组存放待查记录,每个数据元素至少含有关键字域。</p><p>索引表：每个结点含有最大关键字域和指向本块第一个结点的指针。</p><p>（5）采用折半查找方法在索引表中找到块[第2块]，用顺序查找方法在主表对 应块中找到记录[第3记录]。</p><p>（6）性能分析：</p><p>若将长度为n的表分成b块，每块含s个记录，并设表中每个记录查找概率相等。</p><p>用折半查找方法在索引表中查找索引块，ASL块间≈log2(n/s+1)</p><p>用顺序查找方法在主表对应块中查找记录，ASL块内=s/2</p><p><strong>ASL(成功)≈log2(n/s+1) + s/2</strong></p><h3 id="三、动态查找表">三、动态查找表</h3><p>1.动态查找表</p><p>（1）表结构本身是在查找过程中动态生成的</p><p>（2）若表中存在其关键字等于给定值key的记录,表明查找成功；</p><p>（3）否则插入关键字等于key的记录。</p><p>2.二叉排序树（将判定树的结点信息从下标改为数据即为二叉排序树）</p><p>（1）空树或者是具有如下特性的二叉树：</p><p>–⑴.若它的左子树不空，则左子树上<strong>所有</strong>结点的值均小于根结点的值；</p><p>–⑵.若它的右子树不空，则右子树上<strong>所有</strong>结点的值均大于根结点的值；</p><p>–⑶.它的左、右子树也都分别是二叉排序树。</p><p>（2）二叉排序树又称二叉查找树</p><p>查找算法： 给定值与根结点比较：–1.若相等，查找成功–2.若小于，查找左子树–3.若大于，查找右子树</p><p>生成举例：</p><p><strong>题目</strong>：画出在初始为空的二叉排序树中依次插入56,64,92,80,88,75时该树的生长全过程</p><p><img src="./../assets/d2580fec79503256908079d814c46272.png" alt="img"></p><p>（3）二叉排序树(插入)</p><p>二叉排序树是一种<strong>动态</strong>树表；</p><p>当树中<strong>不存在</strong>查找的结点时，作<strong>插入</strong>操作；</p><p><strong>新插入的结点一定是叶子结点</strong>（只需改动一个结点的指针）；</p><p>该叶子结点是查找不成功时路径上<strong>访问的最后一个结点</strong>左孩子或右孩子(新结点值小于或大于该结点值)。（最后一个！）</p><p>（4）<strong>中序</strong>遍历二叉排序树，可得到一个关键字的有序序列。</p><p>（5）二叉排序树(删除)</p><p>删除二叉排序树中的一个结点后，必须保持二叉排序树的特性（左子树的所有结点值小于根结点，右子树的所有结点值大于根结点）也即保持中序遍历后，输出为有序序列。</p><p>被删除结点具有以下三种情况：1.是叶子结点（直接删除结点，并让其父结点指向该结点的指针变为空）；2.只有左子树或右子树（删除结点,让其父结点指向该结点的指针指向其左子树(或右子树),即用孩子结点替代被删除结点即可）；3.同时有左、右子树。（<strong>以中序遍历时的直接前驱</strong>s替代被删除结点p，然后再删除该直接前驱（只可能有左孩子））</p><p><img src="./../assets/79214a289ead742445faa98bd9ffc6cc.png" alt="img"></p><p>（6）性能分析</p><p><img src="./../assets/61414a0033967c09f3af63077944d293.png" alt="img"></p><p>（注意根算1！）</p><p>对于每一棵特定的二叉排序树，均可按照平均查找长度的定义来求它的 ASL 值。</p><p>显然，由值相同的 n 个关键字，构造所得的不同形态的各棵二叉排序树的平均查找长度的值不同，甚至可能差别很大。</p><p>在最坏的情况下，二叉排序树为近似线性表时(如以<strong>升序或降序</strong>输入结点时)，其查找深度为n量级，即其时间复杂性为O(n)</p><p>（7）特性</p><p>一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列（通过中序遍历）。</p><p>插入新记录时，<strong>只需改变一个结点的指针</strong>，相当于在有序序列中插入一个记录而不需要移动其它记录。</p><p><strong>二叉排序树既拥有类似于折半查找的特性，又采用了链表作存储结构。</strong></p><p>但当插入记录的次序不当时(如升序或降序)，则二叉排序树深度很深，增加了查找的时间。</p><p>3.平衡二叉树</p><p>（1）平衡二叉树是二叉排序(查找)树的另一种形式</p><p>（2）平衡二叉树又称<strong>AVL树</strong>(Adelsen-Velskii and Landis)</p><p>（3）其特点为：树中<strong>每个结点</strong>的左、右子树深度之差的绝对值不大于1，即|hL-hR|≤1</p><p>（4）平衡因子：每个结点附加一个数字, 给出该结点左子树的高度减去右子树的高度所得的高度差,这个数字即为结点的平衡因子balance （左减右！）</p><p>（5）AVL树任一结点平衡因子只能取 -1, 0, 1</p><p>（6）平衡二叉树(删除)与二叉排序树相同</p><p>如果被删结点A最多只有一个孩子，那么将结点A从树中删去，并将其双亲指向它的指针指向它的唯一的孩子，并作平衡化处理。</p><p>如果被删结点A没有孩子，则直接删除之，并作平衡化处理。</p><p>如果被删结点A有两个子女，则用该结点的直接前驱S替代被删结点，然后对直接前驱S作删除处理(S只有一个孩子或没有孩子)。</p><p>4.AVL平衡化旋转</p><p>（1）如果在一棵平衡的二叉查找树中插入一个新结点，造成了不平衡。此时必须调整树的结构，使之平衡化。</p><p>（2）平衡化旋转(处理)有两类：</p><p>–1.单向旋转 (单向右旋和单向左旋)</p><p><img src="./../assets/cef5b169a4fe5d6b9110ada53c5c75ac.png" alt="img"></p><p>–2.双向旋转 (先左后右旋转和先右后左旋转)</p><p><img src="./../assets/5621c1de1427d7a5cb77ecb06ac90867.png" alt="img"></p><p>（3）每插入一个新结点时, AVL树中相关结点的平衡状态会发生改变。</p><p>–1.在插入一个新结点后，需要<strong>从插入位置沿通向根的路径回溯</strong>，检查各结点的平衡因子。</p><p>–2.如果在某一结点发现高度不平衡，停止回溯。(<strong>出现2或者-2</strong>)</p><p>–3.从发生不平衡的结点起，沿刚才回溯的路径<strong>取直接下两层的结点</strong>。（做旋转操作）</p><p>题目：画出在初始为空的AVL树中依次插入64,5,13,21,19,80,75,37,56时该树的生长过程，并在有旋转时说出旋转的类型。</p><p><img src="./../assets/973d290c0600a1e23b5e455662b6b1e4.jpeg" alt="img"></p><h3 id="四、哈希表">四、哈希表</h3><p>1.哈希表（散列表）</p><p>（1）哈希(Hash)表又称散列表散列表，是一种<strong>直接计算记录存放地址</strong>的方法，它在<strong>关键码与存储位置之间直接建立了映象</strong>。</p><p>（2）哈希函数是从关键字空间到存储地址空间的一种映象。</p><p>（3）哈希函数在记录的关键字与记录的存储地址之间建立起一种对应关系。可写成：addr(ai)= H(keyi)，H(·)为哈希函数k，eyi是表中元素ai关键字,addr(ai)是存储地址。</p><p>2.哈希表(查找)</p><p>（1）哈希查找也叫散列查找，是利用哈希函数进行查找的过程。</p><p>–1.首先利用哈希函数及记录的关键字计算出记录的存储地址.。</p><p>–2.然后直接到指定地址进行查找</p><p>–3.不需要经过比较，一次存取就能得到所查元素</p><p>3.哈希表(冲突)</p><p>（1）不同的记录，其关键字通过哈希函数的计算，可能得到相同的地址。把不同的记录映射到同一个散列地址上，这种现象称为冲突。</p><p>4.哈希表(定义)</p><p>（1）根据设定的哈希函数 H(key) 和所选中的处理冲突的方法</p><p>（2）将一组关键字映象到一个有限的、地址连续的地址集 (区间) 上</p><p>（3）并以关键字在地址集中的“象”作为相应记录在表中的存储位置</p><p>（4）如此构造所得的查找表称之为“哈希表”</p><p>5.哈希函数(均匀性)</p><p>（1）哈希函数实现的一般是从一个<strong>大的集合</strong>（部分元素，空间位置上一般不连续）到一个<strong>小的集合</strong>（空间连续）的映射</p><p>（2）一个好的哈希函数，对于记录中的任何关键字，将其映射到地址集合中任何一个地址的概率应该是相等的</p><p>（3）即关键字经过哈希函数得到一个“随机的地址“</p><p>6.哈希函数(要求)</p><p>（1）哈希函数应是简单的，能在较短的时间内计算出结果。</p><p>（2）哈希函数的定义域尽可能包括需要存储的全部关键字，如果散列表允许有 m 个地址时，其值域必须在 0 到 m-1 之间。</p><p>（3）散列函数计算出来的地址应能均匀分布在整个地址空间中。</p><p>7.哈希函数(直接定址法)</p><p>（1）<strong>直接定址法</strong>中，哈希函数取关键字的线性函数： H(key) = a x key + b（其中a和b为常数）</p><p>（2）<strong>直接定址法仅适合于地址集合的大小与关键字集合的大小相等</strong>的情况</p><p>（3）当a=1时，H(key)=key，即用关键字作地址</p><p>（4）在实际应用中能使用这种哈希函数的情况很少</p><p>8.哈希函数(数字分析法)</p><p>（1）假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)。</p><p>（2）分析关键字集中的全体</p><p>（3）从中提取<strong>分布均匀的若干位</strong>或它们的组合作为地址</p><p><img src="./../assets/a837e04d368a9faa7799a52305854407.png" alt="img"></p><p>（4）数字分析法仅适用于<strong>事先明确</strong>知道表中所有关键码每一位数值的分布情况</p><p>（5）数字分析法<strong>完全依赖于关键码集合</strong></p><p>（6）如果换一个关键码集合，选择哪几位要重新决定</p><p>9.哈希函数(平方取中法)</p><p>（1）以关键字的平方值的<strong>中间几位</strong>作为存储地址。</p><p>（2）求“<strong>关键字的平方值</strong>” 的目的是“扩大差别”</p><p>（3）同时平方值的中间各位又能受到整个关键字中各位的影响。</p><p>（4）此方法在词典处理中使用十分广泛。它先计算构成关键码的标识符的内码的平方, 然后按照散列表的大小取中间的若干位作为散列地址。</p><p><img src="./../assets/8c221977aa45d8efb4c996a7ecea1c24.png" alt="img"></p><p>（5）平方取中法是较常用的构造哈希函数的方法</p><p>（6）适合于关键字中的每一位都有某些数字重复出现且频度很高的情况</p><p>（7）中间所取的位数，由哈希表长决定</p><p>10.哈希函数(折叠法)</p><p>（1）将关键字分割成位数相同的若干部分(最后部分的倍数可以不同)，然后取它们的叠加和(舍去进位)为哈希地址。</p><p>（2）移位叠加:将分割后的几部分低位对齐相加。</p><p>（3）间界叠加:从一端沿分割界来回折送，然后对齐相加。</p><p><img src="./../assets/7e447f01b0d85f7c219037010aa1bf1a.png" alt="img"></p><p>（4）折叠法适合于关键字的<strong>数字位数特别多</strong>，而且每一位上数字分布大致均匀的情况。</p><p>11.<strong>哈希函数(除留余数法)</strong></p><p>（1）取关键字被某个不大于哈希表长m的数p除后所得余数为哈希地址： <strong>H(key) = key MOD p</strong> ( p≤m )</p><p>m为表长 p为不大于m的素数或是不含20以下的<strong>质因子</strong></p><p>（2）除留余数法是一种最简单、最常用的构造哈希函数的方法</p><p>（3）不仅可以对关键字直接取模(MOD)，也<strong>可在折叠、平方取中等运算之后取模</strong></p><p>12.处理冲突的方法</p><p>“处理冲突” 的实际含义是：为产生冲突的地址寻找下一个哈希地址。</p><p>处理冲突的方法主要有三种：<strong>1.开放定址法2.再哈希法3.链地址法</strong></p><p>13.处理冲突的方法(开放定址法)</p><p>（1）为产生冲突的地址 H(key) 求得一个地址序列： H0, H1, H2, …, Hs，1≤s≤m-1</p><p>（2）Hi = [H(key)+di] MOD m</p><p>i=1,2,…,s</p><p>H(key)为哈希函数</p><p>m为哈希表长</p><p>（3）开放定址法－线性探测：</p><p>当di取1,2,3,…,m-1时，称这种开放定址法为线性探测再散列</p><p><img src="./../assets/9b1376886c35a5689f8d5222603f7eef.png" alt="img"></p><p>（4）开放定址法－二次探测：</p><p>当di取= 1^2, -1^2，2^2, -2^2，3^2,…时，称这种开放定址法为二次探测再散列</p><p>（5）特性</p><p>当di取= 1^2, -1^2，2^2, -2^2，3^2,…时，称这种开放定址法为二次探测再散列；</p><p>二次探测再散列：m=4j+3的素数时总能找到。</p><p>缺点：易产生“二次聚集”，即在处理同义词的冲突过程中，又添加了非同义词的冲突，对查找不利</p><p>14.处理冲突的方法(再哈希法)</p><p>（1）构造若干个哈希函数，当发生冲突时，计算下一个哈希地址，直到冲突不再发生，即：Hi = Rhi(key) i=1,2,……k</p><p>Rhi—不同的哈希函数</p><p>（2）特点：不易产生聚集，但增加计算时间</p><p>15.处理冲突的方法(链地址法)</p><p>（1）将所有哈希地址相同的记录都链接在同一链表中</p><p>（2）表头插入和表后插入</p><p><strong>题目</strong>：已知一组关键字(19,14,23,1,68,20,84,27,55,11,10,79)哈希函数为： H(key)=key MOD 13,用链地址法处理冲突[表头插入]</p><p>（注意左侧数组表示和空符号^)</p><p><img src="./../assets/c3d4f291ed2c90e2697567e6b28489d1.png" alt="img"></p><p>16.哈希表的实现</p><p>17.哈希表的性能分析</p><p>（1）虽然哈希表在关键字与记录的存储位置之间建立了直接映象，但由于“冲突”的产生，使得哈希表的查找过程仍然是一个给定值和关键字进行比较的过程</p><p>（2）因此，仍需以平均查找长度(ASL)作为衡量哈希表的查找效率的量度</p><p>（3）决定哈希表查找的ASL的因素：</p><p>–1.选用的哈希函数</p><p>–2.选用的处理冲突的方法</p><p>–3.哈希表的装填因子：哈希表的装填因子是哈希表中填入的记录数与哈希表的长度的比值，即：<strong>α = 哈希表中填入的记录数 / 哈希表的长度</strong>。装填因子α标志哈希表的装满程序。</p><p><em><strong>注意：散列表的平均查找长度依赖于装填因子，不直接依赖于n或m</strong></em></p><p>（4）装填因子α越小，发生冲突的可能性就越小；装填因子α越大，发生冲突的可能性就越大。</p><p>（5）平均查找长度ASL:</p><p>线性探测再散列的哈希表查找成功时：ASL ≈ (½)(1 + 1/(1-α))</p><p>ASL(成功)=(1/2)*(1+1/(1-记录数/哈希表长度))</p><p>二次探测再散列的哈希表查找成功时：ASL ≈ -(1/α)ln(1-α)</p><p>ASL(成功)=-(1/(记录数/哈希表长度))ln(1-记录数/哈希表长度)</p><p>链地址法处理冲突的哈希表查找成功时：ASL ≈ (1 + α/2)</p><p>ASL(成功)=(1+(记录数/哈希表长度)/2)</p><h3 id="五、B-树-结点结构">五、B-树[结点结构]</h3><p>1.B-树是一种特殊的<strong>多路平衡查找树</strong></p><p>2.R.Bayer和E.Maccreight于1970年提出</p><p>3.B-树是一种在<strong>外存文件系统</strong>中常用的<strong>动态索引</strong></p><p>4.技术磁盘中文件的读写以“<strong>盘块</strong>”为单位进行</p><p>5.将<strong>关键字索引</strong>信息，放在盘块中，可以加快数据的查找速度</p><p>6.结点结构：</p><p>（1）Ki是关键字，且Ki&lt;Ki+1</p><p>（2）Ai是指向子树根结点的指针</p><p>（3）Ai-1所指子树中所有结点的关键字均小于Ki</p><p>（4）Ai 所指子树中所有结点的关键字均大于Ki</p><p>（5）对于m阶B-树，ceil(m/2) -1≤n≤m-1 (分支数比关键字数目多一)</p><p><img src="./../assets/685eee884c55d4fdb56396efaee53d74.png" alt="img"></p><p>7.m阶B-树定义:</p><p>（1）树中每个结点至多有m棵子树（m-1个关键字）</p><p>（2）<strong>若根结点不是叶子结点，则至少有两棵子树</strong></p><p>（3）除根之外的<strong>所有非终端结点至少有 ceil(m/2) 棵子树</strong></p><p>（4）所有叶子结点，都出现在同一层次上，且不带信息（可以看作是查找失败的结点，指向这些结点的指针为空指针）</p><p>**题目:**3阶B-树（11个结点）</p><p><img src="./../assets/efa70088b6901fcfdcab17c4d34e72e1.png" alt="img"></p><p>(1)关键字比分支数少一（B-）,m=3(3阶)</p><p>(2)关键字数目为n,ceil(3/2)-1&lt;=n&lt;=3-1即1&lt;=n&lt;=2</p><p><strong>ceil(m/2)-1&lt;=n&lt;=m-1</strong></p><p>(3)如图深度为3，结点数最少(所有都是关键字n=1,分支为2)：2^3-1=7;结点数最多(所有都是关键字n=2,分支为3)：1+3+3^2=13</p><p><strong>结点数最少：2^h-1;结点数最多：1+m+m^2+…+m^(h-1)</strong></p><h2 id="第十章：内部排序">第十章：内部排序</h2><h3 id="一、排序">一、排序</h3><p>1.排序</p><p>（1）排序：将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列</p><p>（2）内部排序：在排序期间数据对象全部存放在<strong>内存</strong>的排序；</p><p>（3）外部排序：在排序期间全部对象个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序。</p><p>2.<strong>排序基本操作</strong>：</p><p>（1）<strong>比较</strong>：比较两个关键字的大小</p><p>（2）<strong>移动</strong>：将记录从一个位置移动至另一个位置</p><p>3.排序时间复杂度</p><p>排序的时间复杂度可用算法执行中的记录关键字<strong>比较次数</strong>与记录<strong>移动次数</strong>来衡量。</p><p>4.排序方法的稳定性</p><p>（1）如果在记录序列中有两个记录r[i]和r[j], 它们的关键字 key[i] == key[j] , 且在排序之前, 记录r[i]排在r[j]前面。</p><p>（2）如果在排序之后, 记录r[i]仍在记录r[j]的前面, 则称这个排序方法是稳定的, 否则称这个排序方法是不稳定的。</p><h3 id="二、插入排序">二、插入排序</h3><p>1.直接插入排序</p><p>（1）当插入第i(i≥1)个对象时, <strong>前面</strong>的r[0], r[1], …, r[i-1]已经<strong>排好序</strong>。</p><p>（2）用r[i]的关键字与r[i-1], r[i-2], …的关键字顺序进行比较(和顺序查找类似)，如果小于，则将r[x]向后移动(插入位置后的记录向后顺移)</p><p>（3）找到插入位置即将r[i]插入</p><p>（4）每步将一个待排序的对象, 按其关键字大小, 插入到前面已经排好序的有序表的适当位置上, 直到对象全部插入为止。</p><p><img src="./../assets/82df5956fb410d2783cdb2da8a95190f.jpeg" alt="img"></p><p>（5）关键字比较次数和记录移动次数与记录关键字的初始排列有关。</p><p>（6）最好情况下, 排序前记录已按关键字从小到大有序, 每趟只需与前面有序记录序列的最后一个记录比较1次, 移动2次记录, 总的关键字比较次数为 n-1, 记录<strong>移动次数为 2(n-1)</strong>。</p><p>（7）最坏情况下, (i从1开始，下标从0开始)第i趟时第i个记录必须与前面i个记录都做关键字比较, 并且每做1次比较就要做1次数据移动。则总关键字比较次数KCN和记录移动次数RMN分别为</p><p><img src="./../assets/7426ba00280e26fabeb369496a007e24.png" alt="img"></p><p>（8）在平均情况下的关键字比较次数和记录移动次数约为 n^2/4。</p><p>（9）直接插入排序的时间复杂度为<strong>O(n^2)</strong>。</p><p>（10）直接插入排序是一种<strong>稳定的排序方法</strong>。</p><p>（11）直接插入排序最大的优点是简单，在<strong>记录数较少</strong>时，是比较好的办法。</p><p>2.折半插入排序</p><p>（1）折半插入排序在查找记录插入位置时，采用<strong>折半查找</strong>算法</p><p>（2）折半查找比顺序查找快, 所以折半插入排序在查找上性能比直接插入排序好</p><p>（3）但需要移动的记录数目与直接插入排序相同(为O(n2))</p><p>（4）折半插入排序的时间复杂度为O(n^2)。</p><p>（5）折半插入排序是一种稳定的排序方法</p><p>3.希尔排序</p><p>（1）从直接插入排序可以看出，当待排序列为正序时，时间复杂度为O(n)</p><p>（2）若待排序列基本有序时，插入排序效率会提高希尔排序方法是先将待排序列分成<strong>若干子序列分别进行插入排序</strong>，待整个序列基本有序时，再对全体记录进行一次直接插入排序</p><p>（3）希尔排序又称为<strong>缩小增量排序</strong>。</p><p><img src="./../assets/388fa4028c4c261d79f4fb416d5970cd.jpeg" alt="img"></p><p>（4）算法：</p><p>首先取一个整数 gap &lt; n(待排序记录数) 作为间隔, 将全部记录分为 <strong>gap 个子序列</strong>, 所有距离为 gap 的记录放在同一个子序列中。（gap为组数！）</p><p>在每一个子序列中分别施行直接插入排序。然后缩小间隔 gap, 例如取 gap = gap/2。</p><p>重复上述的子序列划分和排序工作，直到最后取gap = 1, 将所有记录放在同一个序列中排序为止。</p><p>（5）算法分析：</p><p>开始时 gap 的值较大, 子序列中的记录较少, 排序速度较快。</p><p>随着排序进展, gap 值逐渐变小, 子序列中记录个数逐渐变多,由于前面大多数记录已基本有序, 所以排序速度仍然很快。</p><p>Gap的取法有多种。 shell 提出取 gap = n/2，gap = gap/2，直到gap = 1。</p><p>对特定的待排序记录序列，可以准确地估算关键字的比较次数和记录移动次数。</p><p>希尔排序所需的比较次数和移动次数约为n^1.3</p><p>当n趋于无穷时可减少到n x(log2 n)^2</p><p>希尔排序的时间复杂度约为O(n x(log2 n)^2)</p><p>希尔排序是一种不稳定的排序方法</p><h3 id="三、快速排序">三、快速排序</h3><p>1.冒泡排序</p><p>（1）设待排序记录序列中的记录个数为n(下标从1到n)。</p><p>（2）一般地，第i趟起泡排序从1到n-i+1依次比较相邻两个记录的关键字，如果发生逆序，则交换之</p><p>i=1时，为第一趟排序，关键字最大的记录将被交换到最后一个位置</p><p>i=2时，为第二趟排序，关键字次大的记录将被交换到最后第二个位置</p><p>关键字小的记录不断上浮(起泡)，关键字大的记录不断下沉(每趟排序最大的一直沉到底)</p><p>（3）其结果是这n-i+1个记录中，关键字最大的记录被交换到第n-i+1的位置上，最多作n-1趟。</p><p>（4）最好情况：在记录的初始排列已经按关键字从小到大排好序时,此算法只执行一趟起泡,做n-1次关键字比较,不移动记录。</p><p>（5）最好情况：在记录的初始排列已经按关键字从小到大排好序时,此算法只执行一趟起泡,做n-1次关键字比较,不移动记录</p><p><img src="./../assets/335cf4360ef62c16dcc426c0624c3662.png" alt="img"></p><p>（6）起泡排序的时间复杂度为O(n^2)</p><p>（7）起泡排序是一种稳定的排序方法</p><p>（8）每一趟可以确定一个数的位置（从后往前）</p><p>2.快速排序</p><p>（1）任取待排序记录序列中的某个记录(例如取第一个记录)作为基准(枢),按照该记录的关键字大小,将整个记录序列划分为<strong>左右两个子序列</strong></p><p>（2） 左侧子序列中所有记录的关键字都小于或等于基准记录的关键字</p><p>（3）右侧子序列中所有记录的关键字都大于基准记录的关键字</p><p>（4）基准记录则排在这两个子序列中间(这也是该记录最终应安放的位置)。</p><p>（5）然后分别对这两个子序列重复施行上述方法，直到所有的记录都排在相应位置上为止。</p><p>（6）基准记录也称为枢轴（或支点）记录。</p><p>（7）算法：</p><p>取序列第一个记录为枢轴记录，其关键字为Pivotkey。</p><p>指针low指向序列第一个记录位置。</p><p>指针high指向序列最后一个记录位置。</p><p>一趟排序(某个子序列)过程：</p><p>–1.从high指向的记录开始,向前找到第一个关键字的值小于Pivotkey的记录,将其放到low指向的位置,low+1</p><p>–2.从low指向的记录开始,向后找到第一个关键字的值大于Pivotkey的记录,将其放到high指向的位置,high-1</p><p>–3.重复1,2，直到<strong>low=high</strong>，将枢轴记录放在low(high)指向的位置</p><p>对枢轴记录前后两个子序列执行相同的操作，直到每个子序列都只有一个记录为止。</p><p><img src="./../assets/f95f241c8117cf752bb0525a22ee496c.png" alt="img"></p><p>（8）性能分析：</p><p>快速排序是一个递归过程。</p><p>利用序列第一个记录作为基准，将整个序列划分为左右两个子序列。只要是关键字小于基准记录关键字的记录都移到序列左侧。</p><p>如果每次划分对一个记录定位后, 该记录的左侧子序列与右侧子序列的长度相同, 则下一步将是对两个长度减半的子序列进行排序, 这是最理想的情况。</p><p>可以证明, 快速排序的平均计算时间也是O(nlog2 n)。</p><p>实验结果表明: 就平均计算时间而言, 快速排序是所有内排序方法中最好的一个。</p><p>但快速排序是一种不稳定的排序方法。</p><p>（9）在最坏情况下, 即待排序记录序列已经按其关键字从小到大排好序, 其递归树成为单支树, 时间复杂度达O(n2)</p><p>每次划分只得到一个比上一次少一个记录的子序列。</p><p>必须经过n-1 趟才能把所有记录定位,</p><p>而且第 i 趟需要经过 n-i 次关键字比较才能找到第 i 个记录的安放位置，总的关键字比较次数将达到：</p><p><img src="./../assets/3f181f78f7d35eac879f48961b433c8f.png" alt="img"></p><p>（10）改进：枢轴记录取low、high、(low+high)/2三者指向记录关键字居中的记录。</p><h3 id="四、选择排序">四、选择排序</h3><p>1.简单选择排序</p><p>（1）每一趟(例如第i趟,i=0,1,…,n-2)在后面n-i个待排序记录中选出关键字最小的记录,与第i个记录交换。</p><p><img src="./../assets/ad61cbd9d02d81bcfbb48dab261f8ce6.png" alt="img"></p><p>（2）每趟可确定一个数（从前往后）</p><h3 id="算法中的几个表示关系的缩写">算法中的几个表示关系的缩写</h3><p>EQ 就是 EQUAL等于</p><p>NE 就是 NOT EQUAL不等于</p><p>GT 就是 GREATER THAN大于</p><p>LT 就是 LESS THAN小于</p><p>GE 就是 GREATER THAN OR EQUAL 大于等于</p><p>LE 就是 LESS THAN OR EQUAL 小于等于</p><p>（2）性能分析：</p><p>直接选择排序的关键字比较次数 KCN 与记录的初始排列无关。</p><p>设整个待排序记录序列有n个记录,则第i趟选择具有最小关键字记录所需的比较次数总是 n-i-1次。总的关键字比较次数为：</p><p><img src="./../assets/ffa70eadbf35883eece48ef96aafdd95.png" alt="img"></p><p>记录的移动次数与记录序列的初始排列有关。</p><p>当这组记录的初始状态是按其关键字从小到大有序的时候,记录的移动次数RMN=0,达到最少。</p><p>最坏情况是每一趟都要进行交换，总的记录移动次数为 RMN = 3(n-1)。</p><p>直接选择排序是一种不稳定的排序方法。</p><p>2.堆排序</p><p>（1）设有一个关键字集合，按完全二叉树的顺序存储方式存放在一个一维数组中。对它们从根开始，自顶向下，同一层自左向右从 1 开始连续编号。若满足 Ki &gt;=K2i &amp;&amp; Ki &gt;=K2i+1则称该关键字集合构成一个堆(最大堆)</p><p><em><strong>注意：只对根有要求，对左右节点大小关系顺序无要求</strong></em></p><p>（2）最大堆（筛选）：</p><p>输出根结点</p><p>用最后结点代替根结点值（最后的！）</p><p>比较根结点与两个子结点的值，如果小于其中一个子结点，则选择大的子结点与根结点交换</p><p>继续将交换的结点与其子结点比较</p><p>直到叶子结点或者根节点值大于两个子结点</p><p>（2）创建初始堆：</p><p>根据给定的序列，从1至n按顺序创建一个完全二叉树</p><p>由**最后一个非终端结点(第n/2个结点)**开始至第1个结点，逐步做筛选（第n/2个！）</p><p>（3）性能排序</p><p>对于长度为n的序列，其对应的完全二叉树的深度为k(2^(k-1) &lt;= n &lt;= 2^k)</p><p>对深度为k的堆，筛选算法中进行的关键字比较次数至多为2(k-1)次</p><p>堆排序时间主要耗费在建初始堆和调整建新堆(筛选)上</p><p>建初始堆最多做n/2次筛选</p><p>对长度为n的序列，排序最多需要做<strong>n-1次</strong>调整建新堆(筛选)</p><p>因此共需要O(nxk)量级的时间k = log2n</p><p>堆排序时间复杂度为O(nlog2n)</p><p>堆排序是一个不稳定的排序方法</p><p>记录数较多时，推荐堆排序</p><p><img src="./../assets/643a20b4ae55f6c148f36b59a22f4cb3.jpeg" alt="img"></p><h3 id="五、归并排序">五、归并排序</h3><p>1.归并（有序！）</p><p>（1）归并是将两个或两个以上的<strong>有序</strong>表合并成一个新的有序表。</p><p>（2）两路归并</p><p>假设待归并两个有序表长度分别为m和n，则两路归并后，新的有序表长度为m+n</p><p>两路归并操作至多只需要m+n次移位和m+n次比较</p><p>因此两路归并的时间复杂度为O(m+n)</p><p>2.2路－归并排序</p><p>（1）将n个记录看成是n个有序序列</p><p>（2）将前后相邻的两个有序序列归并为一个有序序列(两路归并)（前后相邻！）</p><p>（3）重复做两路归并操作，直到只有一个有序序列为止</p><p><img src="./../assets/e1e594680639ee04d6bfc0401f63d2af.png" alt="img"></p><p>（4）性能分析：</p><p>如果待排序的记录为n个，则需要做log2n趟两路归并排序</p><p>每趟两路归并排序的时间复杂度为O(n)</p><p>因此2路－归并排序的时间复杂度为O(nlog2n)</p><p>归并排序是一种稳定的排序方法</p><p><img src="./../assets/b1b2a294e5da99805595af88dad60921.jpeg" alt="img"></p><h3 id="六、基数排序">六、基数排序</h3><p>1.多关键字的排序(最低位优先法LSD)</p><p>（1）从最低位关键字kd起进行排序，</p><p>（2）然后再对高一位的关键字排序，……</p><p>（3）依次重复，直至对最高位关键字k1排序后，便成为一个有序序列</p><p><img src="./../assets/478eb8c0c814607f2520d04a6316a3fe.png" alt="img"></p><p>2.链式基数排序</p><p>（1）基数排序：借助“分配”和“收集”对单逻辑关键字进行排序的一种方法</p><p>（2）链式基数排序方法：用链表作存储结构的基数排序</p><p>（3）设置10个队列，f[i]和e[i]分别为第i个队列的头指针和尾指针</p><p>（4）第i趟分配：根据第i位关键字的值，改变记录的指针，将链表中记录分配至10个链队列中，每个队列中记录关键字的第i位关键字相同</p><p>（5）第i趟收集：改变所有非空队列的队尾记录的指针域，令其指向下一个非空队列的队头记录，重新将10个队列链成一个链表</p><p>（6）从最低位至最高位，逐位执行上述两步操作，最后得到一个有序序列</p><p><img src="./../assets/1c6a3da9e6d1614f4a9515fd3938560a.png" alt="img"></p><p><img src="./../assets/4654749b5af35d9c60a749580c373b56.png" alt="img"></p><p>（7）性能分析</p><p>若每个关键字有 d 位,关键字的基数为radix 。</p><p>需要重复执行d 趟“分配”与“收集”。</p><p>每趟对 n 个对象进行“分配”，对radix个队列进行“收集”。</p><p>总时间复杂度为O(d(n+radix))。</p><p>若基数radix相同, 对于对象个数较多而关键字位数较少的情况, 使用链式基数排序较好。</p><p>基数排序需要增加n+2radix个附加链接指针。</p><p>基数排序是稳定的排序方法。</p><h3 id="七、各种排序方法比较">七、各种排序方法比较</h3><p><img src="./../assets/e951527d987b045afdb8d574683c3a21.png" alt="img"></p><p><em><strong>注意：在插入和选择排序中，若初始数据基本正序，则选用插入排序。</strong></em></p><p>1.时间性能</p><p>（1）</p><p>时间复杂度为 O(nlogn)：快速排序、堆排序和归并排序</p><p>时间复杂度为 O(n^2)：直接插入排序、冒泡排序、简单选择排序</p><p>时间复杂度为 O(n): 基数排序</p><p>（2）当待排记录序列按关键字顺序有序时</p><p>直接插入排序和起泡排序能达到O(n)的时间复杂度；</p><p>快速排序的时间性能蜕化为O(n^2) 。</p><p>（3）简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。</p><p>2.空间性能</p><p>（1）指的是排序过程中所需的辅助空间大小</p><p>（2）所有的简单排序方法(包括：直接插入、起泡和简单选择) 和堆排序的空间复杂度为O(1)</p><p>（3）快速排序为O(logn)，为递归程序执行过程中，栈所需的辅助空间；</p><p>（4）归并排序所需辅助空间最多，其空间复杂度为 O(n);</p><p>（5）链式基数排序需附设队列首尾指针，则空间复杂度为 O(rd)。</p><p>3.排序方法的稳定性能</p><p><strong>口诀：考试情绪不稳定，就快些选堆朋友吧！</strong></p><p><strong>（不稳定：快-&gt;快速排序，些-&gt;希尔排序，选-&gt;直接选择排序，堆-&gt;堆排序）</strong></p><p>（1）稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。</p><p><img src="./../assets/7b8e05180e4e098cce7dfbe243486733.png" alt="img"></p><p>（2） 当对多关键字的记录序列进行LSD方法排序时，必须采用稳定的排序方法。</p><p>（3）对于不稳定的排序方法，只要能举出一个实例说明即可。</p><p>（4）快速排序、堆排序和希尔排序是不稳定的排序方法。</p><p>（5）所有时间复杂度为O(n^2) 的简单排序算法都是稳定的（直接选择排序算法除外）。</p><p>（6）归并排序和基数排序是稳定的。</p><p>所有排序整理：</p><p><img src="./../assets/c908938a22520d9d02cadbae61b87421.jpeg" alt="img"></p>]]></content>
    
    
    <summary type="html">收集到的数据结构复习资料</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
