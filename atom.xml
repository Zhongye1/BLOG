<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柊野的博客</title>
  
  
  <link href="https://zhongye1.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhongye1.github.io/"/>
  <updated>2024-09-19T15:59:45.015Z</updated>
  <id>https://zhongye1.github.io/</id>
  
  <author>
    <name>柊野</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客站的一周年</title>
    <link href="https://zhongye1.github.io/posts/7391b3fc.html"/>
    <id>https://zhongye1.github.io/posts/7391b3fc.html</id>
    <published>2024-09-18T15:36:24.000Z</published>
    <updated>2024-09-19T15:59:45.015Z</updated>
    
    <content type="html"><![CDATA[<BR><center>柊野的博客站</center><center>  2023.9.18   ==>  2024.9.18</center><BR><p><img src="https://pic3.zhimg.com/80/v2-9cfcd118a35efe2fc85045ffc89897d4_720w.webp" alt="img" style="zoom:67%;" /></p><BR><BR><BR><center>仅以此纪念我在广东南漂的又一年</center><center> 也以此怀念我的故乡 </center><center>以及那些无从记录的过往 </center><BR><BR><center> 故事往往因鲜为人知而被掩饰，困苦因困而苦 </center><center> 这片旷野是四面八方的，而前进是选择不是逆行 </center><BR><BR><p><img src="https://pic4.zhimg.com/80/v2-1f36bcd074963f0e9c5df29e9ed4fa07_720w.webp" alt="img" style="zoom:67%;" /></p><center> 摄于湖北屋后原野 </center>]]></content>
    
    
    <summary type="html">2023.9.18   ==&gt;  2024.9.18</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://zhongye1.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>九月</title>
    <link href="https://zhongye1.github.io/posts/fd12c93d.html"/>
    <id>https://zhongye1.github.io/posts/fd12c93d.html</id>
    <published>2024-09-17T08:30:15.000Z</published>
    <updated>2024-09-19T16:00:41.424Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="tip "><p>9月1日</p></div><p><img src="https://pic4.zhimg.com/80/v2-5415b3941d1e8c38796689255c41f7c7_720w.webp" alt="img" style="zoom:50%;" /></p><p><img src="https://pic2.zhimg.com/80/v2-b741d4b5996a9d758d16ce1887a15979_720w.webp" alt="img" style="zoom:50%;" /></p><p><img src="https://pic1.zhimg.com/80/v2-038b40ade38253649ea6c49bd73f4578_720w.webp" alt="img" style="zoom:50%;" /></p><p>满校区跑，开学焦虑了</p><p>顺便混了下图书馆,借了几本关于网站建设的书。</p><p>翻了下RSS订阅时，读到一段话</p><blockquote><p>今天好像有一股力量在努力把这些超越性的东西从我们的社会生活里清理出去。</p><p>人很渺小，但是人不应该因为自己渺小就要消灭所有伟大。</p><blockquote><p><a href="https://lenciel.com/2024/08/bu-er-qi-xi/">不二与偏要二 - @Lenciel</a></p></blockquote></blockquote><hr><div class="tip "><p>9月2日</p></div><p>概率论挂科率高？我卷死你</p><p>重装了下python</p><p>大一完全是瞎搞，把一堆东西瞎装，现在重新清理一下</p><p><img src="https://pic1.zhimg.com/80/v2-60f4739c4831e87cdabcc073c6bb9b56_720w.webp" alt="img"></p><p>毕竟要开课了</p><p>虽然觉得VScode更好用</p><p>日后再说</p><hr><div class="tip "><p>9月3日</p></div><p>老师推荐的logseq做笔记没博客好用</p><p>都是写markdown，博客还支持HTML CSS JS 各种页面和嵌入</p><p>不过这个归档页面不错</p><p><img src="https://free-img.400040.xyz/4/2024/09/03/66d72d9cc24ea.png" alt="img"></p><hr><div class="tip "><p>9月4日</p></div><p>一周只有周三晚上没课，难得的没课的时间，去了下黄埔</p><p><img src="https://pic1.zhimg.com/80/v2-9f00a60097520cd098ba2595850b6ec8_720w.webp" alt="img"></p><p><img src="https://pica.zhimg.com/80/v2-b4339a2f1a73d24af123d0425d6133f0_720w.webp" alt="img"></p><p>参观了一下四八零一工厂和军校旧址</p><hr><div class="tip "><p>9月5日</p></div><p>我觉得当初选课时的自己有点毛病</p><p>选那么多那么杂生怕期末不会死</p><p>反正现在完蛋了</p><p>之前的笔记本还要找一下</p><p>然后周末只能泡图书馆了</p><p>最近开销挺多，到时候看看倒卖个人简历网页能不能赚钱</p><p><img src="https://pic2.zhimg.com/80/v2-5570178f83684b066dfd65d5255fe6a5_720w.webp" alt="img" style="zoom:50%;" /></p><hr><div class="tip "><p>9月8日</p></div><p>突发奇想想去实验室打杂</p><p>犯浑啊…</p><p>一想我大学以来一直在犯浑也不差这一下</p><p>反正邮件已经发了</p><p>那剩下要做的只有等死了…</p><p>……</p><p>感觉大一上挂科的高代永远是大学阴影了…</p><p>好像还得罪了专业负责人（被嫌弃了</p><p>-</p><p>无思绪，遂出门散心</p><p><img src="https://pic4.zhimg.com/80/v2-858ceb75cce1e638a725d26c1cabdb13_720w.webp" alt="img" style="zoom:50%;" /></p><p><img src="https://pica.zhimg.com/80/v2-bf889a8b690a9fe2af6f0ba37258fe66_720w.webp" alt="img" style="zoom:50%;" /></p><p>大二会怎样呢</p><p>过去和未来的压力都无形无色的加于自己</p><p>然后没办法应对</p><p>能力不够</p><p>-</p><p>希望这些局面会有所改观</p><p>在珠江边如是想道</p><p>-</p>    <div id="aplayer-MdwRXkXF" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1860234957" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>那今天算是结束了，下周是更满的课程</p><p>先睡了罢</p><p>以后有的过的…</p><hr><div class="tip "><p>9月11日</p></div><p>九月份快中秋了还这么热</p><p>也许当初我回了湖北读大学的话</p><p>在这个时候天气会不会凉快点</p><p>顺便跑长江边或者去看东湖</p><p>天气会更快冷下来而且冬天会下雪</p><p>回老家也方便</p><p>-</p><p>不过没有机会说如果了，这是我在广州的第二年，今年入秋估计特别晚</p><p>而且冬天不会下雪的</p><p>毕竟南漂嘛</p><p>…</p><hr><p>放一首歌，另外希望自己能早点走出来</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=861659785&bvid=BV1nV4y1w74h&cid=935573523&autoplay=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts" width="100%" autoplay="0"></iframe><p><em>如果可以 就由我来改变世界，</em><br><em>至于消灭战争，</em><br><em>或许有些太过伟大，</em><br><em>不过偶尔也会如此奢望，</em><br><em>演员明星什么的 本就离我遥远，</em><br><em>且不谈这些，</em><br><em>光是在你面前我都扭扭捏捏，</em><br><em>一定很令人为难吧…</em><br><em>啊…</em><br><em>是哪里弄错了吗？</em><br><em>我不知道，</em><br><em>于是左右摇晃 摇晃，</em><br><em>本就一无所有 可心痛依旧，</em><br><em>我们的心总会连在一起，</em><br><em>然后左右冲撞 冲撞，</em><br><em>冲破冻结的岩层，</em><br><em>奔向远方…</em></p><p>「我們出生本來就一無所有，卻因為害怕犯錯與失去些什麼而逐漸變得膽小。即便如此還是下定唱出要赤裸的在這世界中翻滾的決心。」</p><p><strong>啊…那么，谢谢收听！</strong></p><p><strong>波奇酱和结束乐队在摄像机前的日常到这里就结束了，而我们的日常还在继续。</strong></p><hr><div class="tip "><p>9月12日</p></div><p>成功了</p><p>找到了愿意带科研项目的老师</p><p>总之先研究一些材料罢</p><p>路还长着，睡了</p><p>祝顺利…</p><p>另外明天建一个新页面用于存放笔记</p><p><img src="https://pic2.zhimg.com/80/v2-18131b90cf89b2997d895cae47d77419_720w.webp" alt="img" style="zoom:33%;" /></p><hr><div class="tip "><p>9月13日</p></div><p>一直在犯浑</p><p>当初那么选课真的是生怕自己期末寄不了</p><p>觉得自己学的不够好还想再学一遍（</p><p>幸好改了（逃</p><p>我的大学生活已经够丧了不想再添油加醋了（</p><p>然后的话就是不能再摸鱼了</p><p>这个项目要做起来</p><p>好像周末要汇报啥的</p><p><s>过个中秋再看罢</s></p><p>有时间就研究下</p><p><s>结果听了一晚上摇滚</s></p>    <div id="aplayer-wHnqJADy" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="8926752857" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><img src="https://pic2.zhimg.com/80/v2-fe88022d1ddd727c237dec5cc1706e47_720w.webp" alt="img" style="zoom:50%;" /></p><center>古早前存的，找了好久的图</center><p>此外中秋记得回来带个路由器到学校研究</p><p>技术宅拯救世界</p><hr><div class="tip "><p>9月16日</p></div><p>路由的研究告一段落性的失败了</p><p>技术难度不说实用性也低不如直接接网线</p><p>计网原理还得学</p><p>目前要推进的是手头上另外一个项目</p><p>此外</p><p>想去漫展打工赚点零花费顺便薅场地门票</p><p>不过CICF招临时工的话又是投简历又是面试是否有点太夸张了</p><p><img src="https://pic4.zhimg.com/80/v2-407795a7f2413a65fb586d900ba9430b_720w.webp" alt="img" style="zoom:33%;" /></p><hr><div class="tip "><p>9月17日</p></div><p>越是冷峻的环境越是要让人要有所作为</p><p>总要有有梦想有情怀有实力的人来解决问题</p><p>面对现实的一堆不平更是如此</p><p>·</p><p>另外……</p><p>在中秋之际祝自己节日快乐</p><hr><div class="tip "><p>9月19日</p></div><p>事情好多想鸽又不敢鸽</p><p>（倒</p>]]></content>
    
    
    <summary type="html">即便如此還是下定唱出在這世界中翻滾的決心</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://zhongye1.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>制作自己的校园网路由器</title>
    <link href="https://zhongye1.github.io/posts/1e8f513f.html"/>
    <id>https://zhongye1.github.io/posts/1e8f513f.html</id>
    <published>2024-09-03T15:43:18.000Z</published>
    <updated>2024-09-04T10:00:12.972Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="怎么制作自己的校园网路由器（广州大学版）"><a href="#怎么制作自己的校园网路由器（广州大学版）" class="headerlink" title="怎么制作自己的校园网路由器（广州大学版）"></a>怎么制作自己的校园网路由器（广州大学版）</h1><p><img src="https://www.talaxy.site/static/fb1ffc836d6d829688c0ba281ed33cca/3999e/img.png" alt="动手编译适合自己路由器的 ipk"></p><p><strong>2024年更</strong></p><p>庆已使用web端进行校园网认证，路由器已经不再需要使用插件登录模拟登录</p><p>但是同时一个账户只能有一台设备通过web登录，包括无感登录的设备，即最多只有两台设备可以直接接入校园网</p><p>而使用锐捷认证的不记在内，也就是说可以同时有3台设备直接接入校园网，如果带多台设备上课的话体验有比较大的提升</p><p>对于多人使用的情况，使用插件登录也不会占用某人的校园网账号，导致某人无法使用校园网wifi，有利于宿舍和谐</p><p>我现在是使用方式是在宿舍的电脑用web登录，在教学区通过手机热点让其他设备接入，勉强能用（校园网本来就烂，经过手机转发雪上加霜，导致远程桌面延时明显提升）</p><p>最后，这项技术对于普通的同学意义已经不是很大了，但也算是10年代技术大佬为后人留下的丰碑吧</p><hr><p>庆用的是锐捷的系统，你能买到的锐捷校园网路由器都大同小异，直接购买即可</p><p>此文主要是写给愿意折腾的同学，将我本人组all in one服务器踩到的一些坑分享给大家，如果你想用树莓派软路由、x86虚拟机软路由抑或是自行刷机，甚至是想做路由器赚钱，都可以参考此文</p><p>不多bb，我们所要做的就是在路由器上安装一个插件，用这个插件客户端进行认证，以此来接入校园网</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185331-b6mr6li-20240523140847-q34j0zx.png" alt="image"></p><p>主流的插件有华中科技大学大佬开发的mentohust</p><p><a href="https://github.com/hyrathb/mentohust">hyrathb/mentohust: mentohust加入v4支持 (github.com)</a></p><p>和其算法开发的minieap</p><p><a href="https://github.com/updateing/minieap">updateing/minieap: 可扩展的 802.1x 客户端，带有锐捷 v3 (v4) 算法插件支持 (github.com)</a></p><p>minieap庆内亲测可用，以下以minieap为例</p><h2 id="一、装系统"><a href="#一、装系统" class="headerlink" title="一、装系统"></a>一、装系统</h2><p>主流的开源路由器系统为openwrt，各种插件也是基于此开发的，先给你的机子安装上openwrt，方法各异自行百度，也可以直接买刷好op的</p><h2 id="二、搞到插件"><a href="#二、搞到插件" class="headerlink" title="二、搞到插件"></a>二、搞到插件</h2><p>openwrt是基于linux的，不同的处理器都可以安装openwrt，但编译好的固件只能用于一种架构的处理器，如果网上找不到，只能自行编译插件（编译环境的处理器架构和最终成品的处理器架构没关系）</p><p>我们需要编译minieap-gzhu、luci-proto-minieap，前者为认证插件本体，后者为其界面，openwrt的软件包是ipk文件</p><blockquote><p>个人编译的x86架构插件，x86软路由或者x86虚拟机可直接用</p><p>链接：<a href="https://pan.baidu.com/s/16GR_BS3LvcJf1Y4KcQuuDA">https://pan.baidu.com/s/16GR_BS3LvcJf1Y4KcQuuDA</a><br>提取码：6tmt</p><p>本文参考 <a href="https://www.talaxy.site/mentohust-minieap/">动手编译适合自己路由器的 ipk | 雪山深处 (talaxy.site)</a> 另一位学长的教程</p></blockquote><h3 id="0-准备好魔法环境"><a href="#0-准备好魔法环境" class="headerlink" title="0. 准备好魔法环境"></a>0. 准备好魔法环境</h3><p>dddd</p><h3 id="1-安装linux环境"><a href="#1-安装linux环境" class="headerlink" title="1. 安装linux环境"></a>1. 安装linux环境</h3><p>推荐使用wsl或者其他虚拟机（虚拟机网络请使用nat模式）方法自行百度</p><h3 id="1-5-推荐使用ssh控制linux用scp拷文件（直接在虚拟机钟使用图形化界面也不是不行）"><a href="#1-5-推荐使用ssh控制linux用scp拷文件（直接在虚拟机钟使用图形化界面也不是不行）" class="headerlink" title="1.5 推荐使用ssh控制linux用scp拷文件（直接在虚拟机钟使用图形化界面也不是不行）"></a>1.5 推荐使用ssh控制linux用scp拷文件（直接在虚拟机钟使用图形化界面也不是不行）</h3><p>安装ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>宿主机推荐使用winscp客户端连接虚拟机ssh</p><h3 id="2-安装编译环境依赖"><a href="#2-安装编译环境依赖" class="headerlink" title="2. 安装编译环境依赖"></a>2. 安装编译环境依赖</h3><p>终端钟敲入以下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git-core build-essential libssl-dev libncurses5-dev unzipgawk subversion mercurial</span><br><span class="line">sudo apt-get install ccache</span><br></pre></td></tr></table></figure><h3 id="3-下载openwrt-sdk（openwrt编译工具）并解压"><a href="#3-下载openwrt-sdk（openwrt编译工具）并解压" class="headerlink" title="3. 下载openwrt sdk（openwrt编译工具）并解压"></a>3. 下载openwrt sdk（openwrt编译工具）并解压</h3><p>推荐解压目录到~目录，否则有报错的可能，注意，不可使用root账户编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://downloads.openwrt.org/releases/21.02.0/targets/x86/64/openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64.tar.xz</span><br><span class="line">xz -dk openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64.tar.xz</span><br><span class="line">tar xvf openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64.tar</span><br></pre></td></tr></table></figure><p>该命令目的在于把文件sdk文件解压到~/目录，如果上述命令执行失败，可以手动将压缩包解压后上传linux</p><h3 id="4-开始编译"><a href="#4-开始编译" class="headerlink" title="4. 开始编译"></a>4. 开始编译</h3><h4 id="a-编译minieap-gzhu"><a href="#a-编译minieap-gzhu" class="headerlink" title="a. 编译minieap-gzhu"></a>a. 编译minieap-gzhu</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>进入sdk目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ysc3839/openwrt-minieap.git -b gzhu package/minieap</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>将插件源码克隆到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>进入编译菜单，依次选择 “Network” “minieap” “save” “OK” 然后退出到命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make package/minieap/compile V=s</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>开始编译</p><p>ipk 文件就在 bin/packages/(处理器架构)/base/</p><h4 id="b-编译luci-proto-minieap"><a href="#b-编译luci-proto-minieap" class="headerlink" title="b. 编译luci-proto-minieap"></a>b. 编译luci-proto-minieap</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/openwrt-sdk-21.02.0-x86-64_gcc-8.4.0_musl.Linux-x86_64</span><br></pre></td></tr></table></figure><p>进入sdk目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/feeds update luci</span><br><span class="line">./scripts/feeds install-a</span><br></pre></td></tr></table></figure><p>安装 luci feed</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ysc3839/luci-proto-minieap.git package/luci-proto-minieap</span><br></pre></td></tr></table></figure><p>将插件源码克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>进入编译菜单，依次选择依次选择 “LuCI” “Protocols” “luci-proto-minieap” “save” “OK” 然后退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make package/luci-proto-minieap/compile V=s</span><br></pre></td></tr></table></figure><p>开始编译</p><p>ipk 文件就在 bin/packages/(处理器架构)/base/</p><h2 id="三、-安装插件"><a href="#三、-安装插件" class="headerlink" title="三、 安装插件"></a>三、 安装插件</h2><p>将刚刚得到的ipk包传入openwrt系统中，如果你的openwrt安装了文件传输插件，那可以直接用，如果没有，也可以用ssh传上去，以下演示假设传到了根目录上</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185404-j1pryjq-20240523140847-fdmqe0f.png" alt="image"></p><p>菜单栏选择“系统”&gt;&gt; “软件包”（外观不同，但是选项应该是一样的）</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185411-71u1wdu-20240523140847-scegqzs.png" alt="image"></p><p>直接点击安装即可，如果没有文件管理插件或者是你的文件管理插件没有这个功能</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185431-iipews6-20240523140848-lvse9vy.png" alt="image"></p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185426-lereul2-20240523140848-t2bv084.png" alt="image"></p><p>点击确认即可安装</p><h2 id="四、-使用插件"><a href="#四、-使用插件" class="headerlink" title="四、 使用插件"></a>四、 使用插件</h2><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185441-2vywcuq-20240523140848-iqrhv3j.png" alt="image"></p><p>点击“网络”&gt;&gt; “接口”</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185444-w4mjro7-20240523140848-9jjf83q.png" alt="image"></p><p>选择“新接口”</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185448-8nedism-20240523140849-h93yhbr.png" alt="image"></p><p>协议选择“MiniEAP client”，名字随便，接口选择你的wan口，每个接口对应一个物理接口或者虚拟接口，需要根据自己的实际情况选择，该接口要连接到宿舍校园网网口</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185452-ntvaqpm-20240523140849-q0hetku.png" alt="image"></p><p>账户密码就是你校园网的，Packet plugins选我这个</p><p><img src="https://blog.carry.fit//upload/net-img-image-20240430185458-rm0nx1f-20240523140849-111kgo7.png" alt="image"></p><p>然后将DHCP type改成我这个</p><p>不出意外的话就可以愉快使用了</p><p>转自：<a href="https://blog.carry.fit/archives/how-to-make-your-own-campus-network-guangzhou-university-edition-avb6x">怎么制作自己的校园网路由器（广州大学版） - carry blog</a></p>]]></content>
    
    
    <summary type="html">如何制作自己的校园网路由器（广州大学版）</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="校园网" scheme="https://zhongye1.github.io/tags/%E6%A0%A1%E5%9B%AD%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>关于Jupyter汉化问题</title>
    <link href="https://zhongye1.github.io/posts/3de5091.html"/>
    <id>https://zhongye1.github.io/posts/3de5091.html</id>
    <published>2024-09-02T15:49:05.000Z</published>
    <updated>2024-09-02T15:58:47.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决新版Jupyter-notebook-v7-0-0及以上-汉化、默认保存路径等问题"><a href="#解决新版Jupyter-notebook-v7-0-0及以上-汉化、默认保存路径等问题" class="headerlink" title="解决新版Jupyter notebook(v7.0.0及以上)汉化、默认保存路径等问题"></a>解决新版Jupyter notebook(v7.0.0及以上)汉化、默认保存路径等问题</h2><h3 id="一-Jupyter-notebook-v7-0-0及以上汉化"><a href="#一-Jupyter-notebook-v7-0-0及以上汉化" class="headerlink" title="一. Jupyter notebook v7.0.0及以上汉化"></a>一. Jupyter notebook v7.0.0及以上汉化</h3><p><strong>注意！在环境变量中添加如下用户变量仅适用于Jupyter v6及以下版本，不再适用于Jupyter v7</strong><br><img src="https://free-img.400040.xyz/4/2024/09/02/66d5df36ec7d2.png" alt="在这里插入图片描述"><br><strong>Jupyter v7汉化方法如下</strong></p><p>1.打开<a href="https://so.csdn.net/so/search?q=命令行&amp;spm=1001.2101.3001.7020">命令行</a>或者Anaconda Prompt，运行如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyterlab-language-pack-zh-CN</span><br></pre></td></tr></table></figure><p>2.运行Jupyter notebook，选择settings中的Language，替换中文<br><img src="https://free-img.400040.xyz/4/2024/09/02/66d5df33aa570.png" alt="在这里插入图片描述"></p><h3 id="二-修改Jupyter-notebook默认保存路径"><a href="#二-修改Jupyter-notebook默认保存路径" class="headerlink" title="二. 修改Jupyter notebook默认保存路径"></a>二. 修改Jupyter notebook默认保存路径</h3><p><strong>这里先介绍一种万能（不嫌麻烦）的方法</strong><br>1.打开命令行或者Anaconda Prompt，运行如下代码，其中D:\JupyterWorkspace可以修改成你想要Jupyter保存的任意路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook D:\JupyterWorkspace</span><br></pre></td></tr></table></figure><p><strong>这种方法的优点是很灵活<br>缺点是每次启动都需要用命令行或者Anaconda Prompt</strong></p><p><strong>下面介绍一种一本万利（fu za）的方法</strong><br>1.打开命令行或者Anaconda Prompt，运行如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>2.运行后会提示创建完jupyter_notebook_config.py文件，以及它所在的路径，我们直接复制路径找到这个.py文件<br>3.用记事本打开它，CTRL+F查找<strong>notebook_dir</strong>，会搜索到这一行（适用旧版）<br>3.用记事本打开它，CTRL+F查找<strong>root_dir</strong>，会搜索到这一行（适用新版）</p><blockquote><p>#c.NotebookApp.notebook_dir = ‘path’ # 旧版查找这一行<br>#c.ServerApp.root_dir = ‘path’ # 更正，最新版应该查找这一行</p></blockquote><p>有些电脑搜到的可能是#c.ServerApp.notebook_dir = ‘path’，不过没什么影响<br>4.将path替换成自己想要保存的路径，直接复制文件夹路径的话一定要将 \ 改成 // ，并将这一行前面的#去掉**，保存文件<br>5.右键Jupyter notebook选择属性，按下图设置即可<br><img src="https://free-img.400040.xyz/4/2024/09/02/66d5df33b83ca.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">解决新版Jupyter(v7.0.0及以上)汉化、默认保存路径等问题</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>自定义VSCode背景图片</title>
    <link href="https://zhongye1.github.io/posts/533329c2.html"/>
    <id>https://zhongye1.github.io/posts/533329c2.html</id>
    <published>2024-09-02T15:39:00.000Z</published>
    <updated>2024-09-02T15:56:33.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于如何自定义VSCode背景图片"><a href="#关于如何自定义VSCode背景图片" class="headerlink" title="关于如何自定义VSCode背景图片"></a>关于如何自定义VSCode背景图片</h2><h4 id="1-以管理员身份运行VS-Code，安装background插件"><a href="#1-以管理员身份运行VS-Code，安装background插件" class="headerlink" title="1.以管理员身份运行VS Code，安装background插件"></a>1.以管理员身份运行VS Code，安装background插件</h4><p><img src="https://pica.zhimg.com/80/v2-b5a35f698b7589c7090b1bfa2a2963b8_720w.webp" alt="img"></p><h4 id="2-打开setting，在搜索框中输入background，选择扩展中的plugin-background，选择在setting-json中编辑"><a href="#2-打开setting，在搜索框中输入background，选择扩展中的plugin-background，选择在setting-json中编辑" class="headerlink" title="2.打开setting，在搜索框中输入background，选择扩展中的plugin background，选择在setting.json中编辑"></a>2.打开setting，在搜索框中输入background，选择扩展中的plugin background，选择在setting.json中编辑</h4><p><img src="https://pic3.zhimg.com/80/v2-3e406502b1294ad2bcc6a9425c208eb2_720w.webp" alt="img"></p><h4 id="3-在用户设置中输入以下代码，修改完后保存，会提示重启VS-Code，点击确定后即可完成修改"><a href="#3-在用户设置中输入以下代码，修改完后保存，会提示重启VS-Code，点击确定后即可完成修改" class="headerlink" title="3.在用户设置中输入以下代码，修改完后保存，会提示重启VS Code，点击确定后即可完成修改"></a>3.在用户设置中输入以下代码，修改完后保存，会提示重启VS Code，点击确定后即可完成修改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//background 的相关配置</span></span><br><span class="line">    <span class="string">&quot;update.enableWindowsBackgroundUpdates&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;background.customImages&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;file:///F:/Picture/Yukino/vs_background.png&quot;</span><span class="comment">//图片地址（支持http</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;background.style&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;content&quot;</span>:<span class="string">&quot;&#x27;&#x27;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pointer-events&quot;</span>:<span class="string">&quot;none&quot;</span>,</span><br><span class="line">        <span class="string">&quot;position&quot;</span>:<span class="string">&quot;absolute&quot;</span>,<span class="comment">//图片位置</span></span><br><span class="line">        <span class="string">&quot;width&quot;</span>:<span class="string">&quot;100%&quot;</span>,</span><br><span class="line">        <span class="string">&quot;height&quot;</span>:<span class="string">&quot;100%&quot;</span>,</span><br><span class="line">        <span class="string">&quot;z-index&quot;</span>:<span class="string">&quot;99999&quot;</span>,</span><br><span class="line">        <span class="string">&quot;background.repeat&quot;</span>:<span class="string">&quot;no-repeat&quot;</span>,</span><br><span class="line">        <span class="string">&quot;background-size&quot;</span>:<span class="string">&quot;25%,25%&quot;</span>,<span class="comment">//图片大小</span></span><br><span class="line">        <span class="string">&quot;opacity&quot;</span>:<span class="number">0.2</span> <span class="comment">//透明度</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;background.useFront&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;background.useDefault&quot;</span>: <span class="literal">false</span>,<span class="comment">//是否使用默认图片</span></span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-504cbda92dbe5de68c9372b9b8197a31_720w.webp" alt="img"></p><p>效果如下：</p><p><img src="https://pica.zhimg.com/80/v2-3ba8478d3556441d49b22ac1598855ee_720w.webp" alt="img"></p>]]></content>
    
    
    <summary type="html">关于如何自定义VSCode背景图片</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>八月</title>
    <link href="https://zhongye1.github.io/posts/87dfe862.html"/>
    <id>https://zhongye1.github.io/posts/87dfe862.html</id>
    <published>2024-08-29T16:31:02.000Z</published>
    <updated>2024-08-31T14:44:13.438Z</updated>
    
    <content type="html"><![CDATA[<div class="tip "><p>8月1日</p></div><div class="fj-gallery"><p><img src="https://pic3.zhimg.com/80/v2-193d7b78c90201ecbf616cc0a07ce5aa_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-1e5f7949d227f9c8e619d1590968768b_720w.webp" alt="img"></p>          </div><p>到货了，好好好</p><ul><li></li></ul><p>今天NAS建站的尝试是暂时失败了，校园墙的复活有点难</p><p>其实部署网站就之前续费雨云30块一个月服务器的事，简单的很，</p><p>绕这么多弯路存粹不想多花钱（</p><p>不过校园墙这块还是让别人来做算了</p><p>我这种人搞不好的，毕竟运营力大于技术能力，之前搭好了也没人访问</p><p>毕竟让一个进入大学以来几乎没有社交的人来运营的话就是不太合适</p><ul><li></li></ul><p>有时间不如刷番刷漫画啥的</p><p><img src="https://pic1.zhimg.com/v2-b2ee8e1083fda5de4e42aa144af19b60_b.jpg" alt="img"></p><hr><div class="tip "><p>8月3日</p></div><p>尝试搞个QQ机器人<br>接一个GPT<br>不过搭好后好像很鸡肋<br>遂搁置</p><hr><div class="tip "><p>8月4日</p></div><p>给博客加了个访客IP地图</p><p>虽然真要实现预想的效果要做个后端来着（</p><p>也没有搞，有个效果就行</p><p><img src="https://pic3.zhimg.com/80/v2-deb7fa83da6accc4def5a21d5bca886a_720w.webp" alt="img"></p><p><em>（百度的API好烂）</em><br>成品如下：</p><div class="site-card-group"><a class="site-card" href="https://zhongye1.github.io/posts/a8a0d075.html"><div class="img"><img src="https://pic3.zhimg.com/80/v2-deb7fa83da6accc4def5a21d5bca886a_720w.webp"/></div><div class="info"><img src="https://pic1.zhimg.com/80/v2-88d2ec402c1018cec57110c295e85a30_720w.webp"/><span class="title">Blogmap</span><span class="desc">博客访客IP</span></div></a></div><hr><div class="tip "><p>8月5日</p></div><p>所以说暑假就是一段迷茫的时间，除了搁置许久的项目和令人昏昏欲睡的又湿又热的天气没什么其他的什么。</p><p>还要考驾照，不知道要折腾到什么时候，反正回老家得等到寒假了</p><p>…</p><p>放个歌</p>    <div id="aplayer-KOxVeErG" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2020981543" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><em>~~~ 你知道掉下的不是眼泪</em></p><p><img src="https://picx.zhimg.com/80/v2-1492e41f463a164d71062de4e615d7ad_720w.webp?source=d16d100b" alt="img"></p><hr><div class="tip "><p>8月7日</p></div><p>那个驾校的是个究极压力怪</p><p>一想以后还会遇到越来越多这样的人（虽然以前也有一堆）</p><p>这样的话在大学毕业后要和许多这样的人打交道的话</p><p>以后还会出现啥其他情况也说不定</p><p>这就显得让人头疼了</p><p>=============================================</p><p>给博客加了个新页面，扒了一些代码</p><p>反正没人会看的，（好中二）</p><p>就这样吧，附上SITEPOST和<a href="https://zhongye1.github.io/AKN/">链接</a></p><img src="https://pic4.zhimg.com/80/v2-2cab37aed4fd6e18c2c86aef17568beb_720w.webp" alt="img" style="zoom:50%;" /><center>https://zhongye1.github.io/AKN/</center><p>曾希望能在某段经历的时间段中能多留一点，结果是这个想法连着这段不舍的经历一同忘去，</p><p>最后自己去迎接将来那些破事。</p><hr><div class="tip "><p>8月14日</p></div><p><img src="https://pica.zhimg.com/80/v2-29276bc35ff75d9738058a97a5e8872f_720w.webp?source=d16d100b" alt="img"></p><p>啊，是的没多久我的暑假也要结束了</p><p>莫名伤感</p><p>好嘛，下半年比谁都要忙的来着</p><p>也无所谓了</p><img src="https://pic4.zhimg.com/80/v2-187b2461e74eb982b34e7b177b654243_720w.webp" alt="img" style="zoom:67%;" /><p>看到有人拿我的模型做mod还是挺高兴的，没想到还会有被称为佬的一天（</p><img src="https://pic2.zhimg.com/80/v2-1a0251a342876b19b20aa5ed2cb2bc49_720w.webp" alt="img" style="zoom:67%;" /><p>附一张blender摸鱼的记录</p><p>暑假结束的话又要回广州，下半年的话希望新舍友会好点（虽然平时大概率宅图书馆</p><p>希望生活对我也好点。</p><p>.</p><p>其实过的怎么样还是怎么样，不过有点愿景的话也好点</p><p>面对这些的话还是要靠自己</p><p>.</p><p>.</p><p>想当初同感的一个人看上去孤独的人是一个超级现充</p><p>（艹</p><p>这是好事</p><ul><li></li></ul><p>我一想这一年：</p><p>读大学以来几乎没社交</p><p>认识的人都不认识自己</p><p>从没有和人一起出去过</p><p>爱好也完美的岔开了</p><p>不满消费主义和购物街旅游景区</p><p>经常听摇滚又不摇滚</p><p>天天发病然后留黑历史</p><p>经常晚上偷偷写博客</p><p>然后第二天爬起来把写的一堆东西删掉</p><p>经常普通话不标准</p><p>自己还听不出来</p><p>qq资料卡别人都几千赞上万赞</p><p>自己8年老号就百来个赞</p><p>宅</p><p>不喜欢流行文化</p><p>而喜欢上个世纪的东西</p><p>经常几个番反复看又不想看新番</p><p>游戏打不动</p><p>经常囊中羞涩</p><p>经常喜欢捣鼓些有的无的</p><p>喜欢冷门的东西又不想火起来</p><p>（比方说喜欢的乐队火起来就不纯粹了</p><p>（成了网红热门乐队的话还会摇滚吗</p><p>经常写些没人看的东西</p><p>同时很多想法还没记下来就第二天了</p><p>…</p><p>扯远了</p><p>反正我预感大学四年我也交不到几个朋友</p><p>只会忙些有的无的</p><p>然后毕业了去社会了还会一个人吗(倒)</p><p>然后就理所当然的是职场和加班吗</p><p>以前还幻想过搞科研来着</p><ul><li></li></ul><p>这个社会对不善交际的人的恶意还是太大了</p><p>本以为自己做了许多其实啥都没做</p><p>写博客也是</p><hr><p>这个夏天没能回去</p><p>那下次回去的话就是冬天了吧</p><p>到时候还会有这种原野吗</p><p><img src="https://picx.zhimg.com/80/v2-9d1eb0ef93647afb21f0c22f16142be3_720w.webp?source=d16d100b" alt="img"></p><p><em>黎</em></p><p><em>正月初</em></p><p><em>风吹花遍野</em></p><p><em>低头看野草春生</em></p><p>我多次走到此路上，却永远走不到开县的另一端</p><hr><p>这边的话</p><p>都不容易，</p><p>毕竟我只是个写博客牢骚的屑</p><p>在这个角落写下自己的故事</p><p>然后默默删掉</p><p>…</p><p>生活啊</p><p>我的过往只有过去了</p><p>当一切都变了后</p><p>那时我将走向何方？</p><p>若十几年后一切都翻天覆地</p><p>在时间过去后我还会记得吗</p><p>我生活过的这些日子里</p><p>苍白里的彩色</p><p>这些故事还会继续吗</p><p>还会在吗</p><p>其实会很难的吧…</p><hr><div class="tip "><p>8月18日凌晨</p></div><p><img src="https://pic2.zhimg.com/80/v2-f1f9cc470d441d125d9f0a021009ca79_720w.webp" alt="img"></p><p>也许再过几年生活会因些意外而截然不同</p><p>过去的往往因鲜为人知而被掩饰</p><p>未来的旷野在四面八方</p><p><img src="https://pic3.zhimg.com/80/v2-01619bae5eb61073b060beb53ba2ff1e_720w.webp" alt="img"></p><center>凌晨，夜失眠日益加重，遂出门摄</center><center>风吹草遍野</center><hr><div class="tip "><p>8月19日</p></div><p>总是想起黑历史睡不着</p><p>以后这些事也会一直折磨自己</p><p>…</p>    <div id="aplayer-WCuMaJAa" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1911908203" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>挥之而去</p><p>但愿吧</p><hr><div class="tip "><p>8月27日</p></div><p>这段时间中间空了多少天呢…</p><p>暑假也要结束了吧</p><p>要开学了</p><p>想去江之岛（</p><div class="tip "><p>8月28日</p></div><p>明明家里离海边就几公里依然选择了去几十公里外的海滩玩<br>单纯为了看沙滩</p><p>结果看了场雷雨</p><p>天气差也好，至少沙滩边不会下饺子</p><img src="https://pic4.zhimg.com/80/v2-2606e517c7ca990ae5eae3dba6105abd_720w.webp" alt="img" style="zoom:50%;" /><img src="https://pic1.zhimg.com/80/v2-1d7a3355fc0008bede984deadd8e72dc_720w.webp" alt="img" style="zoom:50%;" /><img src="https://pica.zhimg.com/80/v2-19ceb20ff4583261847dba67c70a88ce_720w.webp" alt="img" style="zoom:50%;" /><p>去的大梅沙（</p><p>（反正算是满足了看番里去江之岛类似地方的执念（（（</p><p>夏天结束了</p><p><s>不想开学</s></p><hr><div class="tip "><p>8月30日</p></div><p>放在学校的东西霉了一堆</p><p>洗到10点钟</p><p><img src="https://pica.zhimg.com/80/v2-94cb52077c39d6731c51a39bf5158aa4_720w.webp" alt="img"></p><p><img src="https://picx.zhimg.com/80/v2-a16fc917483ca6d9164062f47b7329c9_720w.webp" alt="img"></p><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊</p><hr><div class="tip "><p>8月31日</p></div><p><img src="https://pic2.zhimg.com/80/v2-e7966d21c22792195b1ce963ccde2375_720w.webp" alt="img"></p><p>8月底，偶遇老家饭馆</p><p>画个尾声</p><p><strong>晓花我们一起摇滚吧！</strong></p><p><em>end</em></p>    <div id="aplayer-hvZBAPVr" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2012172936" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>]]></content>
    
    
    <summary type="html">“晓花，我们一起摇滚吧”</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>动漫圣地巡礼地图</title>
    <link href="https://zhongye1.github.io/posts/e11696b0.html"/>
    <id>https://zhongye1.github.io/posts/e11696b0.html</id>
    <published>2024-08-29T03:10:01.000Z</published>
    <updated>2024-09-01T08:47:18.811Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;!DOCTYPE html&gt;</p><html lang="zh"><head>    <meta charset="UTF-8">    <meta name="keywords" content="动漫,圣地巡礼,柊野">    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- 响应式视口设置 -->    <title>圣地巡礼地图</title>    <!-- 引入百度地图API -->    <script type="text/javascript" src="https://api.map.baidu.com/api?v=3.0&ak=1XjLLEhZhQNUzd93EjU5nOGQ&s=1"></script>    <style>        html, body {            margin: 0;            padding: 0;            height: 100%;        }        #mapContainer {            width: 100%;            height: calc(100% - 70px); /* 考虑到底部表单的高度 */        }        #searchForm {            display: flex;            flex-direction: column;            align-items: center;            position: fixed;            bottom: 0;            left: 0;            right: 0;            padding: 10px;            background-color: white;            z-index: 1000;        }        #searchForm label, #searchForm input, #searchForm button {            margin-bottom: 5px;        }        @media screen and (max-width: 768px) {            #searchForm label, #searchForm input, #searchForm button {                font-size: 14px;            }        }    </style>    <script>        // 确保BMap对象定义完成后再执行后续代码        window.onload = function() {            let map = null;            // 初始化百度地图            function initBaiduMap() {                map = new BMap.Map("mapContainer");                // 设置地图选项                map.enableScrollWheelZoom(true); // 启用滚轮缩放                map.addControl(new BMap.NavigationControl()); // 添加导航控件                map.addControl(new BMap.ScaleControl()); // 添加比例尺控件                // 设置地图的初始中心点和缩放级别                map.centerAndZoom(new BMap.Point(116.404, 39.915), 12);                return map;            }            // 清除地图上的所有标记            function clearMarkers(map) {                var allOverlays = map.getOverlays();                for (var i = 0; i < allOverlays.length; i++) {                    if (allOverlays[i].setMap) {                        allOverlays[i].setMap(null);                    }                }            }            // 从API获取数据            function fetchLandmarks(subjectID) {                Promise.all([                    fetch(`https://api.anitabi.cn/bangumi/${subjectID}/lite`),                    fetch(`https://api.anitabi.cn/bangumi/${subjectID}/points/detail?haveImage=true`)                ])                .then(responses => Promise.all(responses.map(r => r.json())))                .then(([bangumiData, landmarksData]) => {                    if (!bangumiData || !Array.isArray(landmarksData)) {                        alert('没有找到与提供的Bangumi作品ID匹配的数据QAQ');                        return;                    }                    clearMarkers(map); // 在添加新的地标之前清除旧的标记                    landmarksData.forEach(point => {                        addMarkerToMap(point, map, bangumiData);                    });                    if (bangumiData && bangumiData.geo && bangumiData.zoom) {                        map.centerAndZoom(new BMap.Point(bangumiData.geo[1], bangumiData.geo[0]), bangumiData.zoom);                    }                })                .catch(error => {                    console.error('Error fetching landmarks:', error);                    alert('Error,请输入有效的Bangumi ID😂');                });            }            // 在百度地图上添加标记            function addMarkerToMap(point, map, bangumiData) {                if (!point.geo || !point.geo[0] || !point.geo[1]) {                    console.error('Invalid geo coordinates:', point);                    return;                }                var p = new BMap.Point(point.geo[1], point.geo[0]); // 注意坐标顺序                var marker = new BMap.Marker(p);  // 创建标注                map.addOverlay(marker);              // 将标注添加到地图中                       // 创建信息窗口                var infoWindowContent = `                    <b>${bangumiData ? bangumiData.cn : '未知番剧'}: ${point.cn || '未知地标'}</b><br>                    ${point.name || '未知名称'}<br>                    <img src="${point.image ? point.image.replace('?plan=h160', '?plan=h360') : '无图片'}" width="100" height="auto"><br>                    Origin: ${point.origin || '未知来源'}<br>                    <a href="${point.originURL || '#'}" target="_blank">${point.originURL || '无链接'}</a>                `;  // 创建信息窗口内容                var infoWindow = new BMap.InfoWindow(infoWindowContent);  // 创建信息窗口                marker.addEventListener("click", function(){ // 添加点击事件                    this.openInfoWindow(infoWindow, map, p); // 打开信息窗口                });            }            // 绑定表单提交事件处理程序            document.getElementById('searchForm').addEventListener('submit', function(event) {                event.preventDefault(); // 阻止表单默认提交行为                const subjectID = document.getElementById('subjectID').value;                if (subjectID.trim() === '') {                    alert('请输入有效的Bangumi作品ID。');                    return;                }                fetchLandmarks(subjectID);            });            // 初始化地图            initBaiduMap();        }    </script></head><body>    <div id="mapContainer"></div>    <!-- 底部搜索表单 -->    <form id="searchForm">        <label for="subjectID">请输入Bangumi番剧ID:</label>        <input type="text" id="subjectID" name="subjectID" placeholder="例如: 328609（孤独摇滚）">        <button type="submit">检索</button>        <a href="/posts/ac0edfe5.html">【教程】如何查找Bangumi番剧ID</a>    </form></body></html>]]></content>
    
    
    <summary type="html">圣地巡礼用</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>《孤独摇滚》总作监C102原画集</title>
    <link href="https://zhongye1.github.io/posts/46b5378b.html"/>
    <id>https://zhongye1.github.io/posts/46b5378b.html</id>
    <published>2024-08-21T18:10:43.000Z</published>
    <updated>2024-08-21T18:22:37.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C102-孤独摇滚Bocchi-The-Rock-原画集"><a href="#C102-孤独摇滚Bocchi-The-Rock-原画集" class="headerlink" title="(C102) 孤独摇滚Bocchi The Rock 原画集"></a>(C102) 孤独摇滚Bocchi The Rock 原画集</h2><p>收集的一些电子版</p><div class="fj-gallery"><p><img src="https://imgs.aixifan.com/newUpload/69965585_7b2f01a1d79c47ddb9affe1b9b313399.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e79181eaa4364114b18a6db12efb1116.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f8a030ce0016400096fe2b378d2119a5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9e6ef916f6564dcbbb56870cf53be714.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_009b3798a9774678bff4f5f715210de4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6b6257e200df4f4eba90d66a2734d79d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9d7bcdc4c8544181a4c6dff011dea1b9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c85730552aa14ad9b34d6aeb07fb3d1e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_135d69f8ad294bdbafe4a56f7ab902a9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_474eeb0118f74223b79de7485c4b7899.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fe245b79ea14476583942d512545c1b8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d423619c0daf4b2586040dffc1cfad6c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dd19f9e37dcc4eefa991b6fe3ca9ea3d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_085115097bce4ec890872c7aaba06039.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_05ebaa43a0384855815ca327f8f234e5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_aed0b2e1037a48b988c920f84edf7152.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b393f98223d24887bfee0209c257a51e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_76ab5f8479b043daa2ef187e39028d2e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fb56bc81c22141b0b40fc27cb934cc28.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_58e877016d6d4aeea2f57fbc6927ba84.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_58c9f3263aa044b99f62d8250c9424ad.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c1a1c8b7e7034e2c81ae78225691bd3c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9164527573814d4f8421de8c30fc9d2b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_09eb3469bdc14dbdbf40aa13c7df34ca.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3e5264dc5903455bbcbc8a9bff12b1f5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6b1fe584158f4ae89452acc3be9180c6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9f090b9682494e049cc15ace7a294deb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_65fce27d3cae43c5b366c02dfd7b7e4e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_308093594895421f9c86deed22609c12.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_98c97770513642a698a45e5fc28063b6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3dc41fcf716743dd92928811ae252064.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b08755e2bea646ad9295e73e96da02c1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8f5a56fef0124414aa6594ad35292ef8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_df0c193365bb4186acd533a234513786.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c25b372e3dbc416a98306660f2d7cd67.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2a95e43b460a4c30819e452739248c7b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_339a802422cb413fbec9e489fa9abb32.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c31e578b7be94fadb56898be41de798f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_bb4cd23470f54c249bb581325081d740.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9a35da37616a4100baaf97273d3d93cb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9b6a016a1af14b23b382c9d8c46c3551.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0b5a5925fd0d41caa2315ff847dad182.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0bde84edd0134e4ca4a52819e9f4b986.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d0c38c8aa0104999b21b40ea758db909.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_470bb6028c7649c0ad15ccccfacc44d4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_85ff7da2de054fed962986e8169c0c04.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_861f45a12b3a423bba643d9fbf2bb2d8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_02f1ac0536b142808d348c5b1da12193.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fdce6f354ca247a2ab45fc12dec9659a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_948045aff7754930b4dddb7b6bf948ea.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d9f6003d664d4a3fac8f7e154f309aae.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cbd5f788b5c44259b47962e82c716c62.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3d42ff5cc2304be88b17c1f5b23a2128.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0fe15716c0c74e6c8446d37c30d46b93.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_129af876e8c549699ebade39b7aa7038.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8079412053b74e5f833dbe657e03dca9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c4cfb8c83f9b4076a8692f57f232cddb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_816964addf574e248c8c86690cf4b5a7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0c4c1e57098f445d994727b1953a518b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dc60d2efef8f49039e48561b016644a1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3de414a392134a4e977e250a9f77d216.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b1d752e2e94b4ec8812570ea40223796.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_16a885f23369400196170bee21464fdf.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_17847a101e454adc84579c5a0ee73428.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c32cf4785d9e489dbacff1447baa2fc8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f52a884a49e444cca4eb20be20d3344e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_aca734101b3f40b88aa068636ba1b106.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_978dd39f4cd04f199606bae8c0092c11.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_27390658aa1f4fdd969f7a22a80b2bc5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8bdc09db8fa547608bcff24f01a1a57a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3a996e89fdbd4726a72d8a8e840428d4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_be4a7f0553634e6aa6bf1336f57d016c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_95597f5702584f90b21653c3a512393b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b3e421be309349d1b39b7a950ebd528e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_aa8abf6fa18e47658db494c01c8265ba.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_01aa66537b704bf88ace7c3659b8fb74.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8ecea563e0144143be54aaf927304490.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2f1b444b5515440986438a7b5992b748.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e8dfde0d0aee465387737b5c074f2051.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3315e3c6d75345e59ac21f7e117669b4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_961a83bf5eb34785a693050973388997.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5908a1275a5e43bba46404edf10308fb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_59a5a83ce79747e1a7fd49d3c5df924c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e1927d8533584026945626c68d87d221.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cb664207350b4919a7f86e0b6e733a8f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_eb901413ade946a5b7a9e4d32faff912.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c1c370f31ce647e2baccbfdd0576100e.jpg" alt="img"></p><p><img src="https://imgs.aixifan.com/newUpload/69965585_28d17d77cd58470fb485f5d6d3ae4553.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_68f2e27ecc764ca2ba74d58a47285e6b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d4ae83619ca24ffc9640f46048ac4f25.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_557622a8d41242bd9924dfb7cb4bf948.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7ad23864b8074857a8258b2f981bedb8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d8bcbf487e3e4f6092abc95b432d23b5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_59c42361be3e4dc596bb72a73c8bdbed.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_536ce3bfefe344ee89c411bbbf7f2a6f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_334c58a18a0e40b9871e4be193410d44.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7bb5338f8c6e460c842e3627bc648bc9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ed5afd80586e47b7ad11988fc2ba4178.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_106aa1ab35044e62ac2b916a407a9f13.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_74b2c0ed89f641a2ab9fdd155da75a1a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8b725eb2452b409b82e8c76190d0c5e9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_306ae5bc399d4d339c60f87caaeec2a1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a1b3ec2bc71d41658a6a54fe00fdf23f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_66fffbb767f044c5a9d83c05d991fc23.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8c037f8add9441ca9afd9a444fb3753d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1be0024f5a6548c1a7b8f16103da4460.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a7384c9ba6fe478988b47dc1ee9fbda7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a2ab8fa289a84033acab9c29602dd74d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_30dffafb161f43a49a811859a8bfb8e3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_03cf1a08b49d4b17bd917b9ed455902b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2b2d0df699e44f7391c83fdf8e38b858.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a6d6962d8b354589ab5df30488b8a5f6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_876222daac0a42359476cfc9edc74b3b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d75bc588b76a495f8166e4ba7af40dfd.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_09aa58ebcbb44846b431ea0b8c7034bc.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_67265bc7c58646168b5d13acd0a72c63.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9d162a0de0884469982795b653fce613.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ce80e67d7ac9487aa5f1fce4c7daa349.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1e874e819fab4a7095ee5e5d28d5e4c2.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7bee5510f5b04e90a2a15b19c07ca5be.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a36e1bc091004e1ab23d802e893449f3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_df5292f817754bf88e6eab30ac64ac48.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_30090f56666143f4a5f667f412fa4df3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6e67a0cc4fa945d8913f47a21eaaed5d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5b486acb20d74756a260c26530eb25ee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fd9887b921e84970a4bdbae0c7ccf7f8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_20c9fcb5e07c42abb93f29f570c12b27.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3bcdc61c4ff740fbbc29fba5d34a740a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_491a2e86c90a4b8d9314f996d9f1344f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a3bed59e256342908e3210384ceaf839.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3261785df6604c169bcd7aaa66f3b5fd.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_69db319c189342d0a1e9e9194d96f5be.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2357971202784819bfda29c142608716.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_69b99dd5984b4f2f93d761fb7482df6c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_55df611fc3e9464b9395efa7f9df75e9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_69f671b87e964b17885fd0235f2d37d6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2b5bd2bc8a6e4ac4a0818a55e44d1904.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e65b5370f34447fab43c898119b6baf4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3f362f0e3503470ab0312df8b3ad7229.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9fd9a9cbac66402db529675477d5cdc8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4c5760adc4c343e194e80a1548561a89.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_394a75b701114f45a80ae3511c86bcba.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fef210da87de438f95a411c6e5e6a558.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_caefa9f3d2b0464fa0e7ce58d927199b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_31bd802ca3434827bf6e719dff6850ee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6ae3e49146eb4918bbf722a2c0be37bf.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5745cf3da9ee42c6aebbbf2444dbf124.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5cf10143f7e145be9a80b90d7c7f4312.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e7f1b5d8414c4954a704c76b9594dfc9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ecd1853cc3f548fc800573c7b3c3f751.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2ea29e150f6f4286bb79b38c35f84eeb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a8015ca1db0f4e15b292da85f24a78d9.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9e4a384384b24798985a16e3bf197c88.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9193307811774412bb43c8832d0bbf3b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0e553e7857d3486eb064d284bd403ce5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b7590b9d4cbb46e69d13f1e10df2f6f6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6498f3d823f1408aab8d346080694e0f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9890e61354cc407a80879467cc319dc6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_93964dfd8bc04d1db5e0373938e6ece3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f22b972c76614a029097f98637cc27dd.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9aa192f122d248c2abb6d20d4a4872f0.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b29a5c9b66a946708f6ccf0f5873ce75.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b633276b454545e1a2514afeb435b2fb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a1ea82460c0e45a5be5e856a5dfe628c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_93e41213acee44f5a1b083a629942a0c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_0a59a0b58ce3425cab58c72427ad15ad.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f8846a4ccd5345d4829d50cca42a9dee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_437165bddf11448d92cf4f1e4ae2fee3.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4d8e725292824e0d8fa7b936eaacfd44.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4f128d383d3e437a909e9f93f15af3ae.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_72ea8164f75a4001a13d703a78b9004e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_28b45fd1e4854cbe80aabd79447cf6cf.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f6d42b0060a342d7869c93db3b91b33f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fb4c0d7102b44fda8a75fb0702d2cd3a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_649f9a68ea2c44508d2e0c053690bbbb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_38fe51cd88734fbb98f116029c47f86d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dc831113338f418691224df1cafa0eee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a56b901c99da4e17b064d5e910b63a6d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1813c4ab4cd84294a165d605e701fc89.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9a20a7de5cd54c80bc7b14a611f9979d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_62620727d52240fab8e476627792c825.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fbe309bd2432413f9f6c1bf8e1b756dc.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_9c059019efc24b5dae0aec416afb417c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1e2347e2605b467085886730fbdb7a72.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_a1956210697342d9be793e69fdf514c1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6d75aa1994494612a735682239d15b2f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_b1783c27705f444b95c6e96d1d193d05.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_50ebf5bffad34233b68d75555aa3b395.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_adb03d8d85bc43178fce0041eebfc560.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_288feba39b5a47f7a8d7596d537f656c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_715332a9940847618720d74b5e4d7ed4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_58f267407f234bf6b9d880d5dc898063.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_89fd653b9ed642b2b496491b5e8bb52c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1c3a67d2991644388dd402b64ad6f4fa.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_79ad365776d24283bf1955b8b2ca4ba5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_78bdde41e4b54df79e0756ffc8b184b5.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d980733c974d4a92ab2cf85d05600ada.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_18d0e025b5c5490da1eda4c79a3c24e6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_81931cf7fb5347e2a2e75f63cbd3a17c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_f5e21169a6554f96acff5e8911aa220c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_d5e96074d61342d4b13d13901bbf6a2e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7e0c29fe4a214eaab48f55615f486f81.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_62cc1375305444b0971d0e1ea223e55d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3716db73b93b47abbedeafec8b4b4173.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_10fc2498dbb943babc0a49d11cdab16b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_16e2e327cc52414e84559ece061a3c04.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ab67643641a64e94b13ac5940fe8fe27.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5753950520e448acb574960fc47e6181.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_baa7f509a6e340f4bf4df69912ccfd30.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_40eb057f1cb34b7e9e3a8411e49d0c82.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ac0c382f4adb40da8b997536d92e098a.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_40e7980422374b568566da9aaf54fe5e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7669a13e269249898e97293673d41417.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cf5c10b2e77147148bb3427261c92030.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_35d492fc050d4b1bae0e29cfba2de8fd.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2d025b11e66942c188178696b94ddc6d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ab95b6ec06a1411eb2a2ea0391148c94.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_37b66766209f414b839569f4943af4a4.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4d569fb32f4d4320806f967e26ccfe99.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_bce74fce6262410aa0b523a29484069d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_55377a6ae67c4663948be76a52e5eac8.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_517553bdee6f4d6384ecb0a95ead4b6c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_fddf9e012f484ba496405d442e1a26fb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_67d2fa130ad347cd91fa751cc9d6ebb0.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_843e79471bd14aee9d92ee1728ede37f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_7bc72d233f0d47efa37bd08ffe945b44.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3d9050f4c4df401eab701e70ae84aa0b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_74f766269c31436d9508ffe8cab2f87e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_00bd7530ca5648fb932124b69606809f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e5e459c10b974a05b1df0f75922d7287.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c4cfcbe125164169a940d039cabf4d98.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6e951a58e2854125811824ee3d129fab.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_721149fa40bb4e3fbb89c902c46e603c.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_054608f27b784b8abe9fe1447f600987.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_464b90dab5104b3b92e1e87cf28adc82.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_e4ef8244adcd4b7dbce3784090e62974.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_79b0483a9690447d856d7f44063b0727.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ae63cdfec6014c46a76f1571a3ed60ee.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cbcde965e4ac4c89970df2358a8175ef.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_023e2d39811d4aad803d63d357f49a24.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_ec896497316648cbbb9f6ef30f48cfbb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_73d8d5641a0440f3800631c77352152f.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_bfb32e30819c4fc1ad5ba61bbec671f7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_83a18a0ecfbb4c06a28fdf8eb7827b93.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_733b7a0585ee4386811b803f7c3422eb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5ad89a8115eb4ef683706847f2da715b.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_59d31775fcee43ddbf35aaa797e3c222.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_1fc3a43eb7a24302a31cf37bde0e62de.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5de39eb8a4a541a88c6af7d7f6cf4407.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_94f7cdb27d104306afbf482e922e89b6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_742d4a3e094a41e69cb03df115a17fea.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_bce8567fba77443e9eaffc20ea62d576.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_2fb668fbc9714f78adf472c45c165b79.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_cdc4103a9ce244d4aa1f431253b5f68d.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dcd190b6edb64be1a6203591f971f196.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_5087ca0e101a4f38abe0caeb44445a86.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_60c83482c95c4e4484cafc537da43da6.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_aaf9aa46de404bffbaebc863a52a0a6e.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_eab59771cdae40709f947463759568b7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_8d905aa78dd14ba3ac79a09c0c3179cb.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_6a32bb7a266e4b3a80f785efefa638ef.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4360f3c6c63a432383f9a90a5a79af29.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c0df0b633e9041098c4697a482246f43.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dc21d58a181a40e696705802af33b1e1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_64cf69a5e1924b98bd53713ab29f4083.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_46cb6ae1e3164fa1a388178f708e7a64.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_dd9296872b0d4a019e77f9aa8e7b44f7.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_4bea26853b35493a95260d5754282225.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_c5a64f922bf64c52a860ca4c1c4873f0.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_3ae7c5ff195b47cea2cd31a6e88d67a1.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_addd09a588154610b5c25859bcc028cf.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_212625402f6e446eb14966a3f1586609.jpg" alt="img"><img src="https://imgs.aixifan.com/newUpload/69965585_125c854dcf90484eac22c9d4a700d39b.jpg" alt="img"></p>          </div>]]></content>
    
    
    <summary type="html">《孤独摇滚》总作监けろりらC102原画集</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【教程】如何让你的好友不停看到你在玩某游戏</title>
    <link href="https://zhongye1.github.io/posts/ba9ce6f6.html"/>
    <id>https://zhongye1.github.io/posts/ba9ce6f6.html</id>
    <published>2024-08-20T15:40:20.000Z</published>
    <updated>2024-08-20T16:06:31.359Z</updated>
    
    <content type="html"><![CDATA[<div class="tip warning faa-horizontal animated"><p>FBI warning</p></div><img src="https://imgsa.baidu.com/forum/w%3D580/sign=8d30ba9c09087bf47dec57e1c2d1575e/e49c3f2ac65c1038c3e64b15b9119313b27e899d.jpg" alt="img" style="zoom:50%;" align=right /><p>该方法会让你的好友每隔10秒弹出你的好友正在玩▆▆▆▆▆▆</p><p>不过可能会导致被屏蔽甚至删除好友的严重后果。</p><p>所以你需要的是一些steam好友（不怕死的那种</p><p>===================</p><p>接下来当然是基本操作，如何添加▆▆▆▆▆▆，网上都有教程<br>为了水还是发下，</p><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=d8cf65e03efae6cd0cb4ab693fb10f9e/41c464061d950a7b4decca1301d162d9f0d3c95c.jpg" alt="img"><br><img src="https://imgsa.baidu.com/forum/w%3D580/sign=af97493bda00baa1ba2c47b37712b9b1/8feac5fc1e178a8289abfb77fd03738dab77e89a.jpg" alt="img"></p><hr><p>这时候关键步骤来了，添加的你女朋友最好是个自己关掉的东西</p><p>（这样在调用时就不用关掉了）</p><p>这里我们自己写了一个……程序很简单，线程挂着就行了，java，c++，Delphi都行，</p><p>这里我们用c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">5000</span>);  <span class="comment">//五秒后自动关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=2b13490aa064034f0fcdc20e9fc17980/05365b3d269759ee5d85e71cb9fb43166f22df58.jpg" alt="img"></p><p>现在我们已经添加了一个非steam游戏，现在改个名，</p><p>但是注意直接启动，steam状态是不认的，</p><p>我们就要通过steam启动来完成，那么……<br><img src="https://imgsa.baidu.com/forum/w%3D580/sign=6e18634507f431adbcd243317b34ac0f/b1f2bb3533fa828b7ab11b34f61f4134950a5aa7.jpg" alt="img"></p><p>我们右键它，创建一个桌面快捷方式，桌面就会有个图标，右键，复制像这样的链接。</p><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=9e0a12f9a3d3fd1f3609a232004f25ce/7e3c88025aafa40f577a4f0aa064034f7af019f0.jpg" alt="img"></p><p>在桌面新建，文本文档，改名为a.bat（批处理文件）,写入</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`[@<span class="built_in">echo</span>](https://tieba.baidu.com/home/main?un=<span class="built_in">echo</span>&amp;fr=pb&amp;ie=utf-<span class="number">8</span>) off`</span><br><span class="line">`:<span class="built_in">start</span>`</span><br><span class="line">`<span class="built_in">start</span> steam://rungameid/<span class="number">11873789792539901952</span>` #👈把链接换成刚刚你获得的链接#</span><br><span class="line">`<span class="built_in">ping</span> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> -n <span class="number">10</span>&gt;<span class="built_in">nul</span>`</span><br><span class="line">`<span class="keyword">goto</span> <span class="built_in">start</span>`</span><br></pre></td></tr></table></figure><p>把链接换成刚刚你获得的链接，ping那行的10表示每10秒骚扰好友一次。修改，不要低于5，不然steam这个东西就不会下线了。就无法不停上线弹窗了。</p><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=e0c9d9c5444a20a4311e3ccfa0509847/46faa6af2edda3ccdf0639f70ae93901233f9257.jpg" alt="img"></p><p>双击运行就可以看到效果了，过一会估计你的好友估计就会线下真实你了（立竿见影</p><p>关掉cmd就可以了<br><img src="https://imgsa.baidu.com/forum/w%3D580/sign=62c3e1cb1adfa9ecfd2e561f52d1f754/bfdd9913b07eca80f528ba309a2397dda0448300.jpg" alt="img"></p><p>（每日一个昇镬小訬招）</p>]]></content>
    
    
    <summary type="html">论如何让你的好友不停看到你在玩奇怪游戏</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MikuTap</title>
    <link href="https://zhongye1.github.io/posts/mikumiku.html"/>
    <id>https://zhongye1.github.io/posts/mikumiku.html</id>
    <published>2024-08-04T07:21:26.000Z</published>
    <updated>2024-08-04T07:51:37.097Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en" version="4"><head>    <meta charset="UTF-8">    <title>MikuMikuTap~</title>    <style>        body, html {            margin: 0;            padding: 0;            height: 100%;        }        #Frame {            border: none; /* 移除边框 */            display: block; /* 块级元素 */            width: 100%; /* 宽度100% */            height: calc(100vh - 40px); /* 减去按钮的高度 */            position: absolute; /* 绝对定位 */            top: 40px; /* 使iframe位于按钮下方 */            left: 0;        }        .return-button {            display: block;            position: fixed; /* 固定定位 */            top: 0; /* 顶部位置 */            left: 50%; /* 水平居中 */            transform: translateX(-50%); /* 水平居中 */            background-color: #333;            color: white;            text-align: center;            padding: 10px 20px;            text-decoration: none;            z-index: 1000; /* 确保按钮在其他元素之上 */        }    </style></head><body inject_video_svd="true"><!-- 添加按钮 --><p><a href="https://zhongye1.github.io/" class="return-button">返回博客主页~</a></p><iframe id="Frame" src="https://air.moe/funs/MikuTap/" allowfullscreen=""></iframe></body></html>]]></content>
    
    
    <summary type="html">Miku声乐小游戏</summary>
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>申论生成器</title>
    <link href="https://zhongye1.github.io/posts/b61fa24.html"/>
    <id>https://zhongye1.github.io/posts/b61fa24.html</id>
    <published>2024-08-04T06:38:10.000Z</published>
    <updated>2024-08-20T16:06:26.094Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en" version="4"><head>    <meta charset="UTF-8">    <title>申论生成器</title>    <style>        body, html {            margin: 0;            padding: 0;            height: 100%;        }        #Frame {            border: none; /* 移除边框 */            display: block; /* 块级元素 */            width: 100%; /* 宽度100% */            height: calc(100vh - 40px); /* 减去按钮的高度 */            position: absolute; /* 绝对定位 */            top: 40px; /* 使iframe位于按钮下方 */            left: 0;        }        .return-button {            display: block;            position: fixed; /* 固定定位 */            top: 0; /* 顶部位置 */            left: 50%; /* 水平居中 */            transform: translateX(-50%); /* 水平居中 */            background-color: #333;            color: white;            text-align: center;            padding: 10px 20px;            text-decoration: none;            z-index: 1000; /* 确保按钮在其他元素之上 */        }    </style></head><body inject_video_svd="true"><!-- 添加按钮 --><p><a href="https://zhongye1.github.io/" class="return-button">返回博客主页~</a></p><iframe id="Frame" src="https://air.moe/funs/Slscq/" allowfullscreen=""></iframe></body></html>]]></content>
    
    
    <summary type="html">50-5000字申论自动生成器</summary>
    
    
    
    <category term="Github项目" scheme="https://zhongye1.github.io/categories/Github%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>访客地图</title>
    <link href="https://zhongye1.github.io/posts/a8a0d075.html"/>
    <id>https://zhongye1.github.io/posts/a8a0d075.html</id>
    <published>2024-08-03T16:12:49.000Z</published>
    <updated>2024-08-07T16:49:57.774Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;!DOCTYPE html&gt;</p><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="initial-scale=1.0, user-scalable=no" /><title>柊野的博客-访客分布</title><style type="text/css">    body, html {        width: 100%;        height: 100%;        margin: 0;        font-family: "微软雅黑";    }    #allmap {        width: 100%;        height: 100%;        position: relative;        z-index: 1;    }    p {        margin-left: 5px;        font-size: 14px;    }    .openInfo {        margin: 4px 0;    }    .my_label {        width: 300px;        overflow: hidden;        text-overflow: ellipsis;        white-space: nowrap;        display: inline-block;    }    .openInfo_div {        width: 100%;        height: 80%;        overflow-y: auto;    }    .BMap_bubble_content {        height: 100%!important;    }    .openInfo>* {        vertical-align: middle;    }    /* 返回博客按钮=========================================================== */    .button {        border: none;        color: white;        text-align: center;        text-decoration: none;        display: inline-block;        font-size: 20px;        margin: 4px 2px;        cursor: pointer;        background-image: url('https://pic4.zhimg.com/v2-68ff3d189ef7ec060222261a98892e67_b.webp'); /* 图片路径 */        background-size: cover; /* 使图片填充整个按钮区域 */        background-repeat: no-repeat;        background-position: center center;        width: 170px; /* 设置按钮的宽度为图片的宽度 */        height: 90px; /* 设置按钮的高度为图片的高度 */    }    .button2 {        background-color: #008CBA; /* 蓝色备用背景颜色 */    }</style><!-- 将所有的 script 标签放在这里 --><script type="text/javascript" src="https://api.map.baidu.com/api?v=2.0&ak=1XjLLEhZhQNUzd93EjU5nOGQ&s=1"></script><script type="text/javascript" src="https://api.map.baidu.com/library/Heatmap/2.0/src/Heatmap_min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.9.0/jquery.min.js"></script><!-- 将不安全的http升级为https --><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"></head><body><div style="position:absolute;top:0;z-index:99999;background-color:rgba(0,0,0,0.2);width:100%;color:#FFFFFF;">    <center>        <h2>柊野的博客-访客分布-Апрель （访客IP地图）</h2>    </center></div><div style="position:absolute;bottom:20px;left:0;z-index:99999;background-color:rgba(0,0,0,0.2);">    <h3 style="color:#FFFFFF;">好好好</h3>    <p></p>    <a href="https://zhongye1.github.io/" class="button button2" target="_blank">返回博客主页</a></div><div style="position:absolute;bottom:0;right:0;z-index:99999;background-color:rgba(0,0,0,0.2);">    <h4 style="color:#FFFFFF;">        <br/>        进博客就会点亮你的位置，想不到吧hhh        <br/>        访问博客都会被记录在此（        <br/>        顺带位置依据是IP，IP不能精确定位但可以确定城市        <br/>        所以站长不太可能找上门（除非你也在广州大学        <br/>        <br/>来看看你和站长有多远        <br/><font color="#80bfff">站长QQ 2760913192</font>        <br/>                        ————柊野        <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1261190516'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1261190516%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>    </h4></div><div id="allmap"></div><script type="text/javascript">    // 百度地图API功能    var map = new BMap.Map("allmap");    map.centerAndZoom("中国", 6);    map.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放    map.setMapStyle({ style: 'midnight' }); // 修正语法错误    var point = new BMap.Point(116.418261, 39.921984);    map.centerAndZoom(point, 6);    var data_info = [        [114.4942, 37.0631, "China-Hebei-Xingtai", "https://bf3.axibug.com/hunter_map/icon/c1.png"],        [104.93457341, 33.39447997, "256", "https://bf3.axibug.com/hunter_map/icon/c2.png"],        [108.3146, 22.8137, "China-Guangxi-","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [113.380249, 23.04721, "300","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [113.380249, 23.09721, "77","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [120.59246739, 30.00236458, "293","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [106.7167, 26.5833, "China-Guizhou-","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [114.248084,30.601824, "HB","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [114.248084,30.701824, "HB","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [114.248084,30.621824, "298","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [113.507593,30.366792, "298","https://bf3.axibug.com/hunter_map/icon/c4.png"],        [120.14887182, 33.37986188, "223","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [113.1117, 28.1783, "China-Hunan-Changsha","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [114.35164212, 34.80185418, "210","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [114.4, 23.0833, "China-Guangdong-Huizhou","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [106.5531, 29.5569, "China-Chongqing-","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [115.89352755, 28.689578, "163","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.25, 23.1167, "China-Guangdong-","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [108.92427443, 23.55225469, "17","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [117.67620468, 24.51706478, "255","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [114.1861241, 22.29358599, "2912","https://bf3.axibug.com/hunter_map/icon/c3.png"],        [112.247378,32.457298, "58","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [119.3061, 26.0614, "China-Fujian-Fuzhou","https://bf3.axibug.com/hunter_map/icon/c2.png"],        [115.37292429, 22.7787305, "339","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [120.36132599, 23.77722277, "9000","https://bf3.axibug.com/hunter_map/icon/c1.png"],        [106.5531, 29.5569, "China-Chongqing-Chongqing","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [120.3694, 36.066, "China-Shandong-Qingdao","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [106.53063501, 29.54460611, "132","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.854145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.634145,22.687907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.587907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.834145,22.6827907, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.277627,23.132179, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.237627,23.133179, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.277627,23.1331179, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045547, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045547, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382433,23.045547, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382323,23.045547, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045247, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045447, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],        [113.382333,23.045557, "SZ","https://bf3.axibug.com/hunter_map/icon/c6.png"],            ];      var opts = {        width: 390, // 信息窗口宽度        height: 200, // 信息窗口高度        title: "", // 信息窗口标题    };    for (var i = 0; i < data_info.length; i++) {        var marker = new BMap.Marker(new BMap.Point(data_info[i][0], data_info[i][1])); // 创建标注        var myIcon = new BMap.Icon(data_info[i][3], new BMap.Size(25, 25), {});         marker.setIcon(myIcon);        map.addOverlay(marker); // 将标注添加到地图中        addClickHandler(marker, data_info[i][2]);    }    function addClickHandler(marker, id) {        marker.addEventListener("click", function (e) {            openInfo(e, id);        });    }    var nowpoint;    function openInfo(e, id) {        var p = e.target;        var point = new BMap.Point(p.getPosition().lng, p.getPosition().lat);        nowpoint = point;        ajax(id, point);    }    function ajax(id, point) {        // 这里应该添加 AJAX 请求的代码        // 示例代码：        // $.ajax({        //     url: "your-url-here",        //     data: { id: id, point: point },        //     success: function (data) {        //         // 处理成功后的逻辑        //     },        //     error: function () {        //         // 处理错误后的逻辑        //     }        // });    }</script></body></html>]]></content>
    
    
    <summary type="html">博客-访客分布图</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何检索Bangumi作品ID</title>
    <link href="https://zhongye1.github.io/posts/ac0edfe5.html"/>
    <id>https://zhongye1.github.io/posts/ac0edfe5.html</id>
    <published>2024-07-31T17:40:49.000Z</published>
    <updated>2024-08-29T18:13:20.758Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="Bangumi站点" href="https://bgm.tv/"><div class="left"><img src="https://picx.zhimg.com/80/v2-bc308dd4467bdc76edbb6c65fabd38d1_720w.webp"/></div><div class="right"><p class="text">Bangumi站点</p><p class="url">https://bgm.tv/</p></div></a></div><p><strong>进入相关动画页面的链接最后数字就是作品ID</strong><br>如</p><p><a href="https://bgm.tv/subject/328609">https://bgm.tv/subject/328609</a><br>作品ID就是328609</p><p>如图</p><p><img src="https://pic2.zhimg.com/80/v2-a68ca080c5c84942894892e634329df1_720w.webp" alt="img"></p><div class="tag link"><a class="link-card" title="返回圣地巡礼地图" href="https://zhongye1.github.io/posts/e11696b0.html"><div class="left"><img src="https://pic1.zhimg.com/80/v2-bc721faaba1ef3f9e951f621148f700e_720w.webp"/></div><div class="right"><p class="text">返回圣地巡礼地图</p><p class="url">https://zhongye1.github.io/posts/e11696b0.html</p></div></a></div>]]></content>
    
    
    <summary type="html">如何检索Bangumi作品ID</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>typora图床设置</title>
    <link href="https://zhongye1.github.io/posts/32d01401.html"/>
    <id>https://zhongye1.github.io/posts/32d01401.html</id>
    <published>2024-07-31T04:56:23.000Z</published>
    <updated>2024-07-31T05:02:12.915Z</updated>
    
    <content type="html"><![CDATA[<p>兰空图床安装可以去看另一篇文章 <a href="https://blog.imtop1.moe/archives/299/">搭建一个属于自己的图床</a></p><h2 id="一、安装和配置picgo">一、安装和配置picgo</h2><ol><li><p>首先到picgo的官方仓库下载安装包 <a href="https://github.com/Molunerfinn/PicGo">Molunerfinn/PicGo: A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder (github.com)</a> 安装过程一路next就ok，安装完成后的界面：</p><p><a href="https://image.imtop1.moe/oPOFUp.webp"><img src="https://image.imtop1.moe/oPOFUp.webp" alt="picgo0"></a></p></li><li><p>安装兰空图床插件</p><p>这里可以直接到picgo的插件设置里面搜索兰空安装插件，或者是直接到官方github下载并且手动安装，链接：<a href="https://github.com/hellodk34/picgo-plugin-lankong">hellodk34/picgo-plugin-lankong: A PicGo uploader for 兰空图床 lsky-pro，支持 V1 和 V2。 (github.com)</a>教程在链接里面有。</p><p><a href="https://image.imtop1.moe/euJ6uz.webp"><img src="https://image.imtop1.moe/euJ6uz.webp" alt="pic1"></a></p></li><li><p>获取兰空图床token</p><p>这里使用postman请求一个token，信息按照图片里的填就ok，记得把域名换成你自己图床的域名。</p><p><a href="https://image.imtop1.moe/mV6yuf.webp"><img src="https://image.imtop1.moe/mV6yuf.webp" alt="pic2"></a></p><ol><li>设置picgo</li></ol><p>打开图床设置，选择lankong，照着写即可。</p><p><a href="https://image.imtop1.moe/pZXL24.webp"><img src="https://image.imtop1.moe/pZXL24.webp" alt="pic3"></a></p></li><li><p>检测效果</p><p>图床选lankong，随便上传一张图片，看看能不能成功。</p><p><a href="https://image.imtop1.moe/X08dZe.webp"><img src="https://image.imtop1.moe/X08dZe.webp" alt="pic4"></a></p><p><a href="https://image.imtop1.moe/HDM3Ef.webp"><img src="https://image.imtop1.moe/HDM3Ef.webp" alt="pic5"></a></p></li></ol><h2 id="二、对接typora">二、对接typora</h2><p>打开typora，前往偏好设置，进行如下设置：</p><p><a href="https://image.imtop1.moe/ZZOkbW.webp"><img src="https://image.imtop1.moe/ZZOkbW.webp" alt="pic6"></a></p><p>并点击验证图片上传选项：</p><p><a href="https://image.imtop1.moe/L8Z6yw.webp"><img src="https://image.imtop1.moe/L8Z6yw.webp" alt="pic7"></a></p><p>能出现如图界面说明成功了。</p><p>现在你往typora拖拽图片能自动上传到兰空图床</p>]]></content>
    
    
    <summary type="html">typora+picgo+兰空图床打造markdown写作环境</summary>
    
    
    
    <category term="博客美化" scheme="https://zhongye1.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>2024年7月31日</title>
    <link href="https://zhongye1.github.io/posts/e6902323.html"/>
    <id>https://zhongye1.github.io/posts/e6902323.html</id>
    <published>2024-07-30T17:21:52.000Z</published>
    <updated>2024-07-30T17:44:10.011Z</updated>
    
    <content type="html"><![CDATA[<ul><li></li></ul><p>中午困死，一直睡到下午七点</p><p>梦到了些很诡异的东西</p><ul><li></li></ul><p>研究NAS建站</p><p>研究图床</p><p>研究API</p><p>然后都没搞定（倒</p><img src="https://pic4.zhimg.com/80/v2-24ff52b4977d121d3bc9ab1dc9678bab_720w.webp" alt="img" style="zoom:50%;" /><p>就是无厘头的405了</p><p>图床还得用知乎</p><p>搞不好哪天开了防盗链这个博客站又得寄掉</p><p>要弄的还是太多了</p><p>其实现在要网上保存个什么的死难</p><p>随便哪边供应的跑路了就寄了</p><p>不过暑假还有时间修</p><p>之后难说了，大二忙成狗</p><p>难搞</p><p><img src="https://pic1.zhimg.com/80/v2-666eaa2a5c3b4e18b03bef3e0fcb077c_720w.webp" alt="img"></p><ul><li></li></ul><p>另外网易云一个歌单全部收费了</p><p>收费的话比起灰掉还是好点</p><p>不过没啥差别</p><p>每次重新翻收藏时总是有一堆都变成这样</p><img src="https://pic2.zhimg.com/80/v2-eee0a77edb1272f1fb9e58ab732a3f65_720w.webp" alt="img" style="zoom:33%;" />]]></content>
    
    
    <summary type="html">405 Not Allowed</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>周边其二</title>
    <link href="https://zhongye1.github.io/posts/fcf81dde.html"/>
    <id>https://zhongye1.github.io/posts/fcf81dde.html</id>
    <published>2024-07-29T18:03:23.000Z</published>
    <updated>2024-07-30T12:31:48.156Z</updated>
    
    <content type="html"><![CDATA[<ul><li></li></ul><p><img src="https://pic4.zhimg.com/80/v2-d133dfa8b586d5ddc43d8715a24a172b_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-097dafe2afb1cdbf10d944f78e517d5b_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5e6a6a4c3a2297277a6b685b29f91a57_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-53d4b8af1de60e9e907ec7c7190ca52a_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-f5dd3dd51ee10f7a6916e95956990e0b_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-23ddc9d4fa9f7c20c8ab67279924735f_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-84e794e35970290f0ee5234fea9e6301_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-e0cc837ae526a648e14d913910782694_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-22a5064ff5e04f3ce92de9c2886baadd_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-e7e2db37d51b148062918eb560f93322_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-ead7692442601112efcc88a83502a3aa_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-c8e909921c103eea2f78e17c85f46300_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-9aa8c440226d90aba306e139d17a267f_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-31a2e4274eba328a24754dad871aded9_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-298d8f7019e59d8467912bdcea869b3c_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5643fdf1e32bb3aa1792fe9b2d14b553_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-a6949a79d9e87e6fa83394462e526479_720w.webp" alt="img"></p><ul><li></li></ul><p>其实刚到这里时还是挺高兴的</p><p>百来块不到的预算草草来香港除了拍街景另外是想来看一下周边</p><p>不过周边的产品附加值拉满了</p><p>个人不是很能接受拿金钱实力来展示自己的厨力</p><p>穷游香港的话预算60多</p><p>在香港也没有买任何东西</p><p>除此之外另外也没啥其他的了</p><p>给7月画个尾声罢</p><p>其实还想说什么的话</p><p>也没头绪</p><p>就是想的太多</p><p>睡了</p><ul><li></li></ul>]]></content>
    
    
    <summary type="html">百来块不到的预算草草来香港除了拍街景也主要是想来看一下周边</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>年前</title>
    <link href="https://zhongye1.github.io/posts/aeed56ee.html"/>
    <id>https://zhongye1.github.io/posts/aeed56ee.html</id>
    <published>2024-07-29T15:59:07.000Z</published>
    <updated>2024-08-05T15:47:29.019Z</updated>
    
    <content type="html"><![CDATA[<p>-放首歌</p>    <div id="aplayer-KrlKULFO" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1960403945" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><img src="https://pic3.zhimg.com/80/v2-aee1088402a3dba60d86b71c4c5ce4f2_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-f8f67bac6b457af94c4bad5f6b928f94_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-80392f2b012bd26a267d48530c2d523a_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-b840b58b9de1f17ffb0eb71cc9ed5dc3_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-66de82b1b0d5482d439272051e9b0ffb_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-92b32c509920899c39173f1593ab8100_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-bf4481accae1dc117377e6e97d33fa22_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-c18d007dfe7fd637e9d21b61e7bf8642_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-40b9431c44e0f088356e1893f6da9685_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-ae586f3b62e6c45e28f92bac1f294cf8_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-9c8cbf1a07beb44c9415556a387ee31e_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-6c7c62b2e4057ea9014b85a514c39a1a_720w.webp" alt="img"><img src="https://pic4.zhimg.com/80/v2-bb3408d229550808179e9ec48c72b36f_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-9c896e2539244f481b7f06195bfc5c5a_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-4f504440b8b8130ea093454c1ba25568_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-5b1ee59e3138ccc7b6c4cf7731f8147d_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-f7ff7171d0e2e8ca388b84ce79714382_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-1f36bcd074963f0e9c5df29e9ed4fa07_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-c7ad9246231d288efecb967beb16e319_720w.webp" alt="img"></p><p>当时二月初，刚下完冻雨后又下了几天雪</p><p>很少会下这么大的雪，把一切都冻住了几天</p><p>当时说将来可能看不到这种景致了，要多看看</p><p>现在又是夏天了</p>]]></content>
    
    
    <summary type="html">一些年前的照片</summary>
    
    
    
    <category term="随记" scheme="https://zhongye1.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数学分析笔记其二</title>
    <link href="https://zhongye1.github.io/posts/dc9c528b.html"/>
    <id>https://zhongye1.github.io/posts/dc9c528b.html</id>
    <published>2024-07-26T15:54:02.000Z</published>
    <updated>2024-07-26T17:50:32.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数分思维导图（分块对比版）">数分思维导图（分块对比版）</h2><p><img src="https://pic3.zhimg.com/80/v2-51d2dd8a8fce49d68e4155102d2f4b6a_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-328947f5004d7fc73dd60d07c1ae70f3_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-a1b8946301d2c666e14287048462eede_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-3ddf0622ca0c7c8991b3d4e4350fc502_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-ab6d616deccd4c73ce4a929aeb1b6794_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5003f333cf7daedefa7187d8e8d86fcb_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-a6502548cbf3a6baff900ba800287483_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-310a39b7ca256d6d45ca887597de4955_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-d163bd005712d70995ab263d28b541bc_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-f3a12ba58309f0ef249e59f95cc20548_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-55ab37de967ee6f658adc8eff9956e55_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-691b17d8319e18e5b958b565961c3b56_720w.webp" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-d202eb555293a6d8aecfd8af0f4f5731_720w.webp" alt="img"></p><hr><h2 id="一些公式和解题方法">一些公式和解题方法</h2><p><img src="https://pic2.zhimg.com/80/v2-262629548cf754b41abb7056f0f63201_720w.webp" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5115e32777d8549f235ab0ac7f5c805b_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-d1f11105011824e4eac3e37208dcd204_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-9a9e2c71a423e95ca6e861d6a7aa7efc_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-ccbf8f1c47c4b16aa0e01614e1f2ed0e_720w.webp" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-4c35492e316f1fc489493f39186cc6be_720w.webp" alt="img"></p><p>编辑于 2024-07-27</p>]]></content>
    
    
    <summary type="html">数分思维导图及公式合集</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>高代知识点全汇总</title>
    <link href="https://zhongye1.github.io/posts/47d446d0.html"/>
    <id>https://zhongye1.github.io/posts/47d446d0.html</id>
    <published>2024-07-25T19:27:55.000Z</published>
    <updated>2024-07-31T04:32:21.995Z</updated>
    
    <content type="html"><![CDATA[<details class="folding-tag" cyan open><summary> CSDN上的一些知识点合集（点击折叠） </summary>              <div class='content'>              <h4 id="第一章——矩阵及初等变换">第一章——矩阵及初等变换</h4><p><strong>§1.1. 矩阵及其运算</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99618446">线性代数学习笔记——第一讲——线性代数课程绪论</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99618603">线性代数学习笔记——第二讲——矩阵的定义及示例</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99618805">线性代数学习笔记——第三讲——矩阵加法及数乘</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99618841">线性代数学习笔记——第四讲——矩阵乘法的定义</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99657438">线性代数学习笔记——第五讲——矩阵乘法的性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99660769">线性代数学习笔记——第六讲——矩阵的转置</a><br><strong>§1.2. 高斯消元法与矩阵的初等变换</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99721392">线性代数学习笔记——第八讲——矩阵的初等变换</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99722636">线性代数学习笔记——第九讲——初等矩阵</a></p><p><strong>§1.3. 逆矩阵</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99726807">线性代数学习笔记——第十讲——逆矩阵的定义</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99729891">线性代数学习笔记——第十一讲——逆矩阵的计算（利用初等变换求逆矩阵）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99730636">线性代数学习笔记——第十二讲——求解矩阵方程</a><br><strong>§1.4. 分块矩阵</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99663452">线性代数学习笔记——第七讲——分块矩阵</a></p><h4 id="第二章——行列式">第二章——行列式</h4><p><strong>§2.1. n阶行列式的定义</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99747212">线性代数学习笔记——第十三讲——行列式的定义</a></p><p><strong>§2.2. n阶行列式的性质</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99762801">线性代数学习笔记——第十四讲——行列式的性质</a><br><strong>§2.3. Laplace定理</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99766891">线性代数学习笔记——第十五讲——行列式按行（列）展开</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99770920">线性代数学习笔记——第十六讲——行列式的计算</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99773351">线性代数学习笔记——第十七讲——伴随矩阵与逆矩阵</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99887040">线性代数学习笔记——第十八讲——抽象矩阵的可逆性</a><br><strong>§2.4. Cramer法则</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99889327">线性代数学习笔记——第十九讲——克拉默法则</a><br><strong>§2.5. 矩阵的秩</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99890960">线性代数学习笔记——第二十讲——矩阵秩的定义</a>、</p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99893849">线性代数学习笔记——第二十一讲——矩阵秩的等式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99895726">线性代数学习笔记——第二十二讲——矩阵秩的不等式</a></p><h4 id="第三章——几何空间">第三章——几何空间</h4><p><strong>§3.1. 空间直角坐标系与向量</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/99999238">线性代数学习笔记——第二十三讲——空间直角坐标系</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100005855">线性代数学习笔记——第二十四讲——向量及其线性运算</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100006195">线性代数学习笔记——第二十五讲——向量在轴上的投影</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100026005"> 线性代数学习笔记——第二十六讲——向量线性运算的几何意义</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100026531">线性代数学习笔记——第二十七讲——向量的方向余弦</a><br><strong>§3.2. 向量的乘法</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100027126">线性代数学习笔记——第二十八讲——向量内积的概念与性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100085857">线性代数学习笔记——第二十九讲——向量内积的坐标形式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100086031">线性代数学习笔记——第三十讲——向量外积的概念与性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100086376">线性代数学习笔记——第三十一讲——向量外积的坐标形式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100087151">线性代数学习笔记——第三十二讲——向量混合积的概念与性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100087236">线性代数学习笔记——第三十三讲——向量混合积的几何意义</a></p><h4 id="第四章——n维向量空间">第四章——n维向量空间</h4><p><strong>§4.1. n维向量空间的概念</strong></p><p><a href="https://mp.csdn.net/postedit/100167321">线性代数学习笔记——第四十讲——n维向量空间的概念</a></p><p><a href="https://mp.csdn.net/postedit/100167541">线性代数学习笔记——第四十一讲——n维向量空间的子空间</a><br><strong>§4.2. 向量组的线性相关性</strong></p><p><a href="https://mp.csdn.net/postedit/100167651">线性代数学习笔记——第四十二讲——向量组的线性组合</a></p><p><a href="https://mp.csdn.net/postedit/100167901">线性代数学习笔记——第四十三讲——向量组之间的线性表出</a></p><p><a href="https://mp.csdn.net/postedit/100525200">线性代数学习笔记——第四十四讲——线性相关性的概念</a></p><p><a href="https://mp.csdn.net/postedit/100528562">线性代数学习笔记——第四十五讲——线性相关性的判定</a></p><p><a href="https://mp.csdn.net/postedit/100529249">线性代数学习笔记——第四十六讲——线性相关基本定理</a><br><strong>§4.3. 向量组的秩与最大无关组</strong></p><p><a href="https://mp.csdn.net/postedit/100545185">线性代数学习笔记——第四十七讲——向量组的秩与最大无关组的概念</a></p><p><a href="https://mp.csdn.net/postedit/100545450">线性代数学习笔记——第四十八讲——矩阵的列秩和行秩</a></p><p><a href="https://mp.csdn.net/postedit/100545669">线性代数学习笔记——第四十九讲——向量组之间的线性表出和秩</a></p><p><a href="https://mp.csdn.net/postedit/100545879">线性代数学习笔记——第五十讲——最大无关组的性质和等价叙述</a><br><strong>§4.4. 线性方程组解的结构</strong></p><p><a href="https://mp.csdn.net/postedit/100563945">线性代数学习笔记——第五十一讲——n维向量空间的基、维数与坐标</a></p><p><a href="https://mp.csdn.net/postedit/100564018">线性代数学习笔记——第五十二讲——齐次方程组解的性质和基础解系</a></p><p><a href="https://mp.csdn.net/postedit/100564726">线性代数学习笔记——第五十三讲——齐次方程组求解实例</a></p><p><a href="https://mp.csdn.net/postedit/100568940">线性代数学习笔记——第五十四讲——非齐次方程组解的性质</a></p><p><a href="https://mp.csdn.net/postedit/100569281">线性代数学习笔记——第五十五讲——非齐次方程组求解实例</a></p><h4 id="第五章——特征值与特征向量">第五章——特征值与特征向量</h4><p><strong>5.1 特征值与特征向量的概念与计算</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100584392">线性代数学习笔记——第五十六讲——特征值及特征向量的定义</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100584678">线性代数学习笔记——第五十七讲——特征子空间</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100584921">线性代数学习笔记——第五十八讲——特征值与特征向量的判定</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100585358">线性代数学习笔记——第五十九讲——特征值与特征向量的计算</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100585433"> 线性代数学习笔记——第六十讲——特征多项式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100654266">线性代数学习笔记——第六十一讲——矩阵函数、逆矩阵、伴随矩阵的特征值与特征向量</a><br><strong>§5.2 矩阵的相似对角化</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100654621">线性代数学习笔记——第六十二讲——矩阵的相似对角化引例</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100654919">线性代数学习笔记——第六十三讲——相似的定义与性质</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100661294">线性代数学习笔记——第六十四讲——相似对角化的判定（1）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100662028">线性代数学习笔记——第六十五讲——相似对角化的判定（2）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100665386">线性代数学习笔记——第六十六讲——矩阵方幂的计算</a></p><p><strong>§5.3 n维向量空间的正交性</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100669700">线性代数学习笔记——第六十七讲——向量的内积</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100670303">线性代数学习笔记——第六十八讲——柯西—施瓦兹（Cauchy-Schwarz）不等式</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100676734">线性代数学习笔记——第六十九讲——正交向量组与标准正交基</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100677372">线性代数学习笔记——第七十讲——格拉姆—施密特（Gram-Schmidt）正交化方法</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100677838">线性代数学习笔记——第七十一讲——正交矩阵</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100708919">线性代数学习笔记——第七十二讲——共轭矩阵</a></p><p><strong>§5.4实对称矩阵的相似对角化</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100715687">线性代数学习笔记——第七十三讲——实对称矩阵的特征值与特征向量</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100715880">线性代数学习笔记——第七十四讲——实对称矩阵的相似对角化</a></p><h4 id="第六章——二次型与二次曲面">第六章——二次型与二次曲面</h4><p><strong>§6.1.实二次型</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100750410">线性代数学习笔记——第七十五讲——二次型及其矩阵表示</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100751105">线性代数学习笔记——第七十六讲——矩阵的合同</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100751420">线性代数学习笔记——第七十七讲——用配方法化二次型为标准型</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100751854">线性代数学习笔记——第七十八讲——用正交变换化二次型为标准型</a><br><strong>§6.2. 正定二次型</strong></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100752201">线性代数学习笔记——第七十九讲——正定二次型的概念</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100752518">线性代数学习笔记——第八十讲——正定二次型的性质（1）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100780293">线性代数学习笔记——第八十一讲——正定二次型的性质（2）</a></p><p><a href="https://blog.csdn.net/hpdlzu80100/article/details/100780570">线性代数学习笔记——第八十二讲——二次型的其它类型</a></p>              </div>            </details><p>一些总结，可能较零碎。</p><hr><p>本节是线代某些知识点总结，可能较零碎。</p><p>对于简单的知识点，例如“两行对应成比例，<a href="https://so.csdn.net/so/search?q=%E8%A1%8C%E5%88%97%E5%BC%8F&amp;spm=1001.2101.3001.7020">行列式</a>为0&quot;就不讲了。暂时不举例题，有时间会继续补充！</p><h4 id="一-初等行-列变换">一.初等行/列变换</h4><h5 id="1-计算行列式时，行列变换都可">1.计算行列式时，行列变换都可</h5><p>因为<img src="https://latex.csdn.net/eq?D%3DD%5E%7BT%7D" alt="D=D^{T}">，所以不论动行/列都是等价的。</p><blockquote><p>变换规则：</p><p>1.“倍乘”：行列式的某行(列)乘某个元素k。相应的，若行列式中某行(列)元素有公因子k(k≠0)，则k可提到行列式外面，即:</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be10e4590.png" alt="img"></p><p>2.“互换”：行列式中两行(列)互换，行列式变号。</p><p>3.“倍加”：某行(列)的k倍加到另一行(列)，行列式不变。</p></blockquote><h5 id="2-求矩阵的秩时，行列变换都可">2.求<a href="https://so.csdn.net/so/search?q=%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9&amp;spm=1001.2101.3001.7020">矩阵的秩</a>时，行列变换都可</h5><p>因为初等变换不改变某个矩阵非零子式的最高阶数，秩指的就是非零子式的最高阶数。</p><blockquote><p>初等变换的规则：</p><p>1.“倍乘”：一个非零常数乘矩阵矩阵的某一行(列)。</p><p>2.“互换”：互换矩阵中某两行(列)的位置。</p><p>3.“倍加”：将矩阵的某一行(列)的k倍加到令一行(列)。</p><p><strong>注意：</strong></p><p>某矩阵乘元素k，是矩阵中的每个元素都成k，要与行列式区分。</p><p>也就是<img src="https://latex.csdn.net/eq?%7CkA%7C%3Dk%5En%7CA%7C" alt="|kA|=k^n|A|">。</p></blockquote><h5 id="3-解线性方程组时，仅能使用初等行变换">3.解<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84&amp;spm=1001.2101.3001.7020">线性方程组</a>时，仅能使用初等行变换</h5><p>因为矩阵的每一种初等行变换都对应着线性方程组的同解变换，而作列变换会改变原来的方程。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1291006.png" alt="img"></p><h5 id="4-判定解的情况，单纯求r-A-r-A-b-的过程行列变换都可">**4.**判定解的情况，单纯求r(A),r(A,b)的过程行列变换都可</h5><p><strong>注</strong>：将r(A,b)化行阶梯求秩时，往往我们需要<strong>同时得到r(A)</strong>，如果想用列变换的话，<strong>只能对A单独列变换</strong>，千万不要将b列和A的列混合运算，这样r(A)就不准了。(但r(A,b)是准的)。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be11a1aaf.png" alt="img"><br>但是，如果涉及到求通解或唯一解，那么就只能做行变换化行阶梯了，所以建议一开始就只做行变换。</p><blockquote><p><strong>总结</strong>：求解的过程，就只进行<strong>初等行变换化行阶梯</strong>求秩，并且顺势化为行最简型求解**。**</p></blockquote><h5 id="5-求向量组极大无关组、线性表出关系，则仅行变换"><strong>5.求向量组极大无关组、线性表出关系，则仅行变换</strong></h5><p>因为初等行变换不改变列向量组的线性表出关系。例如下图，<img src="https://latex.csdn.net/eq?%5Cbeta" alt="\beta">矩阵中，![\beta_{3}=\beta_{2} +\beta_{1}](<a href="https://latex.csdn.net/eq?%5Cbeta_%7B3%7D%3D%5Cbeta_%7B2%7D">https://latex.csdn.net/eq?\beta_{3}%3D\beta_{2}</a> +\beta_{1})，<img src="https://latex.csdn.net/eq?%5Calpha" alt="\alpha">矩阵同样有这样的关系。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be11d0e76.png" alt="img"></p><h5 id="6-求向量组的秩时，行列变换都可">6.求向量组的秩时，行列变换都可</h5><p>求向量组的秩，其实最后会转化为求矩阵的秩，原理就是**“矩阵的秩=行向量组的秩=列向量组的秩”，**所以求向量组的秩也是行列变换都可。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be12a3bfe.png" alt="img"></p><p>但是一般求向量组的秩后面会继续求解极大无关组/线性表出关系，这时只能做行变换，所以还是建议从开头就只使用行变换。</p><h5 id="7-求特征值时，行列变换都可">7.求特征值时，行列变换都可</h5><p>因为特征多项式本质上是行列式，求行列式时，行列都可以换。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be12cb40c.png" alt="img"></p><h5 id="8-求特征向量时，仅做行变换">8.求特征向量时，仅做行变换</h5><p>因为求特征向量时，本质是在解线性方程组，只能进行初等行变换。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be12abf5d.png" alt="img"></p><h5 id="9-求逆矩阵时，对-A-E-仅做初等行变换">9.求逆矩阵时，对(A,E)仅做初等行变换</h5><p>因为以A−1𝐴−1左乘A得到E，以A−1𝐴−1左乘E得到A−1𝐴−1，以A−1𝐴−1左乘的过程就是做初等行变换的过程。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be136ee86.png" alt="img"></p><p>所以怎么体现A和E做了完全一样的A−1𝐴−1所带来的初等行变换，就是将A，E横着拼在一起，此时做的初等行变换就是同步的了。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be13a4143.png" alt="img"></p><h5 id=""></h5><h5 id="总结："><strong>总结：</strong></h5><blockquote><p>除了① 求行列式的值（求特征值本质上就是求行列式的值）和 ② 单纯求秩，行列变换都可，其余情况通通只做行变换。</p></blockquote><h4 id="二-要牢记">二.要牢记</h4><p>先写那么多，后面有再补充：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be14cf11b.png" alt="img"></p><p>一些推导：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be155866b.png" alt="img"></p><p>对于AB ≠ BA的补充：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be15c5aa1.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be14e0fc5.jpeg" alt="img"></p><p><strong>1.矩阵的逆</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1690f49.png" alt="img"></p><p>推导如下：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be168227d.png" alt="img"></p><p><strong>初等矩阵的逆：</strong><br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be16ad19b.png" alt="img"></p><p><strong>2.矩阵的伴随</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be16d31f9.png" alt="img"></p><h4 id="三-某某子式">三.某某子式</h4><h5 id="1-余子式">1.余子式</h5><p>在n阶行列式中，去掉元素a所在的第i行、第j列元素，由剩下的元素按原来的位置与顺序组成的n-1阶行列式称为元素a的余子式，记作Mij𝑀𝑖𝑗。</p><h5 id="2-代数余子式">2.代数余子式</h5><p>余子式Mij𝑀𝑖𝑗乘(−1)i+j(−1)𝑖+𝑗后称为a的代数余子式，记作AAij𝐴𝑖𝑗</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be177aa2f.png" alt="img"></p><h5 id="3-k阶子式">3.k阶子式</h5><p>给定一个矩阵，任取k行，任取k 列，共k2𝑘2个数构成的行列式，出现在矩阵的秩中，定义如下：</p><p>设A是mxn矩阵，则若存在k阶子式不为零，而任意k+1阶子式(如果有的话)全为零，则r(A)=k，且若A为nxn矩阵，则：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be17bac82.png" alt="img"></p><h5 id="-2"></h5><h5 id="4-k阶主子式">4.k阶主子式</h5><p>指在行列式中选k行k列，但要求行和列的下标相同。如：行为r1、r2、r3，列必须为c1、c2、c3；行为r2、r3、r5，列必须为c2、c3、c5。因此，k阶主子式不唯一。</p><p>这在矩阵相似会用到，下面会讲。</p><h5 id="5-顺序主子式">5.顺序主子式</h5><p>顺序主子式是在主子式上再加限定，顺序主子式是由 1~k 行和 1~k 列所确定的子式。</p><blockquote><p><strong>例如：</strong></p><p>1阶时：取第1行，第1列</p><p>2阶时：取第1、2行，第1、2列</p><p>3阶时：取第1、2、3行，第1、2、3列</p><p>4阶时：取第1、2、3、4行，第1、2、3、4列</p><p>实际上，主子式的主对角线元素是原 n 阶行列式的主对角线元素的一部分，<strong>且顺序相同。</strong></p><p>所以k 阶主子式是不唯一的，而 <strong>k 阶顺序主子式是唯一的</strong>。</p></blockquote><p>用在判断<strong>二次型正定</strong>上，下面会讲。</p><h4 id="四-矩阵的秩">四.矩阵的秩</h4><p>① 0 &lt;= r(A) &lt;= min{m,n}</p><p>② r(kA)=r(A)(k ≠ 0)</p><p>③ r(AB) &lt;= min{r(A),r(B)}</p><p>④ r(A+B) &lt;=r(A)+r(B)</p><p>⑤</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be17ac8a1.png" alt="img"></p><p>r(A)=n-1,r(A*)=1的证明：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1808208.jpeg" alt="img"></p><p>进而可得出一个重要结论：</p><blockquote><p><em><em><em>*</em>*****************A************m****∗****n********************B************n****∗****s**************=****0************𝐴𝑚∗𝑛𝐵𝑛∗𝑠=0*****</em>*</em>，则r(A)+r(B)&lt;=n****</p></blockquote><p>所以，看到A*B就要想到两个结论：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be18c42df.png" alt="img"></p><p>⑥ 设A是m*n矩阵，P,Q分别是m阶，n阶可逆矩阵，则</p><blockquote><p>r(A)=r(PA)=r(AQ)=r(PAQ)</p></blockquote><p>⑦ r(A)=r(AT)𝑟(𝐴𝑇)=r(AAT𝐴𝐴𝑇)=r(ATA𝐴𝑇𝐴)</p><p>关于⑤的例题：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1968a2a.png" alt="img"></p><p>为什么Ax=b有n-r+1个线性无关的解：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1a401a8.png" alt="img"></p><h5 id="-3"></h5><h4 id="五-常用特征值与特征向量">五.常用特征值与特征向量</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1977f3e.png" alt="img"></p><p><strong>注意这样一道例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1989394.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1a81805.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1a5656c.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1a9ec52.png" alt="img"></p><p>关于特征值的一些提示：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1bd81d8.png" alt="img"></p><h4 id="六-矩阵，向量组，方程组">六.矩阵，向量组，方程组</h4><p><strong>矩阵，向量组</strong></p><blockquote><p>① <strong>向量组</strong>是由有限个相同维数的行向量或者列向量组成，其中向量是由n个实数组成的有序数组,是一个n<em>1的矩阵(n维列向量)或是一个1</em>n的矩阵(n维行向量)。</p><p>② <strong>矩阵</strong>是由m*n个数排列成m行n列的数表。</p><p><strong>一个向量组可以看作是一个矩阵的列（或行）向量集合</strong>。如果一个矩阵有n列，那么这n列就可以看作是一个由n个向量组成的向量组。反过来，一个矩阵也可以看作是由其列（或行）向量组成的向量组。</p></blockquote><h5 id="1-怎么判断两个矩阵等价">1.怎么判断两个矩阵等价</h5><blockquote><p>矩阵等价的前提：A与B是****同型****矩阵，即A,B行数，列数相同</p><p>矩阵等价的<strong>充要条件</strong>：</p><p>① r(A)=r(B)</p><p>② PAQ=B，P,Q可逆</p></blockquote><h5 id="2-怎么判断两个向量组是等价向量组">2.怎么判断两个向量组是等价向量组</h5><blockquote><p>向量组等价的前提：A，B矩阵****同维****</p><p>若r( Ⅰ )=r(α1,α2,α3,α4𝛼1,𝛼2,𝛼3,𝛼4…) r(Ⅱ)=r(β1,β2,β3,β4𝛽1,𝛽2,𝛽3,𝛽4…)</p><p>向量组等价的<strong>充要条件</strong>：<br>① r(Ⅰ)=r(Ⅱ)，且(Ⅰ)可由(Ⅱ)线性表出（单向表出即可）</p><p>② r(Ⅱ)=r(Ⅰ)，且(Ⅱ)可由(Ⅰ)线性表出（单向表出即可）</p><p>③ r(α1,α2,α3,α4𝛼1,𝛼2,𝛼3,𝛼4…) =r(β1,β2,β3,β4𝛽1,𝛽2,𝛽3,𝛽4…) =r(α1,α2,α3,α4𝛼1,𝛼2,𝛼3,𝛼4…,β1,β2,β3,β4𝛽1,𝛽2,𝛽3,𝛽4…)，即</p><p>r(Ⅰ)=r(Ⅱ)=r(Ⅰ，Ⅱ)</p><p>④ Ⅰ和Ⅱ能够相互线性表示。</p></blockquote><blockquote><p><strong>总结：</strong><br>① 两个矩阵A与B等价指的是A可以通过有限次初等变换变成B。两个不同型矩阵是不可能等价<br>乡<br>② 两个向量组等价只指的是它们能够互相线性表示，它们各自所含向量的个数可能是不一样的。</p></blockquote><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1c02c42.png" alt="img"></p><blockquote><p>D.即使Ⅰ 和 Ⅱ 同为n维向量组，但是s与t的关系未知，也就是行数相等，列数未知，所以A，B两个矩阵可能不同型，不能等价。</p><p>B.(Ⅰ)可由（Ⅱ）表示，缺少其他条件，如果① 加上(Ⅱ)可由(Ⅰ)线性表出 或者② r(Ⅰ)=r(Ⅱ)就对了</p><p>C正确</p><p>D r(A)=r(B)，只能推出两个向量组秩相同，缺少其他条件，如果加上① 加上(Ⅱ)可由(Ⅰ)线性表出 或者②加上(Ⅰ )可由(Ⅱ)线性表出或者③ r(Ⅰ)=r(Ⅱ)=r(Ⅰ，Ⅱ)，就对了。</p></blockquote><h5 id="3-矩阵和向量等价的比较">3.矩阵和向量等价的比较</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1bf17fc.png" alt="img"></p><p><strong>例题：</strong></p><h5 id="img"><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1c75912.png" alt="img"></h5><blockquote><p>A.(α1,α2,α3,0𝛼1,𝛼2,𝛼3,0)能与(α1,α2,α3𝛼1,𝛼2,𝛼3)相互线性表示，但是(α1,α2,α3,0𝛼1,𝛼2,𝛼3,0)不是Ax=0的基础解系</p><p>B.基础解系一定是线性无关的，但是B选项3个向量是线性相关的（3个向量相加=0）</p><p>C.像上面举的例子一样，α1α2𝛼1𝛼2，β1β2𝛽1𝛽2等秩，但是α1α2𝛼1𝛼2与β1β2𝛽1𝛽2不能相互线性表示。</p><p>D.<img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1c58bf6.png" alt="img"></p><p>在(α1,α2,α3𝛼1,𝛼2,𝛼3)的右边乘可逆矩阵，不改变原来矩阵的秩，且(β1,β2,β3𝛽1,𝛽2,𝛽3)与(α1,α2,α3𝛼1,𝛼2,𝛼3)能相互线性表示</p><p><strong>所以，求Ax=0的另一个基础解析，需要满足与(*<em>******************α********1**********,**********α********2**********,**********α********3******************𝛼1,𝛼2,𝛼3*****</em>)等价且等秩。</strong></p></blockquote><h5 id="-4"></h5><h5 id="4-同解方程组">4.同解方程组</h5><p>若两个方程组Am∗nx=0𝐴𝑚∗𝑛𝑥=0与Bs∗nx=0𝐵𝑠∗𝑛𝑥=0有完全相同的解，则称它们为同解方程组</p><blockquote><p><strong>充要条件：</strong></p><p>① Ax=0的解满足Bx=0，且Bx=0的解满足Ax=0(互相把解代入求出结果即可)</p><p>② r(A)=r(B)，且Ax=0的解满足Bx=0(或Bx=0的解满足Ax=0)</p><p>③ r(A)=r(B)=r([AB][𝐴𝐵])(三秩相同)</p></blockquote><p><strong>例1：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1c67ad1.png" alt="img"></p><p><strong>例2：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1da3ebf.png" alt="img"></p><p><strong>例3：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1da5b0a.png" alt="img"></p><h5 id="-5"></h5><h4 id="七-齐次线性方程组和非齐次线性方程组">七.齐次线性方程组和非齐次线性方程组</h4><blockquote><p><strong>齐次线性方程组有解的条件：</strong></p><p>① r(A)=n时，方程组有<strong>唯一零解</strong>。</p><p>② r(A)=r&lt;n时，方程组有非零解（无穷多解），且有n-r个线性无关解</p><p><strong>齐次方程组其实就是解和系数的正交</strong>，例如，给你一个条件：</p><p>α1=2α2+α3𝛼1=2𝛼2+𝛼3----&gt;α1−2α2−α3+0α4=0𝛼1−2𝛼2−𝛼3+0𝛼4=0</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1dbfe23.png" alt="img"></p><p>则(1 -2 -1 0)就是齐次方程组的基础解系</p></blockquote><blockquote><p><strong>非齐次线性无关组有解的条件：</strong></p><p>① 若r(4)≠r([A,b])，则方程组无解；<br>② 若r(A)=r([A,b])=n，则方程组有唯一解；<br>③ r(A)=r([A,b])=r&lt;n，则方程组有无穷多解。</p></blockquote><blockquote><p>非齐次方程组的通解的求法：</p><p>①求Ax=0的解</p><p>② 求Ax=b的一个特解</p><p>③ 非齐次方程组的通解=齐次方程组的解+一个非齐次的特解</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1ed632d.png" alt="img"></p><blockquote><p>如果A行满秩，则r(A)=r(A|b)，那么方程组一定有解。</p><p>如果A列满秩，则r(A)与r(A|b)的关系不确定：</p><p>① <strong>r(A)&lt;r(A|b)，则无解</strong></p><p>② <strong>r(A)=r(A|b)&lt;n，有无穷多解</strong></p><p>③ <strong>r(A)=r(A|b)=n，有唯一解</strong></p></blockquote><p><strong>非齐次方程组解的性质：</strong></p><blockquote><p>若η1η2η3𝜂1𝜂2𝜂3是非齐次线性方程组Ax=b的解，ξ𝜉是对应齐次方程组Ax=0的解，则：<br>(1) η1−η2𝜂1−𝜂2是Ax=0的解；（2）kξ+η𝑘𝜉+𝜂是Ax=b的解</p></blockquote><p>扩展：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1ec96b0.png" alt="img"></p><blockquote><p>解释：</p><p>1.p个解的任意组合，都是齐次线性方程组的解</p><p>2.非齐次的解线性组合也能得到齐次线性方程组的解，但是需要满足k1+k2+…+kp=0，例如，α1−α2𝛼1−𝛼2=0(1-1=0),α1−α2𝛼1−𝛼2就是齐次线性方程组的解。</p><p>3.非齐次的解线性组合也能得到非齐次线性方程组的解，但是需要满足k1+k2+…+kp=1，例如，(α1+α2)/2(𝛼1+𝛼2)/2，就是非齐次线性方程组的一个解。</p><p>4.齐次线性方程组的解与非齐次线性方程组的解相加，得到的是非齐次线性方程组的解。</p><p>5.r(A)=r，A就有n-r个线性无关的解，而x1,x2,…xn−r𝑥𝑛−𝑟刚好是Ax=0的n-r个线性无关解，所以</p><p>k1x1+k2x2+…+kn−rxn−r𝑘𝑛−𝑟𝑥𝑛−𝑟是Ax=0的解。</p></blockquote><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1eca0c3.png" alt="img"></p><blockquote><p>A.α1−α2𝛼1−𝛼2是组合系数是1-1=0，α1−α2𝛼1−𝛼2是Ax=0的解</p><p>B.3α1−2α23𝛼1−2𝛼2是Ax=b的解，C,D同理。</p></blockquote><h5 id="-6"></h5><h4 id="八-对比记忆"><strong>八.对比记忆</strong></h4><p><strong>1.</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1f5ee5b.png" alt="img"></p><p><strong>矩阵A的tr(A)：tra(A)=矩阵A的迹=对角线元素之和</strong></p><p>**2.**对于秩为1的n阶矩阵A或A=αβT𝛼𝛽𝑇(或βTα𝛽𝑇𝛼)（a,β都是n维非零列向量），其特征值为λ1λ2λ3…λn−1𝜆1𝜆2𝜆3…𝜆𝑛−1=0，λn=∑ni=1aii=βTα𝜆𝑛=∑𝑖=1𝑛𝑎𝑖𝑖=𝛽𝑇𝛼（或αTβ𝛼𝑇𝛽）</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be1f593c8.png" alt="img"></p><p><strong>3.</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be204a814.png" alt="img"></p><p><strong>例题1：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2066a1e.png" alt="img"></p><p><strong>例题2：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be20bc1f4.png" alt="img"></p><h4 id="九-相似与正交"><strong>九.相似与正交</strong></h4><p>存在n阶可逆矩阵P，使得P−1AP=B𝑃−1𝐴𝑃=𝐵,则称A相似于B，记为A~B</p><blockquote><p>若A~B</p><p>① |A|=|B|</p><p>② r(A)=r(B)</p><p>③ tr(A)=tr(B)</p><p>④ λA=λB𝜆𝐴=𝜆𝐵（|λE−A|=|λE−B||𝜆𝐸−𝐴|=|𝜆𝐸−𝐵|）</p><p>⑤ r(λE−A)=r(λE−B)𝑟(𝜆𝐸−𝐴)=𝑟(𝜆𝐸−𝐵)</p><p><em><strong>*⑥ A，B各阶主子式之和分别相同*</strong></em></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be222816e.png" alt="img"></p><p>也就是说，A与B即使特征值相同，但也不一定相似。但是如果A，B都是实对称矩阵，那么相似，则一定特征值相同（实对称矩阵一定能相似对角化，特征值相同一定能相似于同一个对角矩阵，根据传递性A~B）。</p><p><strong>那么怎么判定矩阵相似呢？</strong></p><blockquote><p>① 定义法</p><p>存在n阶可逆矩阵P，使得P−1AP=B𝑃−1𝐴𝑃=𝐵</p><p>② 传递法</p><p>A~ΛΛ，ΛΛ~B，则A~B，其中ΛΛ为对角阵</p><p>这就要说到矩阵的相似对角化</p></blockquote><p><strong>矩阵可相似对角化的条件：</strong></p><blockquote><p><strong>充要条件：</strong></p><p>① n阶矩阵A可相似对角化↔有n个线性无关的特征向量。</p><p>② n阶矩阵A可相似对角化↔A对应于每个k重特征值都有k个线性无关的特征向量</p><p><strong>必要条件：</strong></p><p>③ n阶矩阵A有n个不同特征值→A可相似对角化</p><p>④ n阶矩阵为<strong>实对称矩阵</strong>→A可相似对角化</p></blockquote><p>对于矩阵相似对角化的步骤：</p><blockquote><p>① 求特征值</p><p>② 求特征向量</p><p>③ 正交化（如果需要的话），单位化η1η2η3…ηn𝜂1𝜂2𝜂3…𝜂𝑛</p><p>④ 令Q=[η1η2η3…ηn𝜂1𝜂2𝜂3…𝜂𝑛],则Q为正交矩阵，且Q−1AQ=QTAQ=Λ𝑄−1𝐴𝑄=𝑄𝑇𝐴𝑄=Λ</p></blockquote><p>上面提到了实对称矩阵，实对称矩阵就是组成A的元素都是实数。对于实对称矩阵（AT=A𝐴𝑇=𝐴）要记住：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2250f42.png" alt="img"></p><blockquote><p><strong>对于正交，你需要记住：</strong><br>① αTβ=0𝛼𝑇𝛽=0，则<img src="https://latex.csdn.net/eq?%5Calpha" alt="\alpha">，<img src="https://latex.csdn.net/eq?%5Cbeta" alt="\beta">是正交向量</p><p>② 若满足ATA=E𝐴𝑇𝐴=𝐸，则A是正交矩阵</p><p>ATA=E𝐴𝑇𝐴=𝐸↔A−1=AT𝐴−1=𝐴𝑇</p></blockquote><p>例题：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be20c78f6.png" alt="img"></p><p><strong>不可对角化的矩阵怎么判断相似：</strong></p><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2286469.png" alt="img"></p><blockquote><p>如果A与B相似，那么：</p><p>对于任意实数k和整数n，有(A+kE)n(𝐴+𝑘𝐸)𝑛与(B+kE)n(𝐵+𝑘𝐸)𝑛相似</p><p>对于上面这道题，取k=-1，n=1，判断哪两个矩阵相似。</p></blockquote><p><strong>矩阵相似还可得出：</strong></p><blockquote><p>① A~B，Ak=Bk𝐴𝑘=𝐵𝑘，f(A)=f(B)</p><p>② 若A~B，且A可逆，则A−1𝐴−1~B−1𝐵−1，f(A−1𝐴−1)=f(B−1𝐵−1)</p><p>③ 若A~B，A∗𝐴∗~B∗𝐵∗</p><p>④ 若A~B，AT𝐴𝑇~BT𝐵𝑇</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be22f103e.png" alt="img"></p></blockquote><p><strong>注：</strong></p><h4 id="img-2"><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be23741bd.png" alt="img"></h4><h5 id="-7"></h5><h4 id="十-合同">十.合同</h4><p>设A，B为n阶矩阵，若存在可逆矩阵C，使得CTAC=B𝐶𝑇𝐴𝐶=𝐵，则称A与B合同，即A≅B𝐴≅𝐵。A与B合同，就是指同一个<strong>二次型</strong>在<strong>可逆线性变换</strong>下的两个不同状态的联系。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be23716ca.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be23c6528.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be240b87e.png" alt="img"></p><p>**注：**由于我们已经规定，对称矩阵才是二次型矩阵，所以二次型矩阵都是对称矩阵，相应的和对称矩阵合同的矩阵也是对称矩阵。</p><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be23c6692.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be245dd6f.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be24aba92.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be24a8cd1.png" alt="img"></p><h5 id="-8"></h5><h4 id="十一-二次型">十一.二次型</h4><p>关于二次型化标准型或规范型的方法：配方法，正交变化有总结如下：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be260b287.png" alt="img"></p><p><strong>所以我们可以进一步得到</strong></p><h5 id="等价，合同和相似的关系："><strong>等价，合同和相似的关系：</strong></h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be26b3cd5.png" alt="img"></p><p>**注：**相似一定合同的前提条件是A，B都是实对称矩阵</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2634cf1.png" alt="img"></p><p><strong>例题：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be265a9df.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be27a8028.png" alt="img"></p><p>关于配方法和正交变换分别给一个例题：<br><strong>配方法：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be28c1744.png" alt="img"></p><p><strong>正交变换：</strong><br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be27ea985.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be27d854c.png" alt="img"></p><blockquote><p>① 若λ1=λ2𝜆1=𝜆2，那么两个同一特征值对应的特征向量需要正交化，如果本来就正交可以不做这一步，所以在计算特征值的时候，可以将两个特征向量写为正交的，这样就免去了施密特正交化，直接进入单位化即可。</p><p>② λ1≠λ2≠λ3𝜆1≠𝜆2≠𝜆3，那么不用进行施密特正交，直接单位化即可。</p></blockquote><p><strong>常见题型：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be27a8802.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be28ccb91.png" alt="img"></p><p>这里记录一个例题：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be29b50e6.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be29d5c66.png" alt="img"></p><p>若二次型中只有混合项，没有平方项，要怎么做？</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2a51d99.png" alt="img"></p><h4 id="十二-二次型正定">十二.二次型正定</h4><blockquote><p><strong>二次型正定的充要条件：</strong><br>n元二次型f=xTAx𝑓=𝑥𝑇𝐴𝑥正定↔对任意x≠0，有xTAx𝑥𝑇𝐴𝑥&gt;0（定义）</p><p>① ↔f的正惯性指数p=n</p><p>② ↔存在可逆矩阵D，使得A=DTD𝐴=𝐷𝑇𝐷</p><p>③ ↔A≅E𝐴≅𝐸，A与E合同</p><p>② ③推导：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be29ead4d.png" alt="img"></p><p>④↔A的特征值λ𝜆&gt;0</p><p>⑤↔A的全部顺序主子式&gt;0</p><p><strong>二次型正定的必要条件：</strong></p><p>① aii𝑎𝑖𝑖&gt;0，对角线元素全部大于0</p><p>② |A|&gt;0</p></blockquote><p>最好是使用充要条件① ④ ⑤判断二次型是否正定，如果非要用定义法，来看个例题：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2b97057.png" alt="img"></p><p>注意上题，不能直接将f判定为正定：</p><p>因为将二次型化为标准型的过程一定要做<strong>可逆线性变换</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2b73fd4.png" alt="img"></p><p><strong>例题1：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2bde67d.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2bbdd65.jpeg" alt="img"></p><p><strong>例题2：</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2c370ad.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2bd06ac.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2de5d54.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9be2f0a59c.png" alt="img"></p>]]></content>
    
    
    <summary type="html">收集到的一些高代复习资料</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构复习其二</title>
    <link href="https://zhongye1.github.io/posts/7eb63ac7.html"/>
    <id>https://zhongye1.github.io/posts/7eb63ac7.html</id>
    <published>2024-07-25T18:48:08.000Z</published>
    <updated>2024-07-31T03:58:47.890Z</updated>
    
    <content type="html"><![CDATA[<ul><li></li></ul><h3 id="——算法、线性表——">——算法、线性表——</h3><h3 id="概念明晰：随机存取、顺序存取、随机存储和顺序存储">概念明晰：随机存取、顺序存取、随机存储和顺序存储</h3><blockquote><p>随机存取、顺序存取、随机存储和顺序存储这四个概念是完全不一样的，切不可将之混淆</p><p>很多人包括我可能认为随机存取就是随机存储，顺序存取就是顺序存取，其实不是这样。</p></blockquote><p>下面完整的介绍一下这4个概念</p><h5 id="1、存取结构">1、存取结构</h5><h5 id="分为随机存取和非随机存取（又称顺序存取）">分为<code>随机存取</code>和<code>非随机存取</code>（又称顺序存取）</h5><blockquote><p>1、<code>随机存取</code>就是<code>直接存取</code>，可以通过<strong>下标直接访问</strong>的那种<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;spm=1001.2101.3001.7020">数据结构</a>，与<strong>存储位置无关</strong>。例如数组。</p><p><code>非随机存取</code>就是<code>顺序存取</code>，不能通过下标访问了，只能<strong>按照存储顺序存取</strong>，与<strong>存储位置有关</strong>，例如链表。</p><p>2、<code>顺序存取</code>就是存取第N个数据时，<strong>必须先访问</strong>前（N-1）个数据 （list）;</p><p><code>随机存取</code>就是存取第N个数据时，<strong>不需要</strong>访问前（N-1）个数据，<strong>直接</strong>就可以对第N个<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C&amp;spm=1001.2101.3001.7020">数据操作</a> （array）。</p></blockquote><h5 id="2、存储结构">2、存储结构</h5><h5 id="分为顺序存储和随机存储">分为<code>顺序存储</code>和<code>随机存储</code></h5><h5 id="3、顺序存储结构">3、顺序存储结构</h5><blockquote><ul><li><p>在计算机中用一组<strong>地址连续的存储单元</strong>依次存储线性表的各个数据元素，称作线性表的顺序存储结构。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>顺序存储结构是存储结构类型中的一种，该结构是把<span class="strong">**逻辑上相邻的节点**</span>存储在<span class="strong">**物理位置上相邻的存储单元**</span>中，结点之间的逻辑关系由存储单元的邻接关系来体现。 </span><br><span class="line"><span class="bullet">- </span>由此得到的储结构为顺序存储结构，通常顺序存储结构是借助于计算机程序设计语言（例如c/c++）的数组来描述的。</span><br><span class="line">12</span><br></pre></td></tr></table></figure></li></ul><p>– <strong>主要优点</strong>：节省存储空间。</p><p>因为分配给数据的存储单元全用存放结点的数据（不考虑c/c++语言中数组需指定大小的情况），结点之间的逻辑关系没有占用额外的存储空间。采用这种方法时，<strong>可实现对结点的随机存取</strong>，即每一个结点对应一个序号，由该序号可以<strong>直接计算出来结点的存储地址</strong>。</p><p>– <strong>主要缺点</strong>：不便于修改，对结点的插入、删除运算时可能要移动一系列的结点。</p></blockquote><h5 id="4、随机存储结构">4、随机存储结构</h5><blockquote><p>在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。它不要求逻辑上相邻的元素在物理位置上也相邻。因此它没有顺序存储结构所具有的弱点，但也同时失去了顺序表可随机存取的优点。</p></blockquote><p>–随机存储<strong>最典型的代表</strong>为链式存储：</p><p>链式存储结构特点</p><p>1、比顺序存储结构的存储密度小 （每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多）。</p><p>2、逻辑上相邻的节点物理上不必相邻。</p><p>3、插入、删除灵活 （不必移动节点，只要改变节点中的指针）。</p><p>4、查找结点时链式存储要比顺序存储慢。</p><p>5、每个结点是由数据域和指针域组成</p><h4 id="一、数据结构的概念">一、数据结构的概念</h4><h5 id="1、基本概念">1、基本概念:</h5><blockquote><ul><li>数据：描述客观事实的符号，是计算机中可以操作的对象，能被计算机识别，并输给计算机处理的符号集合。</li><li>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被成为记录。</li><li>数据对象：是性质相同数据元素的集合，是数据的一个子集。</li><li>数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位。</li><li>数据结构：相互之间存在一种或者多种特定关系的数据元素的集合。可分为逻辑结构和物理结构。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3aa801.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-H2EEsw2b-1641217649127)(myReviewPicture/数据结构的类别-16411800000834.jpg)]"></p><h5 id="2、算法">2、算法</h5><h6 id="1-概念">(1)概念</h6><blockquote><p>解决特定问题的求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p></blockquote><h6 id="2-重要特性：">(2)重要特性：</h6><blockquote><p><strong>①输入</strong>：有零个输入或者多个输</p><p><strong>②输出</strong>：只有一个或者多个输出</p><p><strong>③有穷性</strong>：算法在执行有限个步骤时，会自动结束而不会陷入无限循环里面</p><p><strong>④确定性</strong>：算法的每一步都有确定的含义而不会出现二义性</p><p><strong>⑤可行性</strong>：算法的每一步都可以通过有限次数完成。</p></blockquote><h5 id="3、算法的评价标准-“好”的算法应该考虑达到以下目标">3、算法的评价标准(“好”的算法应该考虑达到以下目标)</h5><blockquote><p><strong>①正确性</strong>。算法能够正确地求解问题。</p><p><strong>②可读性</strong>。算法能具有良好的可读性，以帮助人们理解。</p><p><strong>③健壮性</strong>。输入非法数据时，算法能适当地做出反应或进行处理。而不会产生莫名其妙的输出结果。</p><p><strong>④效率与低存储量需求</strong>。效率指算法执行的时间，存储量需求是指算法执行过程中所需的最大存储空间。</p></blockquote><h5 id="4、算法的时空效率">4、算法的时空效率</h5><h6 id="1-时间复杂度">(1)时间复杂度</h6><h6 id="根据算法写成的程序在执行时耗费时间的长度，记为T-n-O-n">根据算法写成的程序在执行时耗费时间的长度，记为T(n) = O(n)</h6><h6 id="2-空间复杂度">(2)空间复杂度</h6><h6 id="根据算法写成的程序在执行时占用存储单元的长度记为S-n">根据算法写成的程序在执行时占用存储单元的长度记为S(n)</h6><h6 id="3-语句频度">(3)语句频度</h6><h6 id="一个算法中的语句执行次数称为语句频度或时间频度，记为T-n">一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)</h6><blockquote><p>时间复杂度：时间复杂度实际上是一个函数，代表基本操作重复执行的次数，进而分析函数虽变量的变化来确定数量级，数量级用O表示，所以算法的时间复杂度为： T（n）=O（f（n））</p></blockquote><blockquote><p>在一个算法存在最好、平均、最坏<strong>三种情况</strong>，我们一般关注的是<strong>最坏情况</strong>，原因是，最坏情况是任何输入实例在运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，从大体上来看，平均情况和最坏情况一样差。</p></blockquote><h6 id="4-一般O（n）的计算方法：">(4)一般O（n）的计算方法：</h6><blockquote><p>①用 1代替所有运行时间中出现的<strong>加法常数</strong>；</p><p>②在修改后的运行函数中**保留最高阶的项；</p><p>③如果<strong>最高阶</strong>的<strong>项系数不是1</strong>，则<strong>去除</strong>这个项系数。</p><p>④ <strong>递归算法</strong>的时间复杂度为：递归总次数每次递归中基本操作执行的次数。</p></blockquote><h6 id="5-常见的时间复杂度有以下七种：">(5)常见的时间复杂度有以下七种：</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3338b6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fChDxRHo-1641217649129)(myReviewPicture/时间复杂度的比较-16411800195595.png)]"></p><p><strong>① O（1）常数型；② O（log2N）对数型；③ O（N）线性型；④ O（Nlog2N）二维型；⑤ O（N^2)平方型；⑥ O（N^3)立方型；⑦ O（2^N）指数型。</strong></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;①</span><br><span class="line"><span class="keyword">while</span> (i&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">i=i*<span class="number">2</span>; ②</span><br><span class="line">&#125;</span><br><span class="line">解：语句<span class="number">1</span>的频度是<span class="number">1</span>, </span><br><span class="line">设语句<span class="number">2</span>的频度是f(n),则：<span class="number">2</span>^f(n)&lt;=n;f(n)&lt;=log2n  </span><br><span class="line">取最大值f(n)= log2n, T(n)=O(log2n )</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h3 id="二、线性表">二、线性表</h3><h4 id="1、顺序存储">1、顺序存储</h4><h5 id="1-结构体的定义">(1)结构体的定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> * PtrToLNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElmenetType Data[ MAXSIZE ];</span><br><span class="line">    Position Last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h5 id="2-顺序表的初始化">(2)顺序表的初始化</h5><blockquote><p>1、构造一个空表</p><p>2、动态分配表结构所需的存储空间，然后将表中Last指针置为-1 表示表中没有数据。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    L = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    L-&gt;Last = <span class="number">-1</span>;<span class="comment">//Last 置为-1 表示表中没有数据元素</span></span><br><span class="line">    Return L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><ul><li>通过L我们可以访问相应线性表的内容。比如：下标为i 的元素：L-&gt;Data[i]</li><li>查询线性表的长度：L-&gt;Last+1;</li></ul><h5 id="3-顺序表的查找-时间复杂度为O-n">(3)顺序表的查找(时间复杂度为O(n))</h5><blockquote><p>在线性表中<strong>查找与给定值 X 相等</strong>的数据元素。</p><p>由于线性表的元素都<strong>存储在数组Data</strong>中，所以这个查找的过程<strong>实际上就是在数组里顺序查找</strong>：</p><ul><li>从<strong>第 1 个元素 a1</strong> 起依次和 X 比较， 直到找到一个与 X <strong>相等</strong>的数据元素，返回它在顺序表中的<strong>存储下标</strong>；</li><li>或者<strong>查遍整个表</strong>都<strong>没有找到</strong>与 X 相等的元素，则返回错误信息 <strong>ERROR</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR -1  <span class="comment">/* 将错误信息 ERROR 的值定义为任一负数都可以 */</span></span></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">While</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X)</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span>( i &gt; L-&gt;Last)</span><br><span class="line">    <span class="keyword">return</span> ERROR;<span class="comment">/* 如果没有找到，则返回错误信息 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> i;<span class="comment">/* 找到后返回的是存储位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h5 id="4）顺序表的插入-时间复杂度为O-n">(4）顺序表的插入 (时间复杂度为O(n))</h5><blockquote><p>在表的插入是指在表的第 i（1≤ i ≤ n + 1）个位序上<strong>插入一个值为 X 的新元素</strong>（也可以理解为在第 i 个元素之前插入新的元素）</p><p>插入后使得<strong>原来长度为 n</strong> 的序列，变为<strong>长度为 n+1</strong>的序列（i = 1时插入序列的最前端，i = n+1 时插入序列的最后）</p><ul><li>将ai~an<strong>顺序向后</strong>移动（移动次序是从 an 到ai)，<strong>为新元素让出位置</strong>；</li><li>将 X 放入空出的<strong>第 i 个位序</strong>；</li><li><strong>修改</strong> Last 指针（相当于修改表长）,使之指向<strong>最后一个元素</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">( List L, ElementType X, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 在 L 的指定位序 i 前插入一个新元素 X； 位序 i 元素数组位置下标为 i-1 */</span></span><br><span class="line">    Postion j;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Last == MAXSIZE<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="comment">/* 表空间已满，不能插入 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表满！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( i&lt;<span class="number">1</span> || i &gt; L-&gt;Last+<span class="number">2</span>)</span><br><span class="line">    &#123;<span class="comment">/* 检查插入位序的合法性：是否在 1~n+1； n为当前元素个数，即Last+1 */</span></span><br><span class="line">        printf（<span class="string">&quot;位序不合法！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( j = L-&gt;Last; j &gt;= i<span class="number">-1</span>; j--) <span class="comment">/*Last 指向序列最后元素an */</span></span><br><span class="line">        L-&gt;Data[j+<span class="number">1</span>] = L-&gt;Data[j]; <span class="comment">/* 将位序为 i 及以后的元素顺序向后移动 */</span></span><br><span class="line">   L-&gt;Data[i<span class="number">-1</span>] = X;<span class="comment">/* Last 仍指向最后一个元素 */</span></span><br><span class="line">    L-&gt;Last++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure><h5 id="5-顺序表的删除（时间复杂度为O-n-）">(5)顺序表的删除（时间复杂度为O(n)）</h5><blockquote><p>将表中的位序为 i（1≤ i ≤ n + 1）的元素从线性表中去掉，删除后使原长度为 n 的数组元素序列,变为长度为 n-1 的序列</p><ul><li>将a[i+1]~a[n] <strong>顺序向前移动</strong> ，a[i] 元素被a[i+1]覆盖；</li><li><strong>修改</strong> Last 指针（相当于修改表长）使之仍指向<strong>最后一个元素</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Delete</span><span class="params">(List L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">/*从 L 中删除指定位序 i 的元素，该元素数组下标为 i-1*/</span></span><br><span class="line">Position j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;Last + <span class="number">1</span>)<span class="comment">/* 检查空表及删除位序的合法性*/</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;位序%d不存在元素&quot;</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>( j = i; i &lt;= L-&gt;Last; j++)</span><br><span class="line">L-&gt;Data[j<span class="number">-1</span>] = L-&gt;Data[j];<span class="comment">/*将位序 i+1 及以后的元素顺序向前移动*/</span> </span><br><span class="line">L-&gt;Last--;<span class="comment">/*Last 仍指向最后元素*/</span> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><h4 id="2、链表存储">2、链表存储</h4><h6 id="1）结构体的定义（时间复杂度为O-n-）">(1）结构体的定义（时间复杂度为O(n)）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> * PtrToLNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position; <span class="comment">/*这里的位置是结点的地址 */</span></span><br><span class="line"><span class="keyword">typedef</span> PreToLNode List;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h6 id="2-求表长（时间复杂度为O-n-）">(2)求表长（时间复杂度为O(n)）</h6><blockquote><p>在<strong>顺序存储</strong>中求表长是很容易的，<strong>直接返回 Last+1</strong> 就可以了。但在<strong>链式存储</strong>中，需要将链表<strong>从头到尾遍历一遍</strong></p><ul><li>设一个<strong>移动指针p和计数器cnt</strong>，初始化后，p从表的第 1 个结点开始逐步往后移，同时计数器 cnt+1.</li><li>当后面不再有结点时，cnt 的值就是结点个数，即 表长。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3dea89.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//默认该链表是有头结点的   </span></span><br><span class="line">Position p;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;  <span class="comment">/* 初始化计数器 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//单向链表的遍历(三部曲)</span></span><br><span class="line">p = L-&gt;next; <span class="comment">/* p指向表的第 1 个结点 */</span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123; <span class="comment">/* 遍历单链表，统计结点数 */</span> </span><br><span class="line">p=p-&gt;next;  </span><br><span class="line">i++; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h6 id="3-判空">(3)判空</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//若 L 为空，则返回1，否侧返回 0</span></span><br><span class="line"><span class="keyword">if</span>(L-&gt;Next) <span class="comment">//非空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h6 id="4-查找（时间复杂度为O-n-）">(4)查找（时间复杂度为O(n)）</h6><blockquote><p>有两种 按序号查找（FindKth）和 按值查找（Find）</p></blockquote><h6 id="①按序号查找-FindKth（时间复杂度为O-n-）">①按序号查找 FindKth（时间复杂度为O(n)）</h6><blockquote><p>对于<strong>顺序存储</strong>，按序号查找是很直接的事情，要得到<strong>第 K 个元素的值，直接取L-&gt;Data[K-1]即可</strong>。</p><p>但是对于<strong>链式存储</strong>则需要采用跟<strong>求表长类似的思路</strong>：</p><ul><li>从链表的<strong>第 1 个元素</strong>结点起，判断<strong>当前结点是否是第 K 个</strong>；</li><li>若<strong>是</strong>，则<strong>返回</strong>该结点的值，<strong>否</strong>则继续<strong>对比后一个</strong>，直到<strong>表结束为止</strong>。</li><li>如果<strong>没有</strong>第 K 个结点则返回<strong>错误信息</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR -1 <span class="comment">/* 一般定义为表中元素不可能取到的值 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">FindKth</span><span class="params">(List L, <span class="type">int</span> K)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/* 根据指定的位序 K， 返回 L 中相应的元素 */</span></span><br><span class="line">Position P;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>; <span class="comment">/* 位序从 1 开始 */</span></span><br><span class="line">p = L; <span class="comment">/* p 指向 L的第 1 个结点 */</span></span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; cnt &lt; K)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">cnt++</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((cnt == K) &amp;&amp; p)</span><br><span class="line"><span class="keyword">return</span> p-&gt;Data;<span class="comment">/* 返回第 K 个 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/* 否则返回错误信息 */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure><h6 id="②按值查找，即定位-Find（时间复杂度为O-n-）">②按值查找，即定位 Find（时间复杂度为O(n)）</h6><blockquote><p>基本方法：也是从头到尾遍历，直到找到为止：</p><ul><li>从链表的<strong>第 1 个元素</strong>结点起，判断<strong>当前结点的值是否等于 X</strong>；</li><li>若<strong>是</strong>，<strong>返回</strong>该结点的<strong>位置</strong>，<strong>否</strong>则继续<strong>对比后一个</strong>，直到<strong>表结束位置为止</strong>；</li><li><strong>找不到</strong>时返回<strong>错误信息</strong>。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR NULL <span class="comment">/*空地址表示错误 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( List L, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position p = L;<span class="comment">/* p指向 L 的第 1 个元素 */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;Data != x)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><h6 id="5-链表的插入（时间复杂度为O-n-）">(5)链表的插入（时间复杂度为O(n)）</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f4967cd.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f4db83a.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i,ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = L;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp; j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="comment">//寻找第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;<span class="comment">//</span></span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//生成新结点s</span></span><br><span class="line">    s-&gt;data = e;<span class="comment">//将结点s 的数据域的值 更新为 e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;  <span class="comment">//将结点s 插入 L 中</span></span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><h6 id="6-创建链表（时间复杂度为O-n-）">(6)创建链表（时间复杂度为O(n)）</h6><h6 id="1、带头结点的【头插法】（时间复杂度为O-n-）">1、带头结点的【头插法】（时间复杂度为O(n)）</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f3db996.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 带头结点的插入创建 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createListHead</span><span class="params">( Linklist L, <span class="type">int</span> n )</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">//建立头结点</span></span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//建立单链表（头插法）</span></span><br><span class="line">    LNode *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//申请空间，写入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode)); <span class="comment">/* 申请、填装结点 */</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp-&gt;Data);<span class="comment">//输入元素值</span></span><br><span class="line">            <span class="comment">//插入到头结点的后面</span></span><br><span class="line">        tmp-&gt;Next = L-&gt;Next; </span><br><span class="line">        L-&gt;Next = tmp;   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure><h6 id="2、带尾结点的插入【尾插法】（时间复杂度为O-n-）">2、带尾结点的插入【尾插法】（时间复杂度为O(n)）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*带尾结点的插入*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList_L</span><span class="params">( Listlist &amp;L, <span class="type">int</span> n )</span></span><br><span class="line">&#123; <span class="comment">//正位序数输入 n 个元素的值，建立带表头结点的单链表L</span></span><br><span class="line">    <span class="comment">//建立头结点</span></span><br><span class="line">       L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">   L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//建立单链表（尾插法）</span></span><br><span class="line">    LNode r = L; <span class="comment">//尾指针指向头结点</span></span><br><span class="line">    <span class="comment">//申请空间，写入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           LNode *tmp = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode)); <span class="comment">/* 申请新结点 */</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp-&gt;Data); <span class="comment">//输入元素</span></span><br><span class="line">            tmp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//插入到尾结点后面</span></span><br><span class="line">        r-&gt;next = temp; </span><br><span class="line">        r = tmp;   <span class="comment">//r指向新的尾结点</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure><h6 id="7-删除（时间复杂度为O-n-）">(7)删除（时间复杂度为O(n)）</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f6b05c3.png" alt="在这里插入图片描述"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f75405a.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线性表L 中第 i 个数据元素删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElementType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="comment">//寻找第 i 个结点，并令p指向其前驱</span></span><br><span class="line">        p = p&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||j &lt; i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;<span class="comment">//删除位置不合理</span></span><br><span class="line">    </span><br><span class="line">    q = p-&gt;next;<span class="comment">//临时保存被删除结点的地址以备释放</span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">//改变被除结点的驱结点的指针域</span></span><br><span class="line">    e = q-&gt;data;<span class="comment">//保存被删除结点的数据域</span></span><br><span class="line">    <span class="built_in">free</span>(q);<span class="comment">//释放被删除结点的空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure><h4 id="3、二者时间复杂度和优缺点的比较">3、二者时间复杂度和优缺点的比较</h4><h5 id="1、两者复杂度比较">1、两者复杂度比较</h5><table><thead><tr><th></th><th>查找</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>顺序表</td><td>O(1)</td><td>O(1)</td><td>O(n)通过下标直接找到待操作元素，主要时间花在移动元素上。</td></tr><tr><td>链表</td><td>O(n)</td><td>O(n)主要时间用于找到插入元素的位置</td><td>O(n)主要时间用于找到待删除元素的位置</td></tr></tbody></table><h5 id="2、两者优缺点比较">2、两者优缺点比较</h5><table><thead><tr><th>数组</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td></td><td>随机访问性强；查找速度快</td><td>插入和删除效率低；可能浪费内存；内存空间要求高，必须有足够的连续内存空间；数组大小固定，不能动态拓展</td></tr></tbody></table><table><thead><tr><th>链表</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td></td><td>插入删除速度快；内存利用率高，不会浪费内存；大小没有固定，拓展很灵活。</td><td>不能随机查找，必须从第一个开始遍历，查找效率低</td></tr></tbody></table><blockquote><p>两者的区别在于<strong>顺序结构</strong>的要求一片连续的存储空间，而<strong>链式结构</strong>的不要求存储空间连续。</p></blockquote><h3 id="三、栈">三、栈</h3><h4 id="1、栈的顺序存储实现">1、栈的顺序存储实现</h4><blockquote><p>通常由一个<strong>一维数组</strong>和一个记录<strong>栈顶</strong>元素位置的变量组成。</p></blockquote><h5 id="1-顺序栈结构体的定义">(1)顺序栈结构体的定义</h5><blockquote><p><strong>当 Top = -1时，表示栈空；当Top = MaxSize -1 时，栈满！</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElementType * Data;  <span class="comment">/*存储元素的数组*/</span></span><br><span class="line">Position Top; <span class="comment">/*栈顶指针*/</span></span><br><span class="line"><span class="type">int</span> MaxSize; <span class="comment">/*堆栈最大容量*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Stack;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h5 id="2-顺序栈的创建">(2)顺序栈的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">(<span class="type">int</span> MaxSize)</span> <span class="comment">/*顺序栈的创建*/</span> </span><br><span class="line">&#123;</span><br><span class="line">Stack S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">S-&gt;Data = (ElementType *)<span class="built_in">malloc</span>(MaxSize * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">S-&gt;Top = <span class="number">-1</span>;       <span class="comment">/*&quot;-1&quot;表示空栈  &quot;MaxSize-1&quot;表示满栈*/</span> </span><br><span class="line">S-&gt;MaxSize = MaxSize;      <span class="comment">/*指定栈的最大容量*/</span> </span><br><span class="line"><span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h5 id="3-判满">(3)判满</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(Stack S)</span><span class="comment">/*判断栈是否满了*/</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>(S-&gt;Top == S-&gt;MaxSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="4-判空">(4)判空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span><span class="comment">/*判断堆栈是否为空*/</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>(S-&gt;Top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="5-入栈">(5)入栈</h5><blockquote><p>在执行堆栈 Push 操作时，先判断栈是否满；</p><ul><li>若不满，Top 加1，并将新元素放入 Data数组的Top位置上</li><li>若满，则返回错误标志</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(Stack S, ElementType X)</span><span class="comment">/*顺序栈的 入栈 操作*/</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">IsFull</span>(S)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆栈满！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">S-&gt;Data[++(S-&gt;Top)] = X;<span class="comment">/*若是栈不满，则Top加 1,并将新元素放入Data数组的Top位置中*/</span> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><h5 id="6-出栈">(6)出栈</h5><blockquote><p>执行Pop操作时，首先判别栈是否为空；</p><ul><li>若不为空，返回Data[Top]，同时将Top-1;</li><li>否则要返回错误标志</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span> <span class="comment">/*顺序栈 的 出栈 操作*/</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆栈空！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/*ERROR 是 ElementType 类型的特殊值，标志错误。必须是正常栈元素数据不可能取到的值 */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>(S-&gt;Data[(S-&gt;Top)--]);<span class="comment">/*若不空，返回Data[Top]，同时将Top减 1*/</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h4 id="2、栈的顺序存储实现">2、栈的顺序存储实现</h4><blockquote><p>链栈与单链表类似，但其操作受限制，插入和删除操作<strong>只能在链栈的栈顶进行。</strong></p></blockquote><h5 id="1-顺序栈结构体的定义-2">(1)顺序栈结构体的定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">PtrToSNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElementType Data;</span><br><span class="line">PtrToSNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSNode Stack;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h5 id="2-顺序栈的创建-2">(2)顺序栈的创建</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">()</span></span><br><span class="line">&#123;<span class="comment">/*构建一个堆栈的头结点，返回该结点指针*/</span> </span><br><span class="line">Stack S;</span><br><span class="line">S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h5 id="3-判空-2">(3)判空</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*判断堆栈 S 是否为空，若是返回 true，否则返回 false*/</span> </span><br><span class="line"><span class="keyword">return</span>(S-&gt;Next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="4-判满-注意：链栈，不必判断堆栈是否满">(4)判满 注意：链栈，不必判断堆栈是否满</h5><h5 id="5-入栈-2">(5)入栈</h5><blockquote><p>链栈，<strong>不必判断堆栈是否满</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(Stack S, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*将元素 X 压入堆栈 S */</span> </span><br><span class="line">PtrToSNode TmpCell;</span><br><span class="line">TmpCell = (PtrToSNode)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">TmpCell-&gt;Data = X;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">S-&gt;Next =TmpCell;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h5 id="6-出栈-2">(6)出栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span> ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;<span class="comment">/*删除并返回堆栈 S 的栈顶元素*/</span>  </span><br><span class="line">PtrToSNode FirstCell;</span><br><span class="line">ElementType TopElem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(IsEmpty(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆栈空！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">FirstCell = S-&gt;Next;</span><br><span class="line">TopElem = FirstCell-&gt;Data;</span><br><span class="line">S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line"><span class="built_in">free</span>(FirstCell);</span><br><span class="line"><span class="keyword">return</span> TopElem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*顺序栈 的 出栈 操作*/</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;堆栈空！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/*ERROR 是 ElementType 类型的特殊值，标志错误。必须是正常栈元素数据不可能取到的值 */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>(S-&gt;Data[(S-&gt;Top)--]);<span class="comment">/*若不空，返回Data[Top]，同时将Top减 1*/</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure><h4 id="3、栈的应用">3、栈的应用</h4><h3 id="四、队列">四、队列</h3><h4 id="1、队列的顺序存储实现">1、队列的顺序存储实现</h4><h5 id="1-循环队列的结构体定义">(1) 循环队列的结构体定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType; <span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line"><span class="type">int</span> front;    <span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="type">int</span> rear;<span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h5 id="2-生成空队列">(2)生成空队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化一个空队列Q */</span></span><br><span class="line">Status <span class="title function_">CreateQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    SqQueue *Q = (SqQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">    Q-&gt;data = (ElementType*)<span class="built_in">malloc</span>(MaxSize * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h5 id="3-判空-3">(3)判空</h5><blockquote><p>队空的条件是：<strong>rear=front</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(Q-&gt;front == Q-&gt;rear);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="4-判满">(4)判满</h5><blockquote><p>队满的条件是：<strong>(rear+1)%数组的长度等于 front</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>((Q-&gt;rear+<span class="number">1</span>)% MaxSize == Q-&gt;front);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="5-入队">(5)入队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q,QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)<span class="comment">/* 队列满的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">Q-&gt;data[Q-&gt;rear]=e;<span class="comment">/* 将元素e赋值给队尾 */</span></span><br><span class="line">Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* rear指针向后移一位置， */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h5 id="6-出队">(6)出队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q,QElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)<span class="comment">/* 队列空的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e=Q-&gt;data[Q-&gt;front];<span class="comment">/* 将队头元素赋值给e */</span></span><br><span class="line">Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* front指针向后移一位置， */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h4 id="2、队列的链式存储实现">2、队列的链式存储实现</h4><blockquote><p>队列与堆栈一样，也可以采用链式存储结构，但队列的头（front）必须指向链表的头结点，队列的尾（rear）指向链表的尾结点。</p></blockquote><h5 id="1-队列的链式存储结构体定义">(1)队列的链式存储结构体定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType; <span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   QElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>/* 队列的链表结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   QueuePtr front,rear; <span class="comment">/* 队头、队尾指针 */</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h5 id="2-生成空队列-2">(2)生成空队列</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造一个空队列Q */</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123; </span><br><span class="line">Q-&gt;front=Q-&gt;rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!Q-&gt;front)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h5 id="3-判空-4">(3)判空</h5><blockquote><p>队空的条件是：<strong>rear=front</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h5 id="4-判满-链式队列，不必判断堆栈是否满">(4)判满 链式队列，不必判断堆栈是否满</h5><h5 id="5-入队-2">(5)入队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为Q的新的队尾元素 */</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q,QElemType e)</span></span><br><span class="line">&#123; </span><br><span class="line">QueuePtr s=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!s) <span class="comment">/* 存储分配失败 */</span></span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next=s;<span class="comment">/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */</span></span><br><span class="line">Q-&gt;rear=s;<span class="comment">/* 把当前的s设置为队尾结点，rear指向s，见图中② */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h5 id="6-出队-2">(6)出队</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q,QElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p=Q-&gt;front-&gt;next;<span class="comment">/* 将欲删除的队头结点暂存给p，见图中① */</span></span><br><span class="line">*e=p-&gt;data;<span class="comment">/* 将欲删除的队头结点的值赋值给e */</span></span><br><span class="line">Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;rear==p)<span class="comment">/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */</span></span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h3 id="五、栈和队列操作的特点">五、栈和队列操作的特点</h3><table><thead><tr><th></th><th>相同点</th><th>不同点</th></tr></thead><tbody><tr><td>堆栈(FILO)</td><td>只允许在端点处插入和删除元素；</td><td>栈是先进后出或者后进先出；栈是只能在表的一端进行插入和删除操作的线性表</td></tr><tr><td>队列(FIFO)</td><td>只允许在端点处插入和删除元素；</td><td>队列是先进先出；队列是只能在表的一端进行插入，然后在另外一端进行删除操作的线性表</td></tr></tbody></table><h3 id="六、数组存储地址的计算">六、数组存储地址的计算</h3><table><thead><tr><th>数组类型</th><th>存储地址的计算（a是数组首地址，len是每个数组元素所占长度）</th></tr></thead><tbody><tr><td>一维数组</td><td>a[i]的存储地址：a+i*len</td></tr><tr><td>二维数组:a[m] [n]</td><td>按行存储：a+(i * n+j) * len；按列存储：a+(j * m+i) * len</td></tr></tbody></table><blockquote><p><strong>例子</strong>：数组存储地址的计算示例：<br>1）已知一维数组a中每个元素占用2个字节，求a[10]的存储地址？<br>答：a[10]的存储地址为：a+10*2=a+20<br>2）已知二维数组a[4][5]中, 每个元素占用2个字节，求元素a[3][2]按行为主序存储的存储地址和按列为主序存储的存储地址？<br>答： 按行存储：a+(35+2) *2 = a+34<br>按列存储：a+(24+3) *2 = a+22</p></blockquote><h2 id="———————树———————">———————树———————</h2><h3 id="一、二叉树">一、二叉树</h3><h4 id="1、定义">1、定义</h4><blockquote><p>二叉树是每个节点最多有两个子树的树结构。</p><p>它有五种基本形态:</p><ul><li>二叉树可以是空集;</li><li>根可以有空的左子树或右子树；</li><li>或者左、右子树皆为空。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f604bd3.png" alt="在这里插入图片描述"></p><h4 id="2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度">2、结点的度、孩子、双亲、深度、有序树、无序树、树的高度</h4><h5 id="a-结点、叶子、树的度">a.结点、叶子、树的度</h5><blockquote><ul><li><strong>结点的度</strong>：结点拥有的子树的数目。</li><li><strong>叶子</strong>：度为零的结点。</li><li><strong>树的度</strong>：树中结点的最大的度</li></ul></blockquote><h5 id="b-孩子、双亲、兄弟、子孙、祖先">b.孩子、双亲、兄弟、子孙、祖先</h5><blockquote><ul><li><strong>双亲</strong>：若一个结点有子树，该结点称为子树根的&quot;双亲&quot;。</li><li><strong>孩子</strong>：子树的根是该结点的&quot;孩子&quot;。</li><li><strong>兄弟</strong>：有相同双亲的结点互为&quot;兄弟&quot;。</li><li><strong>子孙</strong>：一个结点的所有子树上的任何结点都是该结点的子孙。</li><li><strong>祖先</strong>：从根结点到某个结点的路径上的所有结点都是该结点的祖先。</li></ul></blockquote><h5 id="c-无序树、有序树、森林">c.无序树、有序树、森林</h5><blockquote><ul><li><strong>无序树</strong>：如果树中结点的各子树之间的次序是无次序的，<strong>可以交换位置</strong>。</li><li><strong>有序树</strong>：如果树中结点的各子树之间的次序是有次序的, <strong>不可以交换位置</strong>。</li><li><strong>森林</strong>：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</li></ul></blockquote><h5 id="d-层次、高度">d.层次、高度</h5><blockquote><p><strong>层次</strong>：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br><strong>树的深度和高度</strong>：二叉树中节点的最大层次称为二叉树的深度或高度。</p></blockquote><h4 id="2、性质">2、性质</h4><blockquote><p><strong>性质1</strong>：二叉树第 i 层上最多为 2^(i-1) (i≥1)个结点。</p><p><strong>性质2</strong>：深度为k的二叉树至多有2^k - 1个结点(k≥1)。</p><p><strong>性质3</strong>：具有n个结点的【完全二叉树】的高度k为(log&lt;2&gt;n) +1）（<strong>[log2n]表示不大于与其的整数</strong>）</p><p><strong>性质4</strong>：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。</p><p><strong>性质5</strong>：如果对一棵有 n个结点的完全二叉树（其深度为(log&lt;2&gt;n) +1）的结点按 【层序】编号（从第1层到第(log&lt;2&gt;n) +1） 层，每层从左到右），对任一结点 i （1≤ i ≤ n）有：</p><ul><li>如果 i = 1，则结点 i是二叉树的根，无双亲；如果 i ＞ 1，则其双亲是结点 [i/2];</li><li>如果2i ＞n，则结点 i 无左孩子（即结点 i 为叶子结点）；否则其左孩子是结点 2i；</li><li>如果 2i+1 ＞n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。</li></ul></blockquote><h4 id="3、满二叉树、完全二叉树和二叉排序树">3、满二叉树、完全二叉树和二叉排序树</h4><h5 id="a-满二叉树">a.满二叉树</h5><blockquote><p><strong>定义</strong>：高度为h，并且由2{h} –1个结点的二叉树，被称为满二叉树。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f6ddd79.png" alt="img"></p><h5 id="b-完全二叉树">b.完全二叉树</h5><blockquote><p><strong>定义</strong>：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。</p><p><strong>特点</strong>：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f80cde1.png" alt="img"></p><h5 id="c-二叉查找树">c.二叉查找树</h5><blockquote><p><strong>定义</strong>：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。左小右大，任意结点的左、右子树也是二叉查找树</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f8bd638.png" alt="img"></p><blockquote><p>在二叉查找树中：<br>(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>(03) 任意节点的左、右子树也分别为二叉查找树。<br>(04) 没有键值相等的节点（no duplicate nodes）。</p></blockquote><h3 id="二、静态查找">二、静态查找</h3><h4 id="1、顺序存储结构">1、顺序存储结构</h4><blockquote><p>指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标i－1的分量中。</p></blockquote><h4 id="2、顺序查找">2、顺序查找</h4><blockquote><p>从表的一端开始，逐个将记录的关键字和给定值比较，若找到一个记录的关键字与给定值相等，则查找成功；若整个表中记录均比较过，仍未找到关键字等于给定值的记录，则查找失败。</p></blockquote><p><strong>缺点</strong>：查找表的长度越长，查找效率越低。</p><p><strong>优点</strong>：简单、适应面广，对查找表结构没有要求，对顺序存储和链式存储都适用。</p><h4 id="3、二分查找（也称“折半查找”，是一棵“二叉排序树”）">3、二分查找（也称“折半查找”，是一棵“二叉排序树”）</h4><blockquote><p>设查找表元素存储在一维数组r[1,…,n]中，在表中的元素已经<strong>按关键字递增方式排序的</strong>情况下，</p><p>进行[折半查找]的方法是：首先将待查元素的关键字（key）值与表r中间位置上（下标为mid）记录的关键字关键字进行比较，</p><ul><li>若相等，则查找成功；</li><li>若key&gt;r[mid].key,则说明待查记录只可能在后半个子表r[mid+1,…,n]中；</li><li>若key&lt;r[mid].key，则说明待查记录只可能在前半个子表r[1,…,mid-1]中；</li></ul><p>这样逐步缩小范围，直到<strong>查找成功</strong>或<strong>子表为空时失败</strong>为止。</p></blockquote><p><strong>注意：每次缩小范围后，改变的下标是哪个</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递增的方式排序，则折半查找的算法为</span></span><br><span class="line"><span class="comment">//在数组r[low...high],在数组r中找值为key的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bsearch</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key == r[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; r[mid])</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//折半查找，递归算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bsearch_rec</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(key == r[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; r[mid])</span><br><span class="line">            <span class="keyword">return</span> Bsearch_rec(r,low,mid<span class="number">-1</span>,key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Bsearch_rec(r,mid+<span class="number">1</span>,high,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3f97218f.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VgJbPWx2-1641217649130)(myReviewPicture/带有11个结点的二分查找判定书.png)]"></p><p>折半查找的过程可以用一颗二叉树来描述，以当前查找区域间的中间位置序号作为根，左半个子表和右半个子表中的记录序号分别分别作为根的左子树和右子树上的结点，这样构造的二叉树称为折半查找判定树，从树上可以看出：</p><p>查找成功时，折半查找的过程恰好走了一条从根结点到被查找结点的路径，与关键字进行比较的次数即为被查找结点在树中的层数。因此，折半查找判定树在查找成功时进行比较的关键字个数最多不超过树的深度，而具有n个结点的判定树的深度为；所以折半查找在查找成功时和给定值进行比较的关键字个数最多为。</p><p><strong>优点</strong>：查找效率更高，但它要求查找表进行顺序存储并按关键字进行排序。<br><strong>缺点</strong>：对表进行插入或删除时，需要移动大量元素。<br><strong>适用</strong>：表不易变动，且又经常进行查找的情况</p><h4 id="4、二分查找判定树ASL计算">4、二分查找判定树ASL计算</h4><blockquote><p><strong>折半查找的过程看，可用二叉树来描述，二叉树中的每个结点对应有序表中的一个记录，结点中的值为该记录在表中的位置。通常称这个描述折半查找二叉树的过程称为折半查找判定树。</strong></p></blockquote><p><strong>例如：顺序存储的序列{1,2,3,4,5,6,7,8,9,10} 来构建二叉判定树，计算其ASL</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fa00a68.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-giB8nBKX-1641217649131)(myReviewPicture/二分查找判定书ASL成功-16411799392662.png)]"><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3faf1191.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rHJdmL7J-1641217649131)(myReviewPicture/二分查找判定书ASL不成功-16411799619963.png)]"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例如：长度为<span class="number">10</span>的折半查找判定树的具体生成过程：</span><br><span class="line">都遵循这个规律，左孩子结点&lt;根结点&lt;右孩子结点 【左小右大】</span><br><span class="line"></span><br><span class="line">    （<span class="number">1</span>）在长度为<span class="number">10</span>的有序表中进行折半查找，不论查找哪个记录，都必须和中间记录进行比较，而中间记录为</span><br><span class="line">（<span class="number">1</span>+<span class="number">10</span>）/<span class="number">2</span> =<span class="number">5</span>  (注意要取整)   即判定数的的根结点为<span class="number">5</span>，如图<span class="number">7</span><span class="number">-2</span>（a）所示。</span><br><span class="line"></span><br><span class="line">     （<span class="number">2</span>）考虑判定树的左子树，即将查找区域调整到左半区，此时的查找区间为[<span class="number">1</span>,<span class="number">4</span>],那么中间值为（<span class="number">1</span>+<span class="number">4</span>）/<span class="number">2</span> =<span class="number">2</span> (注意要取整) ，所以做孩子根结点为<span class="number">2</span>,如图<span class="number">7</span><span class="number">-2</span>（b）所示。</span><br><span class="line"></span><br><span class="line">     （<span class="number">3</span>）考虑判定树的右子树，即将查找区域调整到右半区，此时的查找区间为[<span class="number">6</span>,<span class="number">10</span>],那么中间值为（<span class="number">6</span>+<span class="number">10</span>）/<span class="number">2</span> =<span class="number">8</span> (注意要取整) ，所以做孩子根结点为<span class="number">8</span>,如图<span class="number">7</span><span class="number">-2</span>（c）所示。</span><br><span class="line"></span><br><span class="line">       (<span class="number">4</span>)重复以上步骤，依次去确定左右孩子、</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><blockquote><p>1.折半查找是一棵<strong>二叉排序树</strong>，每个根结点的值都大于左子树的所有结点的值，小于右子树所有结点的值。</p><p>2.折半查找判定数中的结点都是查找成功的情况，将每个结点的空指针指向一个实际上不存在的结点————<strong>外结点</strong>，所有外界点都是查找不成功的情况，如图7-2（e）所示。<strong>如果有序表的长度为n,则外结点一定有n+1个。</strong></p></blockquote><h5 id="（1）查找成功的ASL">（1）查找成功的ASL</h5><blockquote><p><strong>折半查找判定数中，某结点所在的层数就是即将要比较的次数，整个判定树代表的有序表的平均查找长度即为查找每个结点的比较次数之和除以有序表的 长度。</strong></p></blockquote><p><strong>ASL成功 = 每层结点所在高度×每层结点数 之和 除以 总结点数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 例如：长度为<span class="number">10</span>的有序表的平均查找长度为</span><br><span class="line"></span><br><span class="line">ASL=(<span class="number">1</span>×<span class="number">1</span>+<span class="number">2</span>×<span class="number">2</span>+<span class="number">3</span>×<span class="number">4</span>+<span class="number">4</span>×<span class="number">3</span>)/<span class="number">10</span>=<span class="number">29</span>/<span class="number">10</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h5 id="（2）查找不成功的ASL">（2）查找不成功的ASL</h5><blockquote><p><strong>折半查找判定数中，查找不成功的次数即为查找相应外结点(定义在上方）与内结点的比较次数。整个判定树代表的有序表的平均查找长度。查找失败时的有序表的平均查找长度即为查找每个外结点的比较次数之和除以外结点的个数。</strong></p></blockquote><p><strong>ASL失败 = （每层【补上的】结点所在高度-1）×每层【补上的】结点数 之和 除以 【补上的】总结点数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：查找失败时，长度为<span class="number">10</span>的有序表的平均查找长度为：</span><br><span class="line"></span><br><span class="line">ASL=(<span class="number">3</span>×<span class="number">5</span>+<span class="number">4</span>×<span class="number">6</span>)/<span class="number">11</span>=<span class="number">39</span>/<span class="number">11</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="三、动态查找">三、动态查找</h3><h4 id="1、二叉树链表结构描述如下：">1、二叉树链表结构描述如下：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree; <span class="comment">/* 二叉树类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">/*树结点定义 */</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 结点数据*/</span></span><br><span class="line">    BinTree Left; <span class="comment">/*指向左子树*/</span></span><br><span class="line">    BinTree Right;<span class="comment">/*指向右子树*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p><strong>二叉链表至少包含3个域：数据域 data、左指针域 lchild和右指针域 rchild</strong></p><p><strong>指针域</strong>： n个结点有2n个指针域。</p><p><strong>空指针域</strong>：n 个结点的二叉链表中含有 n+1 个空指针域。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fb17daa.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PqXCTOH8-1641217649132)(myReviewPicture/二叉树的链式存储结构.png)]"><br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fbb6b3f.png" alt="img"></p><h4 id="2、二叉搜索（排序、查找）树的构造过程">2、二叉搜索（排序、查找）树的构造过程</h4><h5 id="1-构造过程">(1)构造过程</h5><blockquote><p>构造二叉排序树的过程，就是从空二叉树开始，逐个向树中插入节点的过程。</p><p>设记录的关键码序列为：63,90,70,55,67,42,98,83,10,45,58</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fb8e575.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HIN82LwY-1641218126672)(myReviewPicture/二叉搜索树的排序.png)]"></p><h5 id="2-插入过程算法及其代码">(2)插入过程算法及其代码</h5><blockquote><p>设待插入节点关键码值为 X ：</p><p>（1）先在树中查找值为 X 的节点，若查找成功，说明节点已存在，无需插入；</p><p>（2）若查找失败，说明节点不存在，则将其插入到树中</p><p>因此，<strong>新插入节点一定是作为叶子节点插入的。</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Insert</span><span class="params">(Bintree BST, ElmentType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)</span><br><span class="line">    &#123;<span class="comment">/*若原来树为空，生成并返回一个结点的二叉搜索树*/</span></span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">/*开始查找插入元素的位置*/</span></span><br><span class="line">        <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Insert(BST-&gt;Left, X);<span class="comment">/*递归插入左子树*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Insert(BST-&gt;Right, X);<span class="comment">/*递归插入右子树*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><h5 id="2-删除过程算法及其代码">(2)删除过程算法及其代码</h5><blockquote><p>二叉搜索树的删除操作比其它操作更为复杂，要删除结点在<strong>树中的位置</strong>决定了操作所采用的<strong>策略</strong>。</p></blockquote><p>a.若要删除的结点是<strong>叶子结点</strong></p><p>可以直接删除，然后再修改其父结点的指针。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fc03da7.png" alt="在这里插入图片描述"></p><p>b.若要删除的结点<strong>只有一个孩子结点</strong>（该结点不一定是叶结点，可以是子树的根）</p><p>删除之前需要改变父结点的指针，指向要删除结点的孩子结点。<br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fc7c15f.png" alt="在这里插入图片描述"></p><p>c.若要删除的结点有左、右两棵子树，有两种选择：</p><p><strong>基本原则：保持二叉搜索树的有序性</strong></p><p>1、取其右子树中的最小元素；</p><p>2、取其左子树中的最大元素。</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fc95c9e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Wzu1zptj-1641217649133)(myReviewPicture/具有两个子树的结点删除.png)]"></p><h5 id="3-查找过程算法及其代码">(3)查找过程算法及其代码</h5><blockquote><p>BST树的查找思想:</p><p>首先将<strong>给定的K值</strong>与二叉排序树的<strong>根节点</strong>的关键字进行比较：</p><ul><li>若<strong>相等</strong>，则<strong>查找成功</strong>；</li><li>若给定的K值<strong>小于</strong>BST树的根节点的关键字：继续在该节点的<strong>左子树上进行查找</strong>；</li><li>若给定的K值大于BST树的根节点的关键字：继续在该节点的<strong>右子树上进行查找</strong>。</li></ul></blockquote><h6 id="a-二叉搜索树的递归查找函数">a.二叉搜索树的递归查找函数</h6><blockquote><p>在二叉排序树上进行查找，则是从<strong>根结点</strong>出发走了一条从根到待查结点的路径；</p><p>若查找不成功，则是从根结点出发走了一条从跟到某一叶结点的路径。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">Find</span><span class="params">(BinTree BST,ElementType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* 查找失败 */</span></span><br><span class="line">    <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(BST-&gt;Right, X);<span class="comment">/* 在 右子树 中递归查找 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(BST-&gt;Left, X);<span class="comment">/* 在 左子树 中递归查找 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;<span class="comment">/* 在当前结点查找成功，返回当前结点的地址*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><h6 id="b-迭代查找算法">b.迭代查找算法</h6><blockquote><p>由于非递归函数的执行效率高，一般采用非递归的迭代来实现查找。很容易将递归函数改为迭代函数</p><p>while循环 代替 Find递归调用即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">Find</span><span class="params">(BinTree BST,ElementType X)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Right;<span class="comment">/* 向 右子树 中移动，继续查找 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Left; <span class="comment">/* 向 右子树 中移动，继续查找 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data;*/</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">/* 在当前结点查找成功，跳出循环 */</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> BST;<span class="comment">/* 返回找到的结点地址，或是NULL */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><h5 id="4-查找最大值和最小值">(4)查找最大值和最小值</h5><blockquote><p>根据二叉搜索树的性质，<strong>最小元素</strong>一定是在树的<strong>最左分支的端点上</strong>。最左分支的端点：最左分支上无左孩子的结点。</p><p><strong>最大元素</strong>一定在<strong>最右分支的端结点上。</strong></p><ul><li>从根结点开始，当其不为空时，沿左分支或者右分支逐个判断各结点的指针，直到遇到空指针为止。</li><li>当左分支逐层推下来查找到的是最小元素。</li><li>反之，当右分支逐层推下来查找到的是最大元素。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fca30a0.png" alt="img"></p><h6 id="a-最小元素的递归函数">a.最小元素的递归函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">FindMin</span><span class="params">(BinTree BST)</span></span><br><span class="line">&#123; <span class="comment">/* 最小元素在最左端点 */</span></span><br><span class="line">    <span class="keyword">if</span>(!BST)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* 空的二叉搜素树，返回NULL */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">        <span class="keyword">return</span> BST;<span class="comment">/* 找到最左端点并返回 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin(BST-&gt;Left); <span class="comment">/*沿左分支递归查找 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h6 id="b-查找最大元素的迭代函数">b.查找最大元素的迭代函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">FindMax</span><span class="params">(BinTree BST)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)</span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right);</span><br><span class="line">    BST = BST-&gt;Right; <span class="comment">/*沿右分支一直向下，直到最右端点 */</span></span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h3 id="四、二叉树的遍历">四、二叉树的遍历</h3><blockquote><p>指按照某种次序访问二叉树的所有结点，并且每个结点仅访问一次，得到一个线性序列。</p></blockquote><h4 id="1、先序遍历">1、先序遍历</h4><blockquote><p>（1）访问根结点<br>（2）先序遍历左子树<br>（3）先序遍历右子树</p><p>-中序、后序遍历相似</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fcd7ec4.png" alt="img"></p><blockquote><p>先序遍历：A → B → D → C<br>中序遍历：B → D → A → C<br>后续遍历：D → B → C → A<br>层序遍历：A → B → C → D</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span>    <span class="comment">//链式二叉树先序遍历递归算法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf_s(<span class="string">&quot;%d &quot;</span>, T-&gt;data);    <span class="comment">//访问根结点</span></span><br><span class="line">PreOrderTraverse(T-&gt;lchild);    <span class="comment">//先序遍历左子树</span></span><br><span class="line">PreOrderTraverse(T-&gt;rchild);    <span class="comment">//先序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式二叉树中序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">InOrderTraverse(T-&gt;lchild);</span><br><span class="line">printf_s(<span class="string">&quot;%d &quot;</span>, T-&gt;data);</span><br><span class="line">InOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式二叉树后序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">printf_s(<span class="string">&quot;%d &quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure><h4 id="2、层序遍历-队列实现）">2、层序遍历(队列实现）</h4><blockquote><p>仔细看看层序遍历过程，其实就是从上到下，从左到右依次将每个数放入到队列中，然后按顺序依次打印就是想要的结果。</p></blockquote><blockquote><p>实现过程</p><ul><li>从队列中取出一个元素；</li><li>访问该元素所指结点；</li><li>若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。</li></ul><p>不断执行这三步操作，直到队列为空，再无元素可取，二叉树的程序遍历就完成了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelorDerTraversal</span><span class="params">(BinTree BT)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    BinTree T;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!BT)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">/* 若是空树则直接返回 */</span></span><br><span class="line">    </span><br><span class="line">    Q = CreatQueue();<span class="comment">/* 创建空队列 */</span></span><br><span class="line">    AddQ(Q, BT);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        T = DeteleQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,T-&gt;Data); <span class="comment">/* 访问取出队列的结点 */</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left)</span><br><span class="line">            AddQ(Q, T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right)</span><br><span class="line">            AddQ(Q, T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure><h5 id="3、由遍历序列还原二叉树">3、由遍历序列还原二叉树</h5><blockquote><p>已知<strong>先</strong>序遍历和<strong>中</strong>序遍历，<strong>可以还原</strong>二叉树；<br>已知<strong>中</strong>序遍历和<strong>后</strong>序遍历，<strong>可以还原</strong>二叉树；<br>已知<strong>先序遍历和后序遍历，不可以</strong>还原二叉树.</p></blockquote><p>a.已知先序遍历和中序遍历还原二叉树</p><blockquote><p>算法思路：<br>1、根据先序遍历结果确定根节点。先序遍历的第一个节点为根节点。<br>2、 在中序遍历结果中找到根节点，根节点左侧的部分为左子树节点，根节点右侧的部分为右子树节点。<br>3、 将中序遍历的结果按根节点分为两部分，迭代的执行第一步和第二步，直到还原整个二叉树。</p></blockquote><p>例如：已知先序遍历的结果为：ABDHIEJKCFLMGNO,中序遍历的结果为：HDIBJEKALFMCNGO</p><p>则二叉树为以下结构：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fd8636e.png" alt="img"></p><p>其后序遍历结果为：HIDJKEBLMFNOGCA</p><h6 id="b-已知后序遍历和中序遍历还原二叉树">b.已知后序遍历和中序遍历还原二叉树</h6><blockquote><p><strong>算法思路</strong>：<br>1、根据后序遍历结果确定根节点。<br>后序遍历的最后一个节点为根节点。<br>2、在中序遍历结果中找到根节点，根节点左侧的部分为左子树节点，根节点右侧的部分为右子树节点。<br>3、将中序遍历的结果按根节点分为两部分，迭代的执行第一步和第二步，直到还原整个二叉树。</p></blockquote><p>例如：已知后序遍历的结果为：HIDJKEBLMFNOGCA,中序遍历的结果为：HDIBJEKALFMCNGO</p><p>则二叉树为以下结构：</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fd86d86.png" alt="img"></p><p>其先序遍历结果为：ABDHIEJKCFLMGNO</p><h3 id="五、递归遍历算法的应用">五、递归遍历算法的应用</h3><h5 id="1、求二叉树的深度">1、求二叉树的深度</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeDeep</span><span class="params">(BiTree T)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> deep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> leftDeep = TreeDeep(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> rightDeep = TreeDeep(T-&gt;rchild);</span><br><span class="line">        deep = leftDeep &gt;= rightDeep ? leftDeep + <span class="number">1</span> : rightDeep + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><h5 id="2、求二叉树的叶子树">2、求二叉树的叶子树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求叶子树</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LeafCount</span><span class="params">(BinTree T,<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!T-&gt;Left &amp;&amp; !T-&gt;Right)</span><br><span class="line">        &#123;</span><br><span class="line">            nm++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeDeep(T-&gt;lchild, num);</span><br><span class="line">        TreeDeep(T-&gt;rchild, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><h5 id="3、交互（换）左、右子树">3、交互（换）左、右子树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(BiTree *&amp;right,BiTree *&amp;left)</span></span><br><span class="line">&#123;</span><br><span class="line">BiTree *temp=right;</span><br><span class="line">right=left;</span><br><span class="line">left=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SwapSubtrees</span><span class="params">(BiTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">SwapSubtrees(T-&gt;rchild);</span><br><span class="line">SwapSubtrees(T-&gt;lchild);</span><br><span class="line">Swap(T-&gt;rchild,T-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><h3 id="六、静态查找和动态查找的根本区别">六、静态查找和动态查找的根本区别</h3><ul><li>上述基于二叉排序树的动态查找，它的基本原理和基于线性表的静态二分查找很相似，都是利用有序性不断缩小查找空间。</li><li>而之所以有静态和动态之分，主要是为了适应不同的应用需求。</li></ul><table><thead><tr><th></th><th>适合用于</th></tr></thead><tbody><tr><td>静态查找</td><td>数据一旦建立好，不需要或者很少进行 删除 和 插入 操作</td></tr><tr><td>动态查找</td><td>频繁的数据变化，插入 和 删除 是基本操作</td></tr></tbody></table><h3 id="七、树-森林与二叉树的转换">七、树/森林与二叉树的转换</h3><h4 id="1、树、森林与二叉树的转换">1、树、森林与二叉树的转换</h4><p>由于二叉树是有序的，为了避免混淆，对于无序树，我们约定树中的每个结点的孩子结点按从左到右的顺序进行编号。</p><blockquote><p>将树转换成二叉树的步骤是：<br>（1）加线。就是在<strong>所有兄弟结点</strong>之间加一条连线；<br>（2）抹线。就是对<strong>树中的每个结点</strong>，只<strong>保留</strong>他与<strong>第一个孩子结点</strong>之间的连线，<strong>删除</strong>它与<strong>其它孩子</strong>结点之间的连线；<br>（3）旋转。就是<strong>以树的根结点为轴心</strong>，将整棵树顺时针旋转一定角度，使之结构层次分明。<br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe6e3a9.png" alt="img"></p></blockquote><h4 id="2、森林转换为二叉树">2、森林转换为二叉树</h4><p>森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。</p><blockquote><p>将森林转换为二叉树的步骤是：<br>（1）<strong>先把每棵树转换为二叉树</strong>；<br>（2）第一棵二叉树<strong>不动</strong>，从第二棵二叉树<strong>开始</strong>，依次把<strong>后一棵</strong>二叉树的根结点作为<strong>前一棵</strong>二叉树的<strong>根结点的右孩子结点</strong>，<strong>用线连接起来</strong>。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe7ed50.png" alt="img"></p><h4 id="3、二叉树转换为树">3、二叉树转换为树</h4><blockquote><p><strong>二叉树转换为树</strong>是<strong>树转换为二叉树</strong>的<strong>逆过程</strong>，其步骤是：<br>（1）若<strong>某结点</strong>的<strong>左孩子结点存在</strong>，将<strong>左孩子结点的右孩子结点、右孩子结点的右孩子结点</strong>……都作为<strong>该结点</strong>的孩子结点，将该结点与这些<strong>右孩子结点用线连接</strong>起来；<br>（2）<strong>删除原二叉树</strong>中所有结点与其右孩子结点的连线；<br>（3）整理（1）和（2）两步得到的树，使之结构层次分明。<br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe9c5ca.png" alt="img"></p></blockquote><h4 id="4、二叉树转换为森林">4、二叉树转换为森林</h4><blockquote><p>二叉树转换为森林比较简单，其步骤如下：<br>（1）先把每个结点与右孩子结点的连线删除，得到分离的二叉树；<br>（2）把分离后的每棵二叉树转换为树；<br>（3）整理第（2）步得到的树，使之规范，这样得到森林。</p></blockquote><h4 id="5、转换以后的特点：">5、转换以后的特点：</h4><p>(1、 根据树与二叉树的转换关系以及二叉树的遍历定义可以推知：</p><ul><li>树的先序遍历与其转换的相应的二叉树的先序遍历的结果序列相同；</li><li>树的后序遍历与其转换的二叉树的中序遍历的结果序列相同；</li><li>树的层序遍历与其转换的二叉树的后序遍历的结果序列相同。</li></ul><p>（2、 由森林与二叉树的转换关系以及森林与二叉树的遍历定义可知：</p><p>森林的先序遍历和中序遍历与所转换得到的二叉树的先序遍历和中序遍历的结果序列相同。</p><h3 id="八、线索二叉树">八、线索二叉树</h3><blockquote><p>传统的二叉链表仅能体现出一种父子关系，不能直接得到结点在遍历中的前驱或后继。引入【线索二叉树】正是为了<strong>加快查找结点前驱和后继的速度。</strong><br><strong>（1、定义</strong>：</p><ul><li><strong>前驱与后继</strong>：在二叉树的<code>先序、中序或后序遍历序列</code>中的两个<code>相邻的结点</code>；</li><li><strong>线索</strong>：指向前驱或后继的<code>结点的指针</code>；</li><li><strong>线索二叉树</strong>：<code>加上线索</code>的<code>二叉链表</code>的<code>二叉树</code>；</li><li><strong>线索化</strong>：对二叉树按<code>某个遍历次序</code>使其<code>变为线索二叉树</code>的过程。</li></ul><p><strong>（2、规定</strong>：<strong>【口诀：左前右后，0孩1前后】</strong></p><ul><li>若<code>无左子树</code>，令<code>lchild</code>指向其<code>前驱</code>结点；</li><li>若<code>无右子树</code>，令<code>rchild</code>执行指向其<code>后继</code>结点</li><li>增加<code>两个标志域标</code>识是指<code>左/右孩子</code>还是指向<code>前驱/后继</code>。</li></ul></blockquote><h4 id="1、存储结构">1、存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line"><span class="type">int</span> ltag, rtag;<span class="comment">// 左右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fea5ad1.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fXyUjz8c-1641217649133)(myReviewPicture/线索二叉树的结构.png)]"></p><h4 id="2、如何判断是孩子还是线索">2、如何判断是孩子还是线索</h4><p><strong>其标志位含义如下：</strong> <strong>【口诀：左前右后，0孩1前后】</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fe9e318.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gl66MqHn-1641217649134)(myReviewPicture/线索二叉树的标识符含义.png)]"></p><ul><li>这种加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。</li><li>根据线索性质的不同， 线索二叉树可分为<strong>前序线索二叉树、 中序线索二叉树和后序线索二叉树</strong>三种。</li></ul><h4 id="3、三种遍历">3、三种遍历</h4><blockquote><p>因为线索化后， 各个结点指向有变化， 因此原来的遍历方式不能使用， 需要使用新的方式遍历线索化二叉树。</p><p>中序线索二叉树的结点中<strong>隐含</strong>了线索二叉树的<strong>前驱和后继信息</strong>。</p><p>在对其遍历时，需要找到第一个具有前驱结点的左结点，然后依次找结点的后继。</p><p>在中序线索二叉树中找结点后继的规律是:</p><ul><li>若其<strong>右标志为1</strong>，则<strong>右链为线索</strong>，指示其<strong>后继</strong>;</li><li>否则遍历<strong>右子树中第一个访问</strong>的结点（右子树中最左下的结点）为其后继。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiThrTree T)</span>&#123; <span class="comment">// 中序输出</span></span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; T-&gt;data;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h3 id="九、哈夫曼树">九、哈夫曼树</h3><h4 id="1、带权路径长度WPL">1、带权路径长度WPL</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3fee2941.png" alt="img"></p><h4 id="2、哈夫曼树的构造（算法）">2、哈夫曼树的构造（算法）</h4><blockquote><p>构造 Huffman 树的基本思想：权值大的结点用短路径，权值小的结点用长路径。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3ffe9b85.png" alt="img"></p><blockquote><p>构造过程</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b3ffe9963.png" alt="在这里插入图片描述"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4000e0f6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S9xCYfbA-1641217649135)(myReviewPicture/huffmantree2.png)]"></p><h4 id="3、哈夫曼树的性质">3、哈夫曼树的性质</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b400ae7d3.png" alt="img"></p><h4 id="4、哈夫曼编码">4、哈夫曼编码</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b400d4c84.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b400f253d.png" alt="img"></p><h2 id="———散列查找———">———散列查找———</h2><h3 id="一、散列查找">一、散列查找</h3><h4 id="1、基本概念-2">1、基本概念</h4><ul><li><strong>散列函数</strong></li></ul><p>在进行查找时，在记录的存储位置与它的关键字之间建立一个确定的对应关系h,以线性表中每个元素的关键字K为自变量，通过函数h(K)计算出该元素的存储位置，我们将h函数称为散列函数或哈希函数。h(K)的值称为散列地址或哈希地址。</p><ul><li><strong>冲突</strong></li></ul><p>在实际应用中，通常可能出现一个待插入元素的散列地址单元已被占用情况，使得该元素无法直接存入此单元，这种情况称为冲突。</p><ul><li><p><strong>同义词</strong></p><p>具有不同关键字而具有相同散列地址的元素称为同义词，即key1≠key2，但h(key1)=h(key2)。由同义词引起的冲突称作同义词冲突。</p></li><li><p><strong>装填因子(α)</strong></p><p>指散列表中已存入的元素数n与散列表空间大小m的比值,即：α=n/m。当α越小时，冲突可能性就越小，但同时，存储空间利用率就越低。</p></li></ul><p>散列表：根据设定的哈希函数及处理冲突的方法将一组关键字映象到一个有限的连续的地址集上，即把记录存放在表中映象的位置上，这种表便称为散列表(哈希表)。</p><ul><li>一个散列表的好坏与三个因素有关：1.装填因子 2、所采用的散列函数 3、解决冲突的方法</li></ul><blockquote><p>假定一个线性表为A=(18,75,60,43,54,90,46)，选取散列函数为：h(K)=K%m 取m=13<br>则得每个元素散列地址：<br>h(18)=18 % 13=5<br>h(75)=75 % 13=10<br>h(60)=60 % 13=8<br>h(43)=43 % 13=4<br>h(54)=54 % 13=2<br>h(90)=90 % 13=12<br>h(46)=46 % 13=7<br>根据散列地址，实现元素的存储映象H[m]：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th></th></tr></thead><tbody><tr><td>H</td><td></td><td></td><td>54</td><td></td><td>43</td><td>18</td><td></td><td>46</td><td>60</td><td></td><td>75</td><td></td><td>90</td></tr></tbody></table></blockquote><blockquote><p>例：如向下表中再插入元素70时，70%13=5，则出现了冲突</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td>H</td><td></td><td></td><td>54</td><td></td><td>43</td><td>18</td><td></td><td>46</td><td>60</td><td></td><td>75</td><td></td><td>90</td></tr></tbody></table></blockquote><h4 id="2、散列函数">2、散列函数</h4><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OtlYI1uv-1641217649135)(myReviewPicture/散列函数.png)]</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 构造散列函数的目标是使散列地址尽可能均匀分布在散列空间上，同时使计算尽可能简单，以节省计算时间。</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h5 id="（1、关键词为数字时：">（1、关键词为数字时：</h5><h6 id="a-直接定址法">a.直接定址法</h6><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a426e7c26d23a12abae842ecc2e1ace.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VlxRhB6x-1641217649136)(myReviewPicture/直接定址法.png)]"></p><h6 id="b-除留余数法-常用">b.除留余数法(常用)</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b401eef26.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fZm4ezqe-1641217649136)(myReviewPicture/除留余数法.png)]"></p><h6 id="c-数字分析法">c.数字分析法</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址，如电话号码、身份证号码某几位会比较随机；</span><br><span class="line">1</span><br></pre></td></tr></table></figure><blockquote><p>**例：**有一组关键字如下：</p><p>92326875</p><p>92739628</p><p>92343634</p><p>92706816</p><p>92774638</p><p>92381262</p><p>92394220</p><p>通过分析：每个关键字从左到右第1、2、3位和第6位取值较集中，不宜作散列地址，其余的第4、5、7、8位取值分散，可以选择，若取最后两位作散列地址，得：<strong>(2,75,28,34,16,38,62,20)</strong></p></blockquote><h6 id="d-平方取中法">d.平方取中法</h6><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">key</span>取平方再取中间几位</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="（2、关键词为字符时：">（2、关键词为字符时：</h5><h6 id="a、ASCII码加和法">a、ASCII码加和法</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">h</span><span class="params">(key)</span></span>=(求和key<span class="selector-attr">[i]</span>)mod TableSize</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h6 id="b、前3个字符移位法">b、前3个字符移位法</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">h</span>(key)=(key[<span class="number">0</span>]*<span class="number">27</span>*<span class="number">27</span>+key[<span class="number">1</span>]*<span class="number">27</span>+key[<span class="number">2</span>])mod TableSize</span><br><span class="line"><span class="attribute">1</span></span><br></pre></td></tr></table></figure><h3 id="二、处理冲突的方法">二、处理冲突的方法</h3><h4 id="1、开放定址法">1、开放定址法</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4022f739.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-w3vCRkqI-1641217649137)(assets/开放定址法2.png)]"></p><h6 id="a-线性探测法">a.线性探测法</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b402672fe.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CKgRc9iU-1641217649138)(myReviewPicture/线性探测法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b402c6fc3.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dRJEytI9-1641217649139)(myReviewPicture/开放定址法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b402edf95.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-s9TU3kVj-1641217649139)(myReviewPicture/ASL.png)]"></p><p><strong>注意</strong>：查找某个值时，用散列函数计算完后，如果那个结果位置上的数字与关键词不一样时，并不能断定关键词不存在，还应该按照冲突解决策略继续找，直到找到空位置了还没找到，才能断定该关键词不存在。</p><h6 id="b、平方探测（二次探测）">b、平方探测（二次探测）</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b40381e62.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tK3J9VUv-1641217649140)(myReviewPicture/平方探测法5.png)]"></p><blockquote><p>举例：h(key)=key mod 11;</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4039a89b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jyTvTfbw-1641217649140)(myReviewPicture/平方探测法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b403ddb6c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XTqZBJVG-1641217649140)(myReviewPicture/平方探测法2.png)]"></p><p>**注意：**取素数是为了减少公因子（减少冲突）</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4049a4b5.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RL4wdkRn-1641217649142)(myReviewPicture/散列表的装填因子.png)]"></p><h6 id="c-在散列法">c.在散列法</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4047fb3b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sXqpjUkM-1641217649142)(myReviewPicture/再散列法.png)]"></p><h4 id="2、分离链接法">2、分离链接法</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b404ef82b.png" alt="在这里插入图片描述"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b405908a6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QpGllGXr-1641217649142)(myReviewPicture/链地址法.png)]"></p><h2 id="———————————————图————————————————">———————————————图————————————————</h2><h3 id="一、图的基本概念">一、图的基本概念</h3><blockquote><p><strong>集合只有同属于一个集合；线性结构存在一对一的关系；树形结构存在一对多的关系；图状结构存在多对多的关系</strong>。</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b4059a033.png" alt="img"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50ea5e8c.png" alt="img"></p><h4 id="1、简单图">1、简单图</h4><blockquote><p>简单图满足以下两条内容：</p><p><strong>1）不存在重复边</strong></p><p><strong>2）不存在顶点到自身的边</strong></p></blockquote><h4 id="2、完全图">2、完全图</h4><blockquote><p>任意两顶点之间都存在边</p></blockquote><h4 id="3、连通分量">3、连通分量</h4><blockquote><p>在无向图中，两顶点有路径存在，就称为连通的。若图中任意两顶点都连通，同此图为连通图。无向图中的极大连通子图称为连通分量。</p></blockquote><h4 id="4、强连通分量">4、强连通分量</h4><blockquote><p>在有向图中，两顶点两个方向都有路径，两顶点称为<strong>强连通</strong>。</p><p>若任一顶点都是强连通的，称为强连通图。有向图中极大强连通子图为有向图的强连通分量。</p></blockquote><h4 id="5-顶点的度、入度和出度">5.顶点的度、入度和出度</h4><blockquote><p><strong>顶点的度</strong>为以该顶点为一个端点的<strong>边的数目</strong>。</p><p>对于<strong>无向图</strong>，顶点的边数为度，<strong>度数之和是顶点边数的 2 倍</strong>。</p><p>对于<strong>有向图</strong>，入度是以顶点为终点，出度相反。有向图的<strong>全部顶点入度之和等于出度之和且等于边数</strong>。<strong>顶点的度等于入度与出度之和</strong></p></blockquote><p><strong>注意</strong>：入度与出度是针对有向图来说的</p><h3 id="二、图的存储">二、图的存储</h3><h4 id="1、数组（邻接矩阵）表示法">1、数组（邻接矩阵）表示法</h4><ul><li><p>建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间关系）。</p></li><li><p>设图A=（V，E）有n个顶点，则</p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50e89c5e.png" alt="åœ¨è¿™é‡Œæ’å ¥å›¾ç‰‡æè¿°"></p></li><li><p>图的邻接矩阵是一个二位数组A.arcs[n] [n]，定义为：</p></li></ul><p>åœ¨è¿™é‡Œæ’å<br>¥å›¾ç‰‡æè¿°</p><h5 id="a-无向图的邻接矩阵表示法">a.无向图的邻接矩阵表示法</h5><blockquote><p>分析1：<strong>无向图</strong>的邻接矩阵是<strong>对称</strong>的；<br>分析2：顶点i的度=第i行（列）中1的个数；<br><strong>特别：完全图的邻接矩阵中，对角元素为0，其余1。</strong></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50e9cb15.png" alt="åœ¨è¿™é‡Œæ’å ¥å›¾ç‰‡æè¿°"></p><h5 id="b-有向图的邻接矩阵表示法">b.有向图的邻接矩阵表示法</h5><blockquote><p>注：在有向图的邻接矩阵中，<br>第 i <strong>行</strong>含义：以结点vi为尾的弧（即<strong>出度边</strong>）<br>第 i <strong>列</strong>含义：以结点vi为头的弧（即<strong>入度边</strong>）<br>分析1：有向图的邻接矩阵<strong>可能是不对称</strong>的；<br>分析2：<strong>顶点的出度 = 第 i 行元素之和</strong><br><strong>顶点的入度 = 第 i 列元素之和</strong><br><strong>顶点的度 = 第 i 行元素之和 + 第 i 列元素之和</strong></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50ed60f0.png" alt="在这里插入图片描述"></p><h5 id="c-有权图（网）的邻接矩阵表示法">c.有权图（网）的邻接矩阵表示法</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50eb310f.png" alt="在这里插入图片描述"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50f02fc2.png" alt="在这里插入图片描述"></p><h4 id="2-邻接表（顺序存储与链式存储结合）">2.邻接表（顺序存储与链式存储结合）</h4><p>![<img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50f9e1aa.png" alt="åœ¨è¿™é‡Œæ’å"><br><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b50fd32c4.png" alt="在这里插入图片描述"></p><h5 id="a-无向图的邻接表">a.无向图的邻接表</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5105fedc.png" alt="img"></p><h5 id="b-有向图的邻接表与逆邻接表">b.有向图的邻接表与逆邻接表</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5108eb3f.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-trpuTIAt-1641217649145)(myReviewPicture/有向图的邻接表.jpeg)]"></p><h5 id="c-带权值的网图">c.带权值的网图</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b510a808e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ah5zBlPv-1641217649146)(myReviewPicture/网图的邻接表.png)]"></p><h3 id="三、图的遍历">三、图的遍历</h3><h5 id="1、深度优先遍历算法">1、深度优先遍历算法</h5><blockquote><p>深度优先搜索类似于树的先序遍历。</p><p>其基本思想是：</p><ul><li>首先访问起始顶点v，然后由v出发，访问与<strong>v 邻接且未被访问</strong>的任一顶点w1，再访问<strong>与w1 邻接且未被</strong>访问的任一顶点W2……重复上述操作。</li><li>当<strong>不能再继续向下访问</strong>时，依次<strong>退回到最近被访问的顶点</strong>，若它还有邻接顶点<strong>未被访问过</strong>，则从该点开始<strong>继续上述搜索过程</strong>，直至图中所有顶点均被访问过为止。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5107057c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tAlBFL32-1641217649146)(myReviewPicture/深度优先遍历.png)]"></p><blockquote><p>从顶点a 出发，进行深度优先遍历，可以得到的一种顶点序列为：a e d f c b</p></blockquote><h5 id="2、广度优先遍历算法">2、广度优先遍历算法</h5><blockquote><p>广度优先搜索类似于二叉树的层序遍历算法。</p><p>其基本思想是：</p><ul><li>首先访问起始顶点v，接着由ν出发，依次访问v 的各个<strong>未访问过的邻接顶点</strong>W1，W2，…，Wi，然后依次访问W1，W2，…，Wi的<strong>所有未被访问过的邻接顶点</strong>；</li><li>再从<strong>这些访问过的顶点</strong>出发，访问它们<strong>所有未被访问过的邻接顶点</strong>，直至图中的<strong>所有顶点都被访问过为止</strong>。</li><li>若此时图中<strong>尚有顶点未被访问</strong>，则另选图中的<strong>一个未被访问的顶点作为始点</strong>，重复上述过程，直至图中<strong>所有顶点都被访问到为止</strong>。</li></ul></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b510a84bf.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4dDjFgZo-1641217649147)(myReviewPicture/广度优先遍历.png)]"></p><blockquote><p>从顶点1 出发，按照广度优先规则遍历，可以得到的一种顶点序列是： 1234576</p></blockquote><h3 id="二、最小生成树">二、最小生成树</h3><h5 id="1、性质">1、性质</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51135fb1.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hfg0lPhL-1641217649147)(myReviewPicture/最小生成树的性质.png)]"></p><h5 id="2、Prim算法">2、Prim算法</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5117aae2.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uhZfCQrh-1641217649147)(myReviewPicture/Prim算法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b511db373.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hrqqoFVo-1641217649148)(myReviewPicture/最小生成树Prim算法.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b511dbe59.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-te5iPtxy-1641217649149)(myReviewPicture/最小生成树Prim算法2.png)]"></p><h5 id="3、Kruskal算法">3、Kruskal算法</h5><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51210bca.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-l7q0KxrC-1641217649149)(myReviewPicture/Kruskal算法.png)]"></p><h4 id="三、拓扑排序">三、拓扑排序</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51278094.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UnFfZk1Y-1641217649149)(myReviewPicture/拓扑排序.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b512b3ab5.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zr1pgvkl-1641217649150)(myReviewPicture/拓扑排序例题.png)]"></p><h5 id="四、最短路径">四、最短路径</h5><h6 id="迪杰斯特拉算法">迪杰斯特拉算法</h6><blockquote><p>通过迪杰斯特拉算法计算图G中的最短路径时，需要指定起点s。</p><p>此外，需要引进两个集合S和U。</p><ul><li>S的作用：记录<strong>已求出最短路径的顶点</strong>（以及<strong>相应的最短路径长度</strong>），</li><li>U的作用：记录<strong>还未求出最短路径的顶点</strong>（以及<strong>该顶点到起点s的距离</strong>）。</li><li>初始时，S中只有起点s；</li><li>U中是除s之外的顶点，并且U中顶点的路径是“起点s到该顶点的路径”。</li><li>然后，从U中找到路径最短的顶点，并将其加入到S中；<ul><li>接着，更新U中的顶点和顶点对应的路径。</li><li>然后，再从U中找到路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。</li><li>重复上述操作，直到遍历完所有顶点。</li></ul></li></ul></blockquote><h6 id="具体过程">具体过程</h6><p><strong>1、初始化，所有顶点的距离初始化为无穷大（INFINITY)</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51308072.png" alt="img"></p><p><strong>2、选定点A，更新（A-A距离设为0)</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b514afd17.png" alt="img"></p><p><strong>3、S集合为{A,B}，考察B的所有邻接点</strong></p><blockquote><p><strong>为什么选定B加入集合S？</strong><br><strong>因为不可能还有其他路径比2还短，我不管经过C到B还是D到B都不可能是路径小于2，所以我们得到了A-&gt;B的最短路径</strong></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b514ca7e1.png" alt="img"></p><blockquote><p>做完这一步，下一步加入集合S的是D<br>因为目前A-&gt;D的路径长度最短，为3（我已经知道了A直接到D和A经过B到D的路径长度）<br>如果A-&gt;B-&gt;X-&gt;D小于min{A-&gt;D,A-&gt;B-&gt;D},那么A-&gt;B-&gt;X小于min{A-&gt;D,A-&gt;B-&gt;D}，那么加入集合的应该是X，这是矛盾的（接下来的操作都是一样的道理</p></blockquote><p><strong>4、S集合为{A,B,D}，在U中没有D的邻接点，不操作</strong></p><p><strong>5、S集合为{A,B,D,C}，在U中没有C的邻接点，不操作</strong></p><p><strong>6、S集合为{A,B,D,C,F}，更新</strong></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5151bee3.png" alt="img"></p><p><strong>7、S集合为{A,B,D,C,F,E}，在U中没有E的邻接点，不操作</strong></p><p><strong>8、S集合为{A,B,D,C,F,E,G}，在U中没有G的邻接点，不操作</strong></p><p><strong>9、最终结果如上图</strong>。</p><h2 id="———排序———">———排序———</h2><h3 id="一、排序的类别">一、排序的类别</h3><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b515628d0.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBiNgFub-1641217649151)(myReviewPicture/排序.png)]"></p><h3 id="1、插入排序">1、插入排序</h3><h4 id="基本思想：">基本思想：</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5159f561.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-W5Hwkv7f-1641217649151)(assets/插入排序基本思想.png)]"></p><h5 id="【1】直接插入排序">【1】直接插入排序</h5><h6 id="（1、基本思想：">（1、基本思想：</h6><blockquote><p>1）、将待排序的一组序列（有N个数）分为<strong>已排好的</strong>和<strong>未排好的</strong> 2个部分；</p><p>2）、初始状态时，已排序序列<strong>仅包含第1 个元素</strong>，未排序序列中的元素为除去<strong>第1 个元素意外的N-1 个元素</strong>；</p><p>3）、此后，将未排序序列中的元素逐一插入到已排序的序列中；</p><p>4）、如此往复，经过<strong>N-1 次</strong>插入后，未排序序列中元素个数为0 ，则排序完成。</p></blockquote><h6 id="（2、执行过程">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b514dae70.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7EB0PiaP-1641217649152)(myReviewPicture/直接插入排序例题1.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b516309b7.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-59uBl571-1641217649152)(myReviewPicture/直接插入排序2.png)]"></p><h6 id="（3、时空效率及稳定性">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5165dced.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SxUpnfwg-1641217649152)(myReviewPicture/直接插入时空效率.png)]"></p><h5 id="【2】希尔排序">【2】希尔排序</h5><h6 id="（1、基本思想：-2">（1、基本思想：</h6><blockquote><p>1）、将带排序序列的一组元素按<strong>一定间隔</strong>分为<strong>若干序列</strong>分别进行<strong>插入排序</strong>；</p><p>2）、开始时设置的“<strong>间隔</strong>”较大，在每轮排序中，将**”间隔“逐步缩小**</p><p>3）、直到“间隔”为 1，也就到了最后一步，做<strong>简单插入排序</strong>。</p></blockquote><h6 id="（2、执行过程-2">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51667024.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-auVhyLOw-1641217649153)(myReviewPicture/希尔排序2.png)]"></p><h6 id="（3、时空效率及稳定性-2">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5168aecd.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ux0GsKAK-1641217649153)(myReviewPicture/希尔排序3.png)]"></p><h3 id="2、交换排序">2、交换排序</h3><h4 id="基本思想：-2">基本思想：</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5172f337.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZgGwNJn5-1641217649154)(myReviewPicture/交换排序基本思想.png)]"></p><h5 id="【1】冒泡排序">【1】冒泡排序</h5><h6 id="（1、基本思想：-3">（1、基本思想：</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5172fa98.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zJfYxzHa-1641217649155)(myReviewPicture/冒泡排序基本思想.png)]"></p><h6 id="（2、执行过程-3">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b5177290b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-95qkCnr1-1641217649155)(myReviewPicture/冒泡排序执行过程.png)]"></p><h6 id="（3、时空效率及稳定性-3">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51775f1e.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xRUZHEtW-1641217649155)(myReviewPicture/冒泡排序时空效率.png)]"></p><h5 id="【2】快速排序">【2】快速排序</h5><h6 id="（1、基本思想：-4">（1、基本思想：</h6><blockquote><p>1)、将未排序元素根据一个作为<strong>基准</strong>的“主元（pivot）分为<strong>两个子序列</strong>；</p><p>2）、其中一个子序列的记录<strong>均大于</strong>“主元”，另一个序列则<strong>均小于</strong>“主元；</p><p>3）、<strong>递归</strong>地对两个子序列用<strong>类似的方法</strong>进行排序。</p></blockquote><h6 id="（2、执行过程-4">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51776a58.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8y2pVgAJ-1641217649155)(myReviewPicture/快速排序例题1.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b517d5abc.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Q4MhHTt1-1641217649156)(myReviewPicture/插入排序例题2.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51915b7d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YNkG7K8J-1641217649156)(myReviewPicture/插入排序3.png)]"></p><h6 id="（3、时空效率及稳定性-4">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51986b15.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E3u9CHCI-1641217649156)(myReviewPicture/插入排序时空效率.png)]"></p><h3 id="3、选择排序">3、选择排序</h3><h4 id="基本思想：-3">基本思想：</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519c39ea.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6WCpUUz3-1641217649157)(myReviewPicture/选择排序的基本思想.png)]"></p><h4 id="【1】简单选择排序">【1】简单选择排序</h4><h6 id="（1、基本思想：-5">（1、基本思想：</h6><blockquote><p>1）、在未排序的序列中选出最小元素和序列的<strong>首位元素</strong>交换，</p><p>2）、再在剩下的排序序列中再选出最小元素与序列的第2 个位置元素交换</p><p>3）、以此类推，最后形参从小到大的已排序序列。</p></blockquote><h6 id="（2、执行过程-5">（2、执行过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519bfb9d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eenzDDlH-1641217649158)(myReviewPicture/简单选择排序执行过程.png)]"></p><h6 id="（3、时空效率及稳定性-5">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519d7fa4.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HhrGBaPc-1641217649158)(myReviewPicture/简单选择排序3.png)]"></p><h4 id="【2】堆排序">【2】堆排序</h4><h6 id="（1、基本思想：-6">（1、基本思想：</h6><blockquote><p>1）、利用**最大堆（或最小堆）*<em>输出*<em>堆顶元素</em></em>，即最大值（或最小值）；</p><p>2）、将剩余元素重新生成<strong>最大堆（或最小堆）</strong>，继续输出<strong>堆顶元素</strong>；</p><p>3）、重复此过程，知道全部元素都已输出，得到的输出元素序列即为有序序列</p></blockquote><h6 id="（2、执行过程要点">（2、执行过程要点</h6><h6 id="1-初始化堆的过程">&lt;1&gt;初始化堆的过程</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b519d2889.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BUmqOTks-1641217649159)(myReviewPicture/执行过程.png)]"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/da8a3cffadcfae675e33943af636920d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-amUvD16w-1641217649159)(myReviewPicture/堆排序.png)]"></p><blockquote><p><strong>下面是构建初始堆的过程</strong></p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b18889.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WbussFeE-1641217649160)(myReviewPicture/堆排序2.png)]"></p><blockquote><p>下面是堆排序的过程</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b3f894.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jBlnfC3t-1641217649160)(myReviewPicture/堆排序1.png)]"></p><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b4c648.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sWcyGiCK-1641217649160)(assets/image-20220103210541040.png)]"></p><h6 id="（3、时空效率及稳定性-6">（3、时空效率及稳定性</h6><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51b4c652.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GOajy21Q-1641217649161)(myReviewPicture/堆排序空间效率.png)]"></p><h4 id="4、归并排序">4、归并排序</h4><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51bacb3c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-g1lLA8Bd-1641217649161)(myReviewPicture/归并排序.png)]"></p><h4 id="二、各种排序的比较">二、各种排序的比较</h4><h4 id="口诀：快选堆希不稳，选堆归基不变">口诀：快选堆希不稳，选堆归基不变</h4><blockquote><p>不稳：说的是 算法不稳定</p><p>不变：说的是 关于移动次数和关键字顺序无关的排序</p></blockquote><p><img src="https://free-img.400040.xyz/4/2024/07/31/66a9b51c46944.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Srey30WJ-1641217649161)(myReviewPicture/各种排序的比较.png)]"></p><p>end</p>]]></content>
    
    
    <summary type="html">数据结构知识点总结其二</summary>
    
    
    
    <category term="笔记" scheme="https://zhongye1.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
